{	"classes" : {		"Array2D" : {			"hash" : 856320,			"definition" : "Collection subclass: #Array2D\r\tinstanceVariableNames: 'contents numberOfColumns numberOfRows'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Ordered'",			"comment" : [				"I represent a mathematical matrix or a two-dimensional array. I provide methods for creating matrices, operating on them arithmetically and algebraically. ",				"",				"Structure:",				" - numberOfRows : a non-negative integer saying how many rows there are.",				" - numberOfColumns : a non-negative integer saying how many columns there are.",				" - contents : an Array holding the elements in row-major order.  That is, for a 2x3 array the contents are (11 12 13 21 22 23).  ",				"",				"",				"Element-wise matrix arithmetic works; you can freely mix matrices and numbers but",				"don't try to mix matrices and arrays (yet).",				"Matrix multiplication, using the symbol +* (derived from APL's +.x), works between",				"(Matrix or Array) +* (Matrix or Array).  Don't try to use a number as an argument of +*.",				"Matrix * Number and Number * Matrix work fine, so you don't need +* with numbers."			],			"category" : "Collections-Sequenceable-Ordered"		},		"AlienWeakTable" : {			"hash" : 486144,			"definition" : "Object subclass: #AlienWeakTable\r\tinstanceVariableNames: 'accessProtect firstUnusedIndex lastUsedIndex weakArray strongArray owner'\r\tclassVariableNames: ''\r\tpackage: 'Alien-Core'",			"comment" : [				"This class supports simple post-mortem finalization of values associated with gc'ed objects.  An object to be finalized is registered in the table together with another object called 'the tag'. The finalizable object is held onto by the table weakly, the tag object--strongly. A table is initialized with the owner object, which is the object that performs the actual finalization. Some time after a finalizable object is garbage-collected, the owner is sent the #finalize: message with the object's tag as the argument.",				"",				"Instance Variables:",				"\taccessProtect <Semaphore>  - A mutex protecting state",				"\tfirstUnusedIndex <Integer> - The lowest index in strongArray that is empty (an invariant)",				"\tlastUsedIndex <Integer> - The highest index in strongArray that is not empty (an invariant)",				"\tweakArray <WeakArray> - The array of objects whose death we're interested in.",				"\tstrongArray <Array> - The array of corresponding objects that wll be passed to the owner when their corresponding element in weakArray is garbage collected.",				"\towner <Object> - The object that is sent finalize: with the tag of an object that has been garbage-collected."			],			"category" : "Alien-Core"		},		"ExecutionCounter class" : {			"hash" : 3337472,			"definition" : "ExecutionCounter class\r\tinstanceVariableNames: ''",			"comment" : [				"I am a meta-object that can be put on any AST node to count execution",				"",				"To install a watchpoint in a node: ",				"\tExecutionCounter installOn: aNode",				"\t",				"Class CounterIconStyler then renders an icon in the editor, mouse over it to see the current counter value."			],			"category" : "Reflectivity-Breakpoints"		},		"SpTPresenterBuilder" : {			"hash" : 2229504,			"definition" : "Trait named: #SpTPresenterBuilder\r\tinstanceVariableNames: ''\r\tpackage: 'Spec2-Core-Base'",			"comment" : [				"A builder to define presenters through method factory pattern. ",				"This allow users to compose presenters without needed to have hardcoded the name of them (which could or not change/be present/etc.)"			],			"category" : "Spec2-Core-Base"		},		"DoubleLinkedList" : {			"hash" : 1629952,			"definition" : "Object subclass: #DoubleLinkedList\r\tinstanceVariableNames: 'head tail'\r\tclassVariableNames: ''\r\tpackage: 'Collections-DoubleLinkedList-Base'",			"comment" : [				"I am DoubleLinkedList, an ordered list data structure consisting of objects, most likely DoubleLinks or something compatible, connected to each other by forward and backwards links.",				"",				"Note that some of my API deals with the elements that I hold, like any other collection, while some of my API references the links that I use internally (those usually have the word link in the selector name). Some methods accepts both values or links as argument (like #add:). Because I expose some if my internal structure, I can be broken quite easily.",				""			],			"category" : "Collections-DoubleLinkedList-Base"		},		"ArrayedCollection" : {			"hash" : 854528,			"definition" : "SequenceableCollection subclass: #ArrayedCollection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am an abstract collection of elements with a fixed range of integers (from 1 to n>=0) as external keys."			],			"category" : "Collections-Abstract-Base"		},		"CTLinkedStoragePoolStack" : {			"hash" : 7638272,			"definition" : "CTLinkedStoragePool subclass: #CTLinkedStoragePoolStack\r\tinstanceVariableNames: 'top'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\ttop:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"IRStackCount" : {			"hash" : 1242880,			"definition" : "Object subclass: #IRStackCount\r\tinstanceVariableNames: 'start position length'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-Bytecode'",			"comment" : [				"This keeps track of the stack count for the BytecodeGenerator."			],			"category" : "OpalCompiler-Core-Bytecode"		},		"LGitIndex" : {			"hash" : 6555392,			"definition" : "LGitRepositoryObject subclass: #LGitIndex\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'LibGit-Core-CoreObjects'",			"comment" : [				"The Git index is used as a staging area between your working directory and your repository. One can use the index to build up a set of changes thatone wants to commit together."			],			"category" : "LibGit-Core-CoreObjects"		},		"Stack" : {			"hash" : 1148160,			"definition" : "LinkedList subclass: #Stack\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Stack-Base'",			"comment" : [				"I implement a simple Stack. #push: adds a new object of any kind on top of the stack. #pop returns the first element and remove it from the stack. #top answer the first element of the stack without removing it."			],			"category" : "Collections-Stack-Base"		},		"Bag" : {			"hash" : 863744,			"definition" : "Collection subclass: #Bag\r\tinstanceVariableNames: 'contents'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Bags'",			"comment" : [				"I represent an unordered collection of possibly duplicate elements.",				"\t",				"I store these elements in a dictionary, tallying up occurrences of equal objects. Because I store an occurrence only once, my clients should beware that objects they store will not necessarily be retrieved such that == is true. If the client cares, a subclass of me should be created."			],			"category" : "Collections-Unordered-Bags"		},		"WideCharacterSet" : {			"hash" : 1189888,			"definition" : "Collection subclass: #WideCharacterSet\r\tinstanceVariableNames: 'map byteArrayMap'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-CharacterSets'",			"comment" : [				"WideCharacterSet is used to store a Set of WideCharacter with fast access and inclusion test.",				"",				"Implementation should be efficient in memory if sets are sufficently sparse.",				"",				"Wide Characters are at most 32bits.",				"We split them into 16 highBits and 16 lowBits.",				"",				"map is a dictionary key: 16 highBits value: map of 16 lowBits.",				"",				"Maps of lowBits  are stored as arrays of bits in a ByteArray.",				"If a bit is set to 1, this indicate that corresponding character is present.",				"8192 bytes are necessary in each lowmap.",				"Empty lowmap are removed from the map Dictionary.",				"",				"A byteArrayMap is maintained in parallel with map for fast handling of ByteString.",				"(byteArrayMap at: i+1) = 0 means that character of asciiValue i is absent, = 1 means present."			],			"category" : "Collections-Support-CharacterSets"		},		"ProcessList" : {			"hash" : 1094400,			"definition" : "SequenceableCollection subclass: #ProcessList\r\tinstanceVariableNames: 'firstLink lastLink'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Processes'",			"comment" : [				"I am a VM Special class! Do not break me!",				"",				"I am a linked list that contains processes as Nodes. My implementation is tied to the VM: ",				"- every node I contain should have as first instance variable the next node in the list.",				"",				"My main user is ProcessScheduler, which contains an array with instances of myself. Each entry in that array a priority for processes. Processes are queues in each process list by the VM automatically."			],			"category" : "Kernel-Processes"		},		"DictionaryValueHolder" : {			"hash" : 650496,			"definition" : "NewValueHolder subclass: #DictionaryValueHolder\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'NewValueHolder-Core-Base'",			"comment" : [				"I am designed specifically for dictionaries."			],			"category" : "NewValueHolder-Core-Base"		},		"CharacterSet" : {			"hash" : 883712,			"definition" : "Collection subclass: #CharacterSet\r\tinstanceVariableNames: 'map'\r\tclassVariableNames: 'CrLf'\r\tpackage: 'Collections-Support-CharacterSets'",			"comment" : [				"A set of characters: ",				"",				"- Lookups for inclusion are very fast.",				"- CharacterSet will automatically convert itself to a WideCharacterSet if a character with value > 255 is added.",				"- Tests for inclusion can be done on any Character value (up to Character maxVal).",				"",				"See the package comments for a description of how each of the classes in Collections-Support-CharacterSets is used."			],			"category" : "Collections-Support-CharacterSets"		},		"LIFOQueue" : {			"hash" : 1096960,			"definition" : "AtomicCollection subclass: #LIFOQueue\r\tinstanceVariableNames: 'head'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Atomic-Base'",			"comment" : [				"This is a thread-safe LIFO (last-in-first-out) queue (also known as stack) implementation,",				"based on atomic operations."			],			"category" : "Collections-Atomic-Base"		},		"OrderedDictionary" : {			"hash" : 1083904,			"definition" : "Collection subclass: #OrderedDictionary\r\tinstanceVariableNames: 'dictionary orderedKeys'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Ordered'",			"comment" : [				"I am a collection that act as a Dictionary except that I use key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality (but it does not matters in this case).",				"I will assume that you know the Dictionary class in this comment.",				"",				"I work mainly as a Dictionary except that I also store the keys in an Array that keeps the order of elements. ",				"I should be used ONLY if you need to keep the keys ordered. Else you should use a Dictionary that is faster and keep less values into memory. (I duplicate the keys).",				"Insertion, update, and inclusion testing have O(1) complexity while removing has O(n) worst-case.",				"",				"### Public API and Key Messages",				"",				"- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue / #at: aKey ifPresent: aBlock ifAbsent: aBlock\t\tallow to add an element.  ",				"- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.",				"- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively.",				"- #keyAtIndex: anIndex / KeyAtIndex: anIndex ifAbsent: aBlock \t\tallow to acess my keys from an index.",				"",				"### Examples",				"\t\"For basic examples see Dictionary comment.\"",				"```\t",				"\tordDic := (Dictionary with: 1 -> $a with: 2 -> $b) asOrderedDictionary.",				"\tordDic.   \t\t\"returns:  an OrderedDictionary(1->$a 2->$b)\"",				"\tordDic keyAtIndex: 2.\t\t\"returns:  2\"",				"```",				"\t",				"### Internal Representation and Key Implementation Points.",				"Instance Variables",				"-\tdictionary:\t\t\t<Dictionary>\t\tA dictionary where I store my keys and values.",				"-\torderedKeys:\t\t<Array>\t\t\tAn ordered collection where I store my keys to maintain the order.",				"",				"I base my implementation on a Dictionary and when I need to execute an action where the order of the values is important I use the keys in my ordered collection."			],			"category" : "Collections-Sequenceable-Ordered"		},		"MethodDictionary" : {			"hash" : 826112,			"definition" : "Dictionary variableSubclass: #MethodDictionary\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Methods'",			"comment" : [				"I'm a special dictionary holding methods. I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instance of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.",				"",				"In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  ",				"",				"Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.",				"",				"About flushCache methods and usage.",				"",				"The VM caches method lookups in a lookup cache from class,selector pairs to method,primitive pairs, where primitive may be null.  This is called the first-level method lookup cache.  The JIT VM caches message lookups in machine code, so that a particular piece of machine code exists in a state that invokes a method for a specific class very fast by embedding the class reference in a register load and the target method in a call instruction, and having the target method verify this \"cache probe\" (this is an \"in-line cache).  The JIT also caches the translation of a byte coded method to machine code, by hiding a reference to a machine code method in a byte coded method.",				"",				"These caches can be invalidated in several circumstances:",				"",				"1a. if one adds or removes a method from a class's method dictionary it may change the correct results of a lookup not merely of the class whose dictionary was updated but also subclasses of the class.",				"1b. if one replaces a method in a method dictionary this changes the target method for a lookup of the selector for the class and subclasses",				"",				"2. if one wants to rewrite the byte code or literals of a method, for example because a Slot definition has changed, then if the method has been compiled to machine code, the machine code must be discarded before the new code may be executed",				"",				"1a & 1b are done via Symbol>>flushCache.  In response the normal VM flushes its first-level method lookup cache, and the JIT also scans all of machine code looking for inline caches with that selector, and voiding them, reverting each send site for that selector to the \"unlinked\" state.",				"",				"There used to be confusion in Squeak, which Pharo inherited, that using CompiledMethod>>flushCache was somehow the right way to void caches when updating method dictionaries, flushing the old method in the dictionary, if any, and the new method.  It isn't, precisely because adding or removing methods affects the visibility of inherited methods with the same selector.  So MethodDictionary code should use Symbol>>flushCache, and only once, on each update of a method dictionary.  As a result, the VM will ensure that the necessary send caches are flushed for that selector.",				"",				"2. is done via CompiledMethod>>flushCache.  In response the VM searches the first-level method lookup cache and removes all entries whose target is the method.  In addition the JIT discards the machine code for the method, and searches for all send sites with that method's machine code as the target and voids them, reverting them to the unlinked state.",				"",				"The VM must be told to flush the cached state for a compiled method via CompiledMethod>>flushCache and will /try/ and void the state for that method.  But it can't always deal with existing activations of that method, because if there are activations running the machine code, that machine code can't merely be thrown away, and can't be replaced because its length may change, depending on literals or byte codes.  So this kind of byte coded method manipulation needs to be done with case and some understanding of the total system state."			],			"category" : "Kernel-Methods"		},		"SpPresenter" : {			"hash" : 2274048,			"definition" : "SpAbstractPresenter << #SpPresenter\r\ttrait: SpTPresenterBuilder;\r\tslots: {\r\t\t\t #application .\r\t\t\t #focusOrder .\r\t\t\t #contextKeyBindings => ObservableSlot .\r\t\t\t #windowIcon => ObservableSlot .\r\t\t\t #aboutText => ObservableSlot .\r\t\t\t #askOkToClose => ObservableSlot .\r\t\t\t #titleHolder => ObservableSlot .\r\t\t\t #additionalSubpresentersMap .\r\t\t\t #layout => ObservableSlot .\r\t\t\t #visible => ObservableSlot .\r\t\t\t #extent => ObservableSlot .\r\t\t\t #styles };\r\ttag: 'Base';\r\tpackage: 'Spec2-Core'",			"comment" : [				"SpPresenter is an abstract class which represent a applicative presenter made to be composed with other SpPresenter",				"",				"Most often, I am used to display other subclasses of SpPresenter or subclasses of SpAbstractWidgetPresenter.",				"",				"I collaborate with ",				"- ValueHolder to managed some of my variables.",				"- SpecFocusOrder when no focusOrder are specified.",				"- SpecLayout",				"- WindowPresenter or DialogWindowPresenter to display myself.",				"",				"A new subclass of SpPresenter must at least define initializeWidgets and defaultSpec on the class side.",				"",				"I provide the following methods",				"- aboutText: set the text displayed in the About.",				"- initializeWindow: to set the title, and other information related to the window.",				"- extent: set the initial size of the window, alternative possibility is define again initialExtent, it must be called before have displayed the widget. ",				"- focusOrder: set an instance what manage the order of focus of the keyboard navigation.",				"- bindKeyCombination:toAction: create a shortcut on keyboard what perform the block of the  action.",				"- owner getter of my parent.",				"- window getter of the window displaying me.",				"",				"On my class side, I provide methods returning standard height and width for some elements.",				"",				"todo",				"- announce:",				"- applyMenuModel: and neglectMenuModel:",				"- keyStrokeForNextFocus:, giveFocusToNextFrom: and takeKeyboardFocus",				"- ensureExtentFor:",				"- hide",				"- needRebuild",				"- on:do:",				"- update:",				"- widget",				"",				"Window",				"=======",				"",				"- openWithSpec instantiates a WindowPresenter using the lookup to found the layout to use.",				"- openDialogWithSpec instanciates a DialogWindowPresenter using the lookup to found the layout to use.",				"Their variants openWithSpec: and openDialogWithSpec:  use the layout parameter.",				"",				"These methods can be useful to manage the window",				"- isDisplayed returns true if the window of the widget is displayed",				"- hasWindow returns true if the widget have a window",				"- centered to center the window in the world.",				"- delete to delete the window.",				"",				"todo",				"- cancelled",				"- setModal:",				"- windowIcon:",				"",				"",				"Instantiation",				"===========",				"",				"* initializeWidgets is called by the initialize method, it should contain initialization of subwidgets and of the focusorder.",				"",				"The instantiation of a subwidget should use one of that way",				"- instantiate: take a class in parameter and return the created instance.",				"- methods named 'new' followed by a widget name are shortcut working with instatiate:",				"",				"Usually, the subwidgets must be added in the focusOrder using something like 'self focusOrder add: accessor of  the  subwidget'",				"",				"Note that instantiateModels: is legacy code in ComposablePresenter and must not be used. It will be deprecated and removed.",				"",				"* initializePresenter is called by the initialize method after initializeWidgets, it should manage interaction of subwidgets.",				"",				"Methods named 'when' followed by an event provide hook to perform the action in parameter.",				"",				"Note",				"-------",				"Be careful about code order if you are overriding initialize method.",				"Normally in Spec initializing instance variables should be done BEFORE calling super initialize (so the opposite of the normal approach), because super initialize calls initalizeWidgets and initializePresenter that normally would make use of those variables.",				"",				"Layout",				"======",				"",				"See SpecLayout",				"",				"defaultSpec or a method containing the pragma <spec: #default> must be defined in the class side of my subclasses.",				"It contains informations about how place its elements.",				"It possible to define more than one method to give the possibility to use another layout, by default the one containing the pragma will be used if it exists, if not defaultSpec will be used."			],			"category" : "Spec2-Core-Base"		},		"StSpotter" : {			"hash" : 6145792,			"definition" : "StPresenter subclass: #StSpotter\r\tinstanceVariableNames: 'searchText resultList model previewContainer categories mutex spinner tip queue updating lastSelectedEntry lastUpdateTime'\r\tclassVariableNames: 'History PreviewVisible Tips TipsVisible'\r\tpackage: 'NewTools-Spotter-View'",			"comment" : [				"When exploring the system, is useful to have a single entry point that will allow users to search for different component of the system. ",				"Spotter provides such entry point and is usually available by pressing <meta+enter>.",				"",				"Spotter is just a front-end to show the result of different processors (see *StSpotterProcessor*) that provide results. Those processors can be configured in different ways and will provide different access options. ",				"",				"Some known processors and options are: ",				"",				"## Classes processor: ",				"- Type #classes in the search bar",				"- Press <meta+b>",				"",				"## Implementors processor: ",				"- Type #implementors in the search bar",				"- Press <meta+m>",				"",				"## Senders processor: ",				"- Type #senders in the search bar",				"- Press <meta+n>"			],			"category" : "NewTools-Spotter-View"		},		"CharacterSetComplement" : {			"hash" : 884480,			"definition" : "Collection subclass: #CharacterSetComplement\r\tinstanceVariableNames: 'absent byteArrayMapCache'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-CharacterSets'",			"comment" : [				"CharacterSetComplement is a space efficient implementation of (CharacterSet complement) taking care of WideCharacter (code > 255)",				"",				"However, it will maintain a byteArrayMap for character <= 255 in a cache for performance",				"",				"instance variables:",				"\tabsent <CharacterSet> contains character that are not in the set (i.e. my complement)",				"\tbyteArrayMapCache <ByteArray | nil> cache this information because it has to be used in tight loops where efficiency matters"			],			"category" : "Collections-Support-CharacterSets"		},		"SpMorphicBoxAdapter" : {			"hash" : 2902784,			"definition" : "SpMorphicLayoutAdapter subclass: #SpMorphicBoxAdapter\r\tinstanceVariableNames: 'startPanel endPanel'\r\tclassVariableNames: ''\r\tpackage: 'Spec2-Adapters-Morphic-Layout'",			"comment" : [				"I'm an adapter for Box Layouts.",				"A paned layout will split (horizontally or vertically) panels (in fixed yet proportional spaces)."			],			"category" : "Spec2-Adapters-Morphic-Layout"		},		"Context" : {			"hash" : 9216,			"definition" : "InstructionStream variableSubclass: #Context\r\tinstanceVariableNames: 'stackp method closureOrNil receiver'\r\tclassVariableNames: 'PrimitiveFailToken SpecialPrimitiveSimulators TryNamedPrimitiveTemplateMethod'\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Instance variables:",				"\treceiver: <Object> (self)",				"\tclosureOrNil: <BlockClosure|nil> ",				"\t\tnil if I'm a method context",				"\t\tthe blockClosure being executed if I'm a block context",				"\tmethod <CompiledMethod> ",				"\t\tmethod being executed if I'm a method context",				"\t\tmethod holding the block if I'm a block context",				"\tvariable fields: <Object> temporary variables (including arguments)",				"",				"My instances hold all the dynamic state associated with the execution of either a method activation resulting from a message send or a block activation resulting from a block evaluation.",				"\t",				"MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.",				"",				"MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal."			],			"category" : "Kernel-Methods"		},		"AbstractCache" : {			"hash" : 1630976,			"definition" : "Object subclass: #AbstractCache\r\tinstanceVariableNames: 'factory statistics weight access'\r\tclassVariableNames: ''\r\tpackage: 'System-Caching'",			"comment" : [				"I am Cache.",				"I am an abstract class.",				"",				"I am a limited cache holding onto key/value pairs.",				"",				"My primary interface is #at:ifAbsentPut: which takes two arguments: a key and a block. Either the key is found (cache hit) and its value is returned, or the key is not found (cache miss). If the latter case, block should compute a new value to cache. Because block takes the key as optional argument, you can specify a factory style argument as well. With an explicit factory specified, you can also use #at: to access me.",				"",				"For each addition to the cache, a weight is computed by #computeWeight (a selector or block) and added to #totalWeight. When #totalWeight is no longer below #maximumWeight, the least recently used item of the cache is evicted (removed) to make room. ",				"",				"The default #computeWeight returns 1 for each value, effectively counting the number of entries. The default #maximumWeight is 16.",				"",				"I count hits and misses and can return my #hitRatio.",				"",				"Optionally, but not by default, I can be configured so that it is safe to access me from different threads/processes during my important operations. See #beThreadSafe."			],			"category" : "System-Caching"		},		"OrderedCollection" : {			"hash" : 809728,			"definition" : "SequenceableCollection subclass: #OrderedCollection\r\tinstanceVariableNames: 'array firstIndex lastIndex'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Ordered'",			"comment" : [				"I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  ",				"I am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.",				"",				"I am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).",				"",				"### Public API and Key Messages",				"",				"- #new / #withAll: aCollection / #with: anObject \tare common constructors",				"- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject \tallow to add new elements to myself.",				"- #remove: anObject / #removeIndex: anIndex \tallow to remove an element.",				"- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock \tare common iterators.",				"",				"### Examples\t",				"",				"```\t",				"\t\"There is many ways to create an OrderedCollection, here are some:\"",				"\tordCol := OrderedCollection new.",				"\tordCol",				"\t\tadd: 'one';",				"\t\tadd: 'two';",				"\t\taddFirst: 'zero';",				"\t\taddLast: 'three'.",				"\tordCol.\t\t\"returns: an OrderedCollection('zero' 'one' 'two' 'three')\"",				"",				"\t\"or\"",				"\tordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.",				"\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"",				"",				"\t\"or from an other collection\"",				"\tordCol := OrderedCollection withAll: #('one' 'two' 'three').",				"\tordCol.\t\t\"returns: an OrderedCollection('one' 'two' 'three')\"",				"",				"\t\"or\"",				"\t#('one' 'two' 'three') asOrderedCollection.",				"",				"\t\"Some manipulations\"",				"\tordCol := OrderedCollection ofSize: 2.",				"\tordCol",				"\t\tat: 1 put: 'one';",				"\t\tat: 2 put: 'two';",				"\t\tat: 2 ifAbsentPut: 'three'.",				"\tordCol.\t\t\"returns: an OrderedCollection('one' 'two')\"",				"\tordCol",				"\t\tremove: 'two';",				"\t\tremoveIndex: 1.",				"\tordCol.\t\t\"returns:  an OrderedCollection()\"",				"",				"\t\"A last one\"",				"\tordCol := OrderedCollection with: $b with: $c with: $a.",				"\tordCol sort: [ :first :second | first < second ].\t\t\"returns: an OrderedCollection($a $b $c)\"",				"\tordCol collect: [ :element | element asUppercase ].\t\t\"returns:  an OrderedCollection($A $B $C)\"",				"\tordCol select: [ :element | element >= $b ].\t\t\"returns:  an OrderedCollection($b $c)\"",				"\tordCol do: [ :element | element inspect ].",				"\tordCol asArray\t\t\"returns: #($a $b $c)\"",				"``` ",				"",				"###Internal Representation and Key Implementation Points.",				"Instance Variables",				"- array:\t\t\t<Array> \t\tAn Array where I store my elements. If I need a bigger one I can remove this one and create a new one.",				"- firstIndex:\t\t<Integer> \tThe index of my first element.",				"- lastIndex:\t\t<Integer> \tThe index of my last element.",				"",				"I store my elements inside an array. This array is AT LEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double)."			],			"category" : "Collections-Sequenceable-Ordered"		},		"Watch class" : {			"hash" : 3360512,			"definition" : "Watch class\r\tinstanceVariableNames: ''",			"comment" : [				"A Watch save the change of values of expressions. ",				"I save them as an ordered collection of  key val association where the key is the timestamp an val is the actual value of the expression.",				"",				"To install a Watch in a node: ",				"Watch in: aNode"			],			"category" : "Reflectivity-Breakpoints"		},		"SpMillerLayout" : {			"hash" : 2214144,			"definition" : "SpExecutableLayout << #SpMillerLayout\r\ttrait: TObservable;\r\tslots: {\r\t\t\t #direction .\r\t\t\t #spacing .\r\t\t\t #borderWidth .\r\t\t\t #visiblePages => ObservableSlot };\r\ttag: 'Miller';\r\tpackage: 'Spec2-Layout'",			"comment" : [				"I'm a layout to implement miller lists. ",				"Since I am intended to be used dynamically (adding/removing components on demand), I implement just `add:` and `remove:` related methods."			],			"category" : "Spec2-Layout-Miller"		},		"WaitfreeQueue" : {			"hash" : 1095680,			"definition" : "AtomicCollection subclass: #WaitfreeQueue\r\tinstanceVariableNames: 'tail dummy'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Atomic-Base'",			"comment" : [				"This is a thread-safe implementation of a queue with wait-free operations. ",				"It is guaranteed that any message sent to my instance (like adding new item, or fetching item) will not block sender, nor enter a waiting loop.",				"",				"The implementation is based on atomicity of simple assignment operations, which can't be interrupted in a middle,",				"i.e. two assignment statements in a row, like:",				"",				"x := y.",				"y := z.",				"",				"can't be interrupted by interpreter and can be seen as a single atomic operation.",				"",				"",				"This implementation fits best for case, when multiple threads populating queue, but only single thread fetching items from it.",				"",				"In given implementation, inserting new items into queue can't block the sender and insertion operation always takes constant time (if we ignore the possible GC interference here).",				"For reading/polling operations queue using a lock mechanism, which indicating that queue currently in the middle of extraction, and therefore, if some thread obtained a lock upon the queue, other threads must wait till one that obtained the lock will finish its operation(s) and release the lock.",				"All operations which may block the sender will answer the default value(s) instead. ",				"",				"",				"",				"Implementation Notes",				"",				"As mentioned above WaitfreeQueue relies on the VM treating simple assignment operations as uninterruptable.  It also ensures that reader and writer processes can't modify the same variables at the same time.",				"",				"The queue consists of a linked list of AtomicQueueItems.  Each item contains a pointer to the next item and the object which is the queue entry.",				"",				"An item can be:",				"",				"- \"circular\", meaning that the next item is itself.",				"- a \"zombie\", meaning that the object points back to the queue's dummy object (more below).",				"",				"Writing processes create a new item and then use atomic access to get the old tail entry and update the queue's tail variable.  They then own the old tail entry and can update its next variable at any time.  Because the queue's tail variable is updated atomically, any number of writer processes can be adding items to the queue.",				"",				"A reader process uses atomic access to the get first item and make the dummy item circular.  At this point the reader process owns the linked list and can modify any item except the last one (which will be circular).  Any other process attempting to read the queue will find the dummy object is circular and return nil - meaning the queue is either empty or locked.",				"",				"If the reader process wants to return the object from the last item in the linked list (which may be owned by a writer process), it will retrieve the object and then mark the item as a zombie, i.e. set the item's object to the queue's dummy item.  The zombie item will then be removed by a later reader process when it is no longer last in the linked list.",				"",				"Once the reader process has retrieved the object it sets the dummy item's next variable to the first item in the linked list, making the queue avilable again to other processes."			],			"category" : "Collections-Atomic-Base"		},		"FileSystemGuide" : {			"hash" : 1280256,			"definition" : "Object subclass: #FileSystemGuide\r\tinstanceVariableNames: 'visitor work selectChildren'\r\tclassVariableNames: ''\r\tpackage: 'FileSystem-Core-Base-Guide'",			"comment" : [				"I am an abstract superclass for objects that fulfill the Guide role in the Guide/Visitor pattern. My subclasses know how to traverse a filesystem in a specific order, \"showing\" the files and directories they encounter to a visitor.",				"",				"visitor",				"\tAn object that fulfills the Visitor role and implements the visitor protocol.",				"\t",				"work",				"\tAn OrderedCollection, used to keep track of filesystem nodes that have not yet been visited"			],			"category" : "FileSystem-Core-Base-Guide"		},		"SpCollectionListModel" : {			"hash" : 2244352,			"definition" : "Object << #SpCollectionListModel\r\ttrait: TObservable;\r\tslots: {\r\t\t\t #announcer .\r\t\t\t #collection .\r\t\t\t #sorting => ObservableSlot };\r\ttag: 'Widgets-Table';\r\tpackage: 'Spec2-Core'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tannouncer:\t\t<Object>",				"\tcollection:\t\t<Object>",				"\tsorting:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Spec2-Core-Widgets-Table"		},		"ZnCookieJar" : {			"hash" : 1396992,			"definition" : "Object subclass: #ZnCookieJar\r\tinstanceVariableNames: 'cookies'\r\tclassVariableNames: ''\r\tpackage: 'Zinc-HTTP-Support'",			"comment" : [				"I represent a container for storing HTTP Cookies for a client session.",				"",				"Part of Zinc HTTP Components."			],			"category" : "Zinc-HTTP-Support"		},		"CTLinkedStoragePoolTest" : {			"hash" : 7640320,			"definition" : "TestCase subclass: #CTLinkedStoragePoolTest\r\tuses: TIceImagesExporting\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "Containers-LinkedStoragePool-Tests"		},		"FLSimpleStack" : {			"hash" : 1725184,			"definition" : "Object subclass: #FLSimpleStack\r\tinstanceVariableNames: 'array slotIndex'\r\tclassVariableNames: ''\r\tpackage: 'Fuel-Core-Collections'",			"comment" : [				"FLSimpleStack is a simple stack used in Fuel to avoid a recursion while traversing the graph to serialize. While analizing the content of an object (inst vars) we can encounter simple objects (direct string representation) or complex objects (composite). In the latter case we start analizing those instVars.",				"",				"So... Imagine object X with two instVars Y and Z. Imagine the method of the traverse is called #analye:.  So you do #analize: X.  Then, in such method you check whether X has regular pointers to regular objects, and if true, you analize them. So in this case you would send #analyze: Y and #analize: Z, generating the recursion. Right ?  Notice that the time between analyse: Y and analyse: Z is dependent on the graph that is attached to Y. Y can have objects that have further objects etc. So leaving X aside, Y can be the first object to serialize and Z the last.",				"",				"With this FLSimpleStack, instead of sending #analyze: Y and #analize: Z  what Fuel does is just to do a push on a stack:   #push: Y  and #push: Z. And then we are done with X, so we pop from the stack and we continue with the next object (at some point in the future we will pop Y and Z) When there are no more objects in the stack it means we are done. "			],			"category" : "Fuel-Core-Collections"		},		"CollectionValueHolder" : {			"hash" : 649984,			"definition" : "NewValueHolder subclass: #CollectionValueHolder\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'NewValueHolder-Core-Base'",			"comment" : [				"I am designed specifically for collections."			],			"category" : "NewValueHolder-Core-Base"		},		"SpPresenterBuilder" : {			"hash" : 2256640,			"definition" : "Object subclass: #SpPresenterBuilder\r\tuses: SpTPresenterBuilder\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Spec2-Core-Base'",			"comment" : [				"A simple presenter builder class that uses `SpTPresenterBuilder`. ",				"It allows users to compose presenters without hardcoding class name."			],			"category" : "Spec2-Core-Base"		},		"SpBoxLayout" : {			"hash" : 2212608,			"definition" : "SpDirectionableLayout subclass: #SpBoxLayout\r\tuses: SpTAlignable\r\tinstanceVariableNames: 'spacing borderWidth homogeneous'\r\tclassVariableNames: ''\r\tpackage: 'Spec2-Layout-Box'",			"comment" : [				"A layout that will arrange presenters in a box, vertically (top to bottom) or horizontally (left to right).",				"Elements can be added at the begining or at the end of the box (see `SpBoxLayout>>#add:` and `SpBoxLayout>>#addLast:` method families).",				"",				"## Discussion",				"",				"The box layout is the main layout in Spec, because its versatility and easy to use. While one may think its functionality is limited, the fact that it can be composed with other types of layouts or other instances of itself (other boxes), will let users do almost everything they need.",				"The basic usage is, however, very simple: ",				"",				"```Smalltalk",				"SpBoxLayout newTopToBottom",				"\tadd: aPresenter;",				"\tadd: otherPresenter;",				"\tyourself.",				"```",				"",				"This will arrange `aPresenter` and `otherPresenter` vertically, assigning to each presenter as much `height` as they can receive (usually 50% of the box).  ",				"Of course, being able to do _just that_ would be very limiting, but then is where layout properties start to be important.",				"",				"### The expand property (`SpBoxLayout>>#add:expand:`)",				"",				"With the previous example, let's define a some real presenters: ",				"",				"```Smalltalk",				"| presenter |",				"",				"presenter := SpPresenter new.",				"presenter layout: (SpBoxLayout newTopToBottom",				"\tadd: presenter newTextInput;",				"\tadd: presenter newText;",				"\tyourself).",				"\t\t",				"presenter openWithSpec",				"```",				"",				"What happened when we opened it? Well, the box layout was filled with an input text and a text area, but the height assigned to the first presenter is not what we would have expected, since even if text input is smaller, area height assigned is still half.",				"The property expand fixes this problem, by telling the layout not to assign more height than what is explicitly needed by the contained presenter: ",				"",				"```Smalltalk",				"| presenter |",				"",				"presenter := SpPresenter new.",				"presenter layout: (SpBoxLayout newTopToBottom",				"\tadd: presenter newTextInput expand: false;",				"\tadd: presenter newText;",				"\tyourself).",				"\t\t",				"presenter openWithSpec",				"```",				"",				"Now the presenter will behave as one would expect (This code is in `SpBoxLayout class>>#exampleExpand`).",				"",				"### adding presenters **last**.",				"",				"Now, consider this problem: You want to add something *at the end* of your presenter (for example, you want to add a button, making a dialog): ",				"",				"```Smalltalk",				"| presenter |",				"",				"presenter := SpPresenter new.",				"presenter layout: (SpBoxLayout newTopToBottom",				"\tadd: 'Enter text' expand: false;",				"\tadd: presenter newTextInput expand: false;",				"\tadd: (presenter newButton label: 'Ok') expand: false;",				"\tyourself).",				"\t\t",				"presenter openWithSpec",				"```",				"",				"But you want that button to be shown at the end. This is why we use the `addLast:` method, who will instruct the layout to add this presenter at the end.",				"",				"```Smalltalk",				"| presenter |",				"",				"presenter := SpPresenter new.",				"presenter layout: (SpBoxLayout newTopToBottom",				"\tadd: 'Enter text' expand: false;",				"\tadd: presenter newTextInput expand: false;",				"\taddLast: (presenter newButton label: 'Ok') expand: false;",				"\tyourself).",				"\t\t",				"presenter openWithSpec",				"```",				"",				"That makes the presenter work as expected  (This code is in SpBoxLayout class>>#exampleAddLast).",				"",				"### Composing layouts",				"",				"The real power of a layout comes when you understand they can be composed (with other instances of themselves or any other kind, children of `SpExecutableLayout`).",				"For example, taking the previous example, let's say you want to add two buttons (Ok, Cancel), aligned horizontaly. To accomplish that, you add a new layout with the buttons: ",				"",				"```Smalltalk",				"| presenter |",				"",				"presenter := SpPresenter new.",				"presenter layout: (SpBoxLayout newTopToBottom",				"\tadd: 'Enter text' expand: false;",				"\tadd: presenter newTextInput expand: false;",				"\taddLast: (SpBoxLayout newLeftToRight",				"\t\t\taddLast: (presenter newButton label: 'Ok') expand: false;",				"\t\t\taddLast: (presenter newButton label: 'Cancel') expand: false;",				"\t\t\tyourself)",				"\t\texpand: false;",				"\tyourself).",				"\t\t",				"presenter openWithSpec",				"```",				"",				"Now, the presenter will show buttons at bottom-right corner (This code is in `SpBoxLayout class>>#exampleComposite`)."			],			"category" : "Spec2-Layout-Box"		},		"LinkedList" : {			"hash" : 1026048,			"definition" : "SequenceableCollection subclass: #LinkedList\r\tinstanceVariableNames: 'firstLink lastLink'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Base'",			"comment" : [				"I am a sequential collection where adjecent objects are linked.",				"I can store any kind of objects that I will wrap into a Link (See implementation points).",				"I act pretty much as an OrderedCollection, but my access times differs: the method #atIndex: is depending of the number of elements so is not constant. In the worse case, the whole list must be crossed.",				"Using the message #addFirst: / #removeLast causes the receiver to behave as a stack; using #addLast: / #removeFirst causes the receiver to behave as a queue.",				"",				"I use the Link class (or his subclasses) in my implementation. ",				"",				"### Public API and Key Messages",				"",				"- #new / #withAll: aCollection / #with: anObject \tare common constructors",				"- #add: anObject / #at: anIndex put: anObject \tallow to add new elements to myself.",				"- #remove: anObject \tallow to remove an element.",				"- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock \tare common iterators.",				"",				"### Example ",				"",				" \t\"There is many ways to create a LinkedList, here are some:\"",				"```",				"\tlinkedList := LinkedList new.",				"\tlinkedList",				"\t\tadd: 'one';",				"\t\tadd: 'two';",				"\t\taddFirst: 'zero';",				"\t\taddLast: 'three'.",				"\tlinkedList.\t\t\"returns: a LinkedList('zero' 'one' 'two' 'three')\"",				"",				"\t\"or\"",				"\tlinkedList := LinkedList with: 'one' with: 'two' with: 'three'.",				"\tlinkedList.\t\t\"returns: a LinkedList('one' 'two' 'three')\"",				"",				"\t\"or from an other collection (here an Array)\"",				"\tlinkedList := LinkedList withAll: #('one' 'two' 'three').",				"\tlinkedList.\t\t\"returns: a LinkedList('one' 'two' 'three')\"",				"",				"\t\"Some manipulations\"",				"\tlinkedList := LinkedList new.",				"\tlinkedList",				"\t\tadd: 1;",				"\t\tadd: 2.",				"\tlinkedList.\t\t\"returns: a LinkedList(1 2)\"",				"\tlinkedList remove: 1.",				"\tlinkedList.\t\t\"returns: a LinkedList(2)\"",				"",				"\t\"A last one\"",				"\tlinkedList := LinkedList with: $b with: $c with: $a.",				"\tlinkedList sort: [ :first :second | first < second ].\t\t\t\"returns: a LinkedList($a $b $c)\"",				"\tlinkedList collect: [ :element | element asUppercase ].\t\"returns:  a LinkedList($A $B $C)\"",				"\tlinkedList select: [ :element | element >= $b ].\t\t\t\"returns:  a LinkedList($b $c)\"",				"\tlinkedList do: [ :element | element inspect ].",				"\tlinkedList asArray\t\t\t\t\t\t\t\t\t\"returns: #($a $b $c)\"",				"```",				"\t\t\t",				"### Internal Representation and Key Implementation Points.",				"",				"Instance Variables",				"- firstLink:\t\t <Link> \tA link that contains the first value of the LinkedList.",				"- lastLink:\t\t <Link> \tA link that contains the last value of the LinkedList.",				"",				"If you attempt to add any object into a LinkedList that is not a Link, it will automatically be wrapped by a ValueLink."			],			"category" : "Collections-Sequenceable-Base"		},		"LRUCache" : {			"hash" : 1631488,			"definition" : "AbstractCache subclass: #LRUCache\r\tinstanceVariableNames: 'lruList keyIndex'\r\tclassVariableNames: ''\r\tpackage: 'System-Caching'",			"comment" : [				"I am LRUCache.",				"I am a Cache.",				"",				"I am a limited cache that evicts the least recently used entries. My implementation is properly O(1).",				"",				"Implementation Notes",				"",				"The key/value pairs in the cache are held as Associations in a DoubleLinkedList, lruList, ordered from least to most recently used.",				"",				"The keyIndex Dictionary maps from each key to the actual DoubleLink inside lruList holding the matching key/value pair.",				"",				"New pairs are added at the end of the list.",				"",				"In case of a hit, a pair gets promoted to the end of the list (most recently used).",				"",				"In case of a full cache, the first pair of the list gets evicted (least recently used).",				"",				"See #validateInvariantWith: where the relationship between the 2 datastructures is checked.",				"",				"",				"Example 1",				"",				"Suppose we have to compute the prime factors of some numbers, ",				"and that this is a slow operation. If we repeatedly do the same",				"computation, we could speed this up with a cache.",				"",				"To get a reasonable hit rate, we generate 50 random numbers below 100.\"",				"",				"\tprimeFactorsCache := LRUCache new.",				"\t",				"\t50 timesRepeat: [",				"\t\t| n |",				"\t\tn := 100 atRandom.",				"\t\tprimeFactorsCache",				"\t\t\tat: n ifAbsentPut: [ n primeFactors ] ].",				"\t",				"\tprimeFactorsCache hitRatio asFloat.",				"",				"Example 2",				"",				"Fibonacci numbers are defined as follows:",				"",				" F(0)=0",				" F(1)=1",				" F(n)=F(n-1)+F(n-2)",				"",				"This is a relatively slow recursive process, especially",				"since the same number is computed more than once,",				"a cache can help. Let's find out the hit rate.",				"",				"Setting a factory block is an alternative way to define",				"a cache's functionality in one single place.\"\t",				"",				"\tfibCache := LRUCache new.",				"",				"\tfibCache ",				"\t\tmaximumWeight: 32;",				"\t\tfactory: [ :key |",				"\t\t\tkey < 2",				"\t\t\t\tifTrue: [ key ]",				"\t\t\t\tifFalse: [ (fibCache at: key - 1) + (fibCache at: key - 2) ] ].",				"",				"\tfibCache at: 40. \"102334155\"",				"",				"\tfibCache hitRatio asFloat."			],			"category" : "System-Caching"		},		"SpMorphicMillerAdapter" : {			"hash" : 2903808,			"definition" : "SpMorphicLayoutAdapter subclass: #SpMorphicMillerAdapter\r\tinstanceVariableNames: 'innerWidget lastExtent lastPageSize needRecalculatePages'\r\tclassVariableNames: ''\r\tpackage: 'Spec2-Adapters-Morphic-Layout'",			"comment" : [				"I'm an adapter for Miller Layouts.",				"A paned layout will split (horizontally or vertically) panels (in fixed yet proportional spaces), ",				"and it will scroll the panels that exceed SpMillerLayout>>#visiblePages property.  "			],			"category" : "Spec2-Adapters-Morphic-Layout"		},		"RunArray" : {			"hash" : 1663488,			"definition" : "SequenceableCollection subclass: #RunArray\r\tinstanceVariableNames: 'runs values lastIndex lastRun lastOffset'\r\tclassVariableNames: ''\r\tpackage: 'Text-Core-Utilities'",			"comment" : [				"My instances provide space-efficient storage of data which tends to be constant over long runs of the possible indices. Essentially repeated values are stored singly and then associated with a \"run\" length that denotes the number of consecutive occurrences of the value.",				"",				"My two important variables are",				"\truns\tAn array of how many elements are in each run",				"\tvalues\tAn array of what the value is over those elements",				"",				"The variables lastIndex, lastRun and lastOffset cache the last access",				"so that streaming through RunArrays is not an N-squared process.",				"",				"Many complexities of access can be bypassed by using the method",				"\tRunArray withStartStopAndValueDo:"			],			"category" : "Text-Core-Utilities"		},		"GTSpotterStepsBreadcrumb" : {			"hash" : 5881600,			"definition" : "GLMBrick subclass: #GTSpotterStepsBreadcrumb\r\tinstanceVariableNames: 'spotterModel items band animation'\r\tclassVariableNames: ''\r\tpackage: 'GT-Spotter-UI-Widgets'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tanimation:\t\t<Object>",				"\tband:\t\t<Object>",				"\titems:\t\t<Object>",				"\tspotterModel:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "GT-Spotter-UI-Widgets"		},		"SpNotebookPresenter" : {			"hash" : 2290432,			"definition" : "SpAbstractWidgetPresenter << #SpNotebookPresenter\r\tslots: {\r\t\t\t #pagesHolder .\r\t\t\t #selectedPage => ObservableSlot };\r\ttag: 'Widgets-Tab';\r\tpackage: 'Spec2-Core'",			"comment" : [				"I'm a presenter for a tabbed notebook container. ",				"This is a container whos children are pages (instances of `SpNotebookPage`), which have a title and a content."			],			"category" : "Spec2-Core-Widgets-Tab"		},		"SmallDictionary" : {			"hash" : 1138944,			"definition" : "Collection subclass: #SmallDictionary\r\tinstanceVariableNames: 'keys values size'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Dictionaries'",			"comment" : [				"`SmallDictionary` is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an `#empty` message which \"empties\" the collection but may hang on to the original elements (so it could collect garbage). Without `#empty` we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and `#empty`. Be careful, I cannot have *nil* as key. ",				"",				"### Public API and Key Messages",				"",				"- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.  ",				"- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.",				"- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively",				"",				"### Examples ",				"",				"",				"To create a dictiony with indexes as key: ",				"",				"```",				"SmallDictionary withAll: #(7 3 1 3)   \t\t",				"\">>>  a SmallDictionaryDictionary(1->7 2->3 3->1 4->3 \"",				"```",				"To use Objects as key (here symbols): ",				"",				"```",				"\tcolors := SmallDictionary new ",				"\t\t\t\tat: #yellow put: Color yellow; ",				"\t\t\t\tat: #blue put: Color blue;",				"\t\t\t\tat: #red put: Color red;",				"\t\t\t\tyourself.",				"\t\t\t\t",				"\tcolors at: #yellow. \t\"returns:  Color yellow\"",				"\tcolors keys          \t\t\"returns: a Set(#blue #yellow #red)\"",				"\tcolors values     \t\t\"returns:  {Color blue. Color yellow. Color red}\"",				"",				"\tcolors empty \t\"a SmallDictionary()\"",				"```",				"",				"### Internal Representation and Key Implementation Points.",				"Instance Variables",				"- keys:\t\t<Array>\t\tArray of keys (we don't use Associations for our key value pairs)",				"- size:\t\t\t<Integer>\tSize of the dictionary",				"- values:\t\t<Array>\t\tArray of our values",				"",				"",				"    Implementation Points"			],			"category" : "Collections-Unordered-Dictionaries"		},		"CTLinkedStoragePoolCircularDoubly" : {			"hash" : 7637248,			"definition" : "CTLinkedStoragePoolCircular subclass: #CTLinkedStoragePoolCircularDoubly\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"CTHeapQ" : {			"hash" : 2367232,			"definition" : "Object subclass: #CTHeapQ\r\tinstanceVariableNames: 'heap indexes tally'\r\tclassVariableNames: ''\r\tpackage: 'Containers-HeapQ'",			"comment" : [				"I am a binary heap and mimic the one found in the Python standard library.",				"! Heapify",				"Consider the following shuffled array of 63 elements:",				"${example:name=CTHeapQTest>>#test100ShuffledInterval|previewShow=#gtBoxesFor:|noCode=}$",				"that can be heapified as ${example:name=CTHeapQTest>>#test100ShuffledIntervalRawHeapSlot|previewShow=#gtBoxesFor:|noCode=}$",				"and visualized as a tree",				"${example:name=CTHeapQTest>>#test100ShuffledIntervalHeapified|noCode=|previewShow=#gtLiveFor:|previewHeight=800}$",				"and the same heap can also be visualized as \"bubbles\" in order to emphasize the __heap invariant__:",				"${example:name=CTHeapQTest>>#test100ShuffledIntervalHeapified|noCode=|previewShow=#gtBubblesLiveFor:|previewHeight=800}$",				""			],			"category" : "Containers-HeapQ"		},		"FreeTypeCache" : {			"hash" : 1869056,			"definition" : "Object subclass: #FreeTypeCache\r\tinstanceVariableNames: 'maximumSize used fontTable fifo'\r\tclassVariableNames: ''\r\tpoolDictionaries: 'FreeTypeCacheConstants'\r\tpackage: 'FreeType-Cache'",			"comment" : [				"Cache for freetype fonts"			],			"category" : "FreeType-Cache"		},		"SharedQueue" : {			"hash" : 1132288,			"definition" : "Stream subclass: #SharedQueue\r\tinstanceVariableNames: 'monitor items'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Base'",			"comment" : [				"An implementation of a shared queue based on class Monitor.  Clients may may place items on the queue using nextPut: or remove them using methods like next or nextOrNil.  Items are removed in first-in first-out (FIFO) order.  It is safe for multiple threads to access the same shared queue, which is why this is a \"shared\" queue.",				"",				"[monitor] is used to synchronize access from multiple threads.",				"",				"[items] is an ordered collection holding the items that are in the queue.  New items are added  at the end, and old items are removed from the beginning.",				"",				"All methods must hold the monitor while they run."			],			"category" : "Collections-Sequenceable-Base"		},		"SpecFocusOrder" : {			"hash" : 945152,			"definition" : "Object subclass: #SpecFocusOrder\r\tinstanceVariableNames: 'presenters'\r\tclassVariableNames: ''\r\tpackage: 'Spec-Core-Support'",			"comment" : [				"A SpecFocusOrder manage the path of focus between widgets.",				"",				"I use a collection (presenters) to keep widgets I managed. When I reach the end of the collection, I try to give the focus at the parent in the hierarchy, if it is nil I loop.",				"",				"I provide the following methods",				"- add: and addLast: to add a widget in my collection",				"- giveFocusToNextFrom:for: and giveFocusToPreviousFrom:for: to make me change the focus, the first argument is presenter who leave the focus and the second is the current model in the hierarchy.",				"- ifEmpty:ifNotEmpty: and ifNotEmpty: are send in my collection.",				"- presenters is the getter of my collection.",				"- removeAll to remove all my widgets.",				"",				"My super class is not OrderedCollection because it could be a problem for the devellopement of another behaviour."			],			"category" : "Spec-Core-Support"		},		"CTLinkedStoragePool" : {			"hash" : 7636224,			"definition" : "Object subclass: #CTLinkedStoragePool\r\tinstanceVariableNames: 'avail'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tavail:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"Heap" : {			"hash" : 1003776,			"definition" : "Collection subclass: #Heap\r\tinstanceVariableNames: 'array tally sortBlock indexUpdateBlock'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Base'",			"comment" : [				"Heap implements a special data structure commonly referred to as 'heap' [ http://en.wikipedia.org/wiki/Heap_%28data_structure%29 ]",				"",				"Heaps are good at handling priority queues because:",				"\t1) greatest priority element according to the sort block will be stored in first position and thus accessed in O(1) operations",				"\t2) worse time for inserting or removing an element is in O(log n) operations, where n is the size of the Heap",				"\tInsertion/Removal times are more efficient than above upper bound, provided that:",				"\t\ta) Elements are only removed at the beginning",				"\t\tb) Elements are added with arbitrary sort order.",				"\t3) there is no need to fully sort the Heap, which makes it more efficient than a SortedCollection",				"",				"The heap can be fully sorted by sending the message #fullySort.",				"Worse time for fully sorting the Heap is in O(n log n) operations, but this is rarely used a feature.",				"Remind that the Heap does not fully sort the collection if you don't ask.",				"Thus don't expect #do: and other iterators to enumerate elements according to the sortBlock order.",				"",				"Instance variables:",				"       array           <Array>         The data repository",				"       tally           <Integer>       The number of elements in the heap",				"       sortBlock       <Block|nil>     A two-argument block defining the sort order,",				"                                                       or nil in which case the default sort order is",				"                                                               [:element1 :element2| element1 <= element2]",				"       indexUpdateBlock        <Block|nil>",				"                                                       A two-argument block of the form [:data :index | ... ]",				"                                                       which allows an application object to keep track of its",				"                                                       index within the heap.  Useful for quick heap update",				"                                                       when object's sort value changes (for example, when an",				"                                                       object in a priority queue has its priority increased",				"                                                       by an external event, you don't want to have to search",				"                                                       through the whole heap to find the index before fixing",				"                                                      the heap).  No update occurs if nil.",				"",				"The Heap can be viewed as a binary tree (every node in the tree has at most two children).",				"The root is stored in first slot of internal array.",				"The children are stored in next two slots.",				"The children of children in next four slots.",				"etc...",				"",				"For a node A of index i (1 based), the two children B1 and B2 are thus stored in indices (2*i) and (2*i+1).",				"Of course, the children indices must be less than the tally otherwise they are considered inexistent.",				"",				"The Heap does arrange to preserve the following invariant:",				"For any children B of a node A, A is sorted before B, in other words, (self sort: A before: B) = true",				"This implies that the root is always the first element according to sort order."			],			"category" : "Collections-Sequenceable-Base"		},		"DATarjanAlgorithm" : {			"hash" : 1753856,			"definition" : "Object subclass: #DATarjanAlgorithm\r\tinstanceVariableNames: 'runningIndex stack stronglyConnectedComponents'\r\tclassVariableNames: ''\r\tpackage: 'Tool-DependencyAnalyser-Core'",			"comment" : [				"A class to do Tarjan Algorithm on a PDPackageRelation, in order to detect strongly connected components.",				"Give a package dependency graph (PDPackageRelationGraph)  in entry of the message run to run the Tarjan algorithm and retrieve all the strongly connected components graph."			],			"category" : "Tool-DependencyAnalyser-Core"		},		"WeakRegistry" : {			"hash" : 1187584,			"definition" : "Collection subclass: #WeakRegistry\r\tinstanceVariableNames: 'list valueDictionary sema'\r\tclassVariableNames: 'Default'\r\tpackage: 'Collections-Weak-Registration'",			"comment" : [				"This kind of WeakRegistry using a new VM feature,",				"which allows a more robust finalization support.",				"",				"In contrast to old implementation, it doesn't spending linear time , checking what elements became garbage."			],			"category" : "Collections-Weak-Registration"		},		"HashedCollection" : {			"hash" : 848896,			"definition" : "Collection subclass: #HashedCollection\r\tinstanceVariableNames: 'tally array'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am an abstract collection of objects that implement hash and equality in a consistent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.",				"",				"Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.",				"",				"Instance Variables",				"\tarray:\t\t<ArrayedCollection> (typically Array or WeakArray)",				"\ttally:\t\t<Integer> (non-negative)",				"",				"array",				"\t- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my \"load\" at 75% or less so that hashing will work well.",				"",				"tally",				"\t- The number of elements in the collection. The array size is always greater than this.",				"",				"Implementation details:",				"I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink."			],			"category" : "Collections-Abstract-Base"		},		"CTLinkedStoragePoolCircular" : {			"hash" : 7636736,			"definition" : "CTLinkedStoragePool subclass: #CTLinkedStoragePoolCircular\r\tinstanceVariableNames: 'head'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\thead:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"CTLinkedStoragePoolQueue" : {			"hash" : 7638784,			"definition" : "CTLinkedStoragePoolStack subclass: #CTLinkedStoragePoolQueue\r\tinstanceVariableNames: 'bottom'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tbottom:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"Breakpoint class" : {			"hash" : 3336448,			"definition" : "Breakpoint class\r\tinstanceVariableNames: ''",			"comment" : [				"A Breakpoint is an object used for stopping the execution of the program in a determined instruction, normally with debugging purposes. ",				"There are three types of breakpoints:",				"-halt once: These are triggered once, and then removed.",				"-halt always: Once installed, they have to be explicitly removed (by using #remove on the instance side, or #removeAll on class side)",				"-halt on condition: Before being installed prompts the user for a condition (a block with a boolean expression), and it is only triggered when that condition is met.",				"",				"Breakpoints are installed via SmartSuggestions menu (available for RBMethodNode, RBMessageNode and RBAssignmentNode), or programmatically:",				"",				"\"(Breakpoint inMethod: (Bar>>#foo2) inNode: ((Bar>>#foo2) ast allChildren at: 9) )",				"break: #when: withArguments: { [ RFCounter counter isZero ] }",				"\"",				""			],			"category" : "Reflectivity-Breakpoints"		},		"Collection" : {			"hash" : 849408,			"definition" : "Object subclass: #Collection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am the abstract superclass of all classes that represent a group of elements.",				"",				"To get more information you read the explanation on Pharo by Example book in the next link: [Pharo by Example - Collections](https://github.com/SquareBracketAssociates/UpdatedPharoByExample/blob/pharo5/Collections/Collections.pillar).",				"",				"Or if you want to read in PDF format, download it from [Pharo by Example](https://github.com/SquareBracketAssociates/PharoByExample80/releases/tag/continuous) and look for Chapter 13: Collections. "			],			"category" : "Collections-Abstract-Base"		},		"ZnBasicAuthenticator" : {			"hash" : 1393408,			"definition" : "Object subclass: #ZnBasicAuthenticator\r\tinstanceVariableNames: 'credentials realm'\r\tclassVariableNames: ''\r\tpackage: 'Zinc-HTTP-Support'",			"comment" : [				"I am ZnBasicAuthenticator.",				"I help servers handle HTTP Basic Authentication.",				"I implement the required #authenticateRequest:do:",				"",				"I have a credentials dictionary with username->password associations.",				"",				"Part of Zinc HTTP Components."			],			"category" : "Zinc-HTTP-Support"		}	},	"messages" : {		"allocateOrReuseLink" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"CTLinkedStoragePoolCircular>>#push:",				"CTLinkedStoragePoolPolynomial>>#addPolynomial:headLink:",				"CTLinkedStoragePoolQueue>>#push:",				"CTLinkedStoragePoolStack>>#push:"			],			"implementors" : {				"CTLinkedStoragePool" : {					"sourceCode" : [						"allocateOrReuseLink",						"",						"\t^ avail",						"\t\t  ifNil: [ self newLink ]",						"\t\t  ifNotNil: [ avail yourself: [ avail := avail nextLink ] ]"					],					"body" : [						"^ avail",						"\t  ifNil: [ self newLink ]",						"\t  ifNotNil: [ avail yourself: [ avail := avail nextLink ] ]"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 8430963,					"argumentNames" : [ ]				}			}		},		"testPopFromEmptyQueue" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testPopFromEmptyQueue",						"",						"\tself",						"\t\tshould: [ ",						"\t\t\tCTLinkedStoragePoolQueue new",						"\t\t\t\tpush: 3;",						"\t\t\t\tpop;",						"\t\t\t\tpop ]",						"\t\traise: CollectionIsEmpty"					],					"body" : [						"self",						"\tshould: [ ",						"\t\tCTLinkedStoragePoolQueue new",						"\t\t\tpush: 3;",						"\t\t\tpop;",						"\t\t\tpop ]",						"\traise: CollectionIsEmpty"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8434582,					"argumentNames" : [ ]				}			}		},		"testSomePushesThenPopsOnQueue" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testSomePushesThenPopsOnQueue",						"",						"\t| stack steps |",						"\tsteps := OrderedCollection new",						"\t\t         add: (Message selector: #push: arguments: { 3 });",						"\t\t         add: (Message selector: #push: arguments: { 4 });",						"\t\t         add: (Message selector: #push: arguments: { 5 });",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #push: arguments: { 6 });",						"\t\t         yourself.",						"",						"\tstack := CTLinkedStoragePoolQueue new.",						"",						"\tsteps withIndexDo: [ :each :i | ",						"\t\teach sendTo: stack.",						"\t\tself exportSlotsGraphOf: stack pathSuffix: i asString ]"					],					"body" : [						"| stack steps |",						"steps := OrderedCollection new",						"\t         add: (Message selector: #push: arguments: { 3 });",						"\t         add: (Message selector: #push: arguments: { 4 });",						"\t         add: (Message selector: #push: arguments: { 5 });",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #push: arguments: { 6 });",						"\t         yourself.",						"",						"stack := CTLinkedStoragePoolQueue new.",						"",						"steps withIndexDo: [ :each :i | ",						"\teach sendTo: stack.",						"\tself exportSlotsGraphOf: stack pathSuffix: i asString ]"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8961253,					"argumentNames" : [ ]				}			}		},		"testRemoveAllFromStack" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testRemoveAllFromStack",						"",						"\t| queue |",						"\tqueue := (1 to: 5)",						"\t\t         inject: CTLinkedStoragePoolStack new",						"\t\t         into: [ :pool :each | pool push: each ].",						"",						"\tqueue",						"\t\tpop;",						"\t\tpop.",						"",						"\tself exportSlotsGraphOf: queue pathSuffix: 'full'.",						"",						"\tqueue removeAll.",						"",						"\tself exportSlotsGraphOf: queue pathSuffix: 'empty'"					],					"body" : [						"| queue |",						"queue := (1 to: 5)",						"\t         inject: CTLinkedStoragePoolStack new",						"\t         into: [ :pool :each | pool push: each ].",						"",						"queue",						"\tpop;",						"\tpop.",						"",						"self exportSlotsGraphOf: queue pathSuffix: 'full'.",						"",						"queue removeAll.",						"",						"self exportSlotsGraphOf: queue pathSuffix: 'empty'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8699557,					"argumentNames" : [ ]				}			}		},		"testEmptyStack" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testEmptyStack",						"",						"\t| stack |",						"\tstack := CTLinkedStoragePoolStack new.",						"",						"\t^ self",						"\t\t  assert: stack isEmpty;",						"\t\t  exportSlotsGraphOf: stack"					],					"body" : [						"| stack |",						"stack := CTLinkedStoragePoolStack new.",						"",						"^ self",						"\t  assert: stack isEmpty;",						"\t  exportSlotsGraphOf: stack"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8697304,					"argumentNames" : [ ]				}			}		},		"pop" : {			"implementors" : {				"FLSimpleStack" : {					"sourceCode" : [						"pop",						"",						"\t\"Returns the first element and remove it from the stack.\"",						"",						"\tslotIndex := slotIndex - 1.",						"\t^ array at: slotIndex"					],					"body" : [						"slotIndex := slotIndex - 1.",						"^ array at: slotIndex"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Returns the first element and remove it from the stack."					],					"hash" : 2519172,					"argumentNames" : [ ]				},				"IRStackCount" : {					"sourceCode" : [						"pop",						"",						"\t^ self pop: 1"					],					"body" : [						"^ self pop: 1"					],					"isTestMethod" : false,					"category" : "affecting",					"comment" : [ ],					"hash" : 2036689,					"argumentNames" : [ ]				},				"Context" : {					"sourceCode" : [						"pop",						"",						"\t\"Answer the top of the receiver's stack and remove the top of the stack.\"",						"",						"\t| value |",						"\tvalue := self at: stackp.",						"\tself stackp: stackp - 1.",						"\t^ value"					],					"body" : [						"| value |",						"value := self at: stackp.",						"self stackp: stackp - 1.",						"^ value"					],					"isTestMethod" : false,					"category" : "controlling",					"comment" : [						"Answer the top of the receiver's stack and remove the top of the stack."					],					"hash" : 1066408,					"argumentNames" : [ ]				},				"LIFOQueue" : {					"sourceCode" : [						"pop",						"",						"\t^ self nextIfNone: [ self errorEmptyStack ]"					],					"body" : [						"^ self nextIfNone: [ self errorEmptyStack ]"					],					"isTestMethod" : false,					"category" : "stack-compliant protocol",					"comment" : [ ],					"hash" : 1890957,					"argumentNames" : [ ]				},				"FileSystemGuide" : {					"sourceCode" : [						"pop",						"",						"\t^ work removeLast"					],					"body" : [						"^ work removeLast"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 2073892,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolStack" : {					"sourceCode" : [						"pop",						"",						"\t^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t\t  | p |",						"\t\t  p := top.",						"\t\t  top := top nextLink.",						"\t\t  p value yourself: [ self releaseLink: p ] ]"					],					"body" : [						"^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t  | p |",						"\t  p := top.",						"\t  top := top nextLink.",						"\t  p value yourself: [ self releaseLink: p ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 8696004,					"argumentNames" : [ ]				},				"GTSpotterStepsBreadcrumb" : {					"sourceCode" : [						"pop",						"",						"\tself band layoutAfter: [ ",						"\t\tself band removeBrick: self items removeLast.",						"\t\tself items size = 1 ifTrue: [ ",						"\t\t\tself items first labelBrick paddingLeft: 0 ].",						"\t\tself items isEmpty ifFalse: [ self popSeparator ].",						"\t\tself items do: [ :b | b wrappedBounds markWidthDirty ] ].",						"",						"\t\"optimization. if last item was popped we need to update root to reposition all brick,",						"\totherwise only I need to be updated\"",						"\tself items size = 0",						"\t\tifTrue: [ self notifyBreadcrumbVisibilityChanged ]",						"\t\tifFalse: [ ",						"\t\t\tself items last showTriangle.",						"\t\t\tself scrollToTheLastOne.",						"\t\t\tself changed ]"					],					"body" : [						"self band layoutAfter: [ ",						"\tself band removeBrick: self items removeLast.",						"\tself items size = 1 ifTrue: [ ",						"\t\tself items first labelBrick paddingLeft: 0 ].",						"\tself items isEmpty ifFalse: [ self popSeparator ].",						"\tself items do: [ :b | b wrappedBounds markWidthDirty ] ].",						"",						"\"optimization. if last item was popped we need to update root to reposition all brick,",						"\totherwise only I need to be updated\"",						"self items size = 0",						"\tifTrue: [ self notifyBreadcrumbVisibilityChanged ]",						"\tifFalse: [ ",						"\t\tself items last showTriangle.",						"\t\tself scrollToTheLastOne.",						"\t\tself changed ]"					],					"isTestMethod" : false,					"category" : "adding/removing",					"comment" : [ ],					"hash" : 6679015,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolCircularDoubly" : {					"sourceCode" : [						"pop",						"",						"\t^ head nextLink == head",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | removingLink |",						"\t\t\t  removingLink := head nextLink.",						"\t\t\t  removingLink previousLink nextLink: removingLink nextLink.",						"\t\t\t  removingLink nextLink previousLink: removingLink previousLink.",						"\t\t\t  removingLink value yourself: [ ",						"\t\t\t\t  head value: head value - 1.",						"\t\t\t\t  self releaseLink: removingLink ] ]"					],					"body" : [						"^ head nextLink == head",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | removingLink |",						"\t\t  removingLink := head nextLink.",						"\t\t  removingLink previousLink nextLink: removingLink nextLink.",						"\t\t  removingLink nextLink previousLink: removingLink previousLink.",						"\t\t  removingLink value yourself: [ ",						"\t\t\t  head value: head value - 1.",						"\t\t\t  self releaseLink: removingLink ] ]"					],					"isTestMethod" : false,					"category" : "API-remotes",					"comment" : [ ],					"hash" : 8696409,					"argumentNames" : [ ]				},				"Stack" : {					"sourceCode" : [						"pop",						"",						"\t\"Returns the first element and remove it from the stack.\"",						"",						"\t^ self removeFirst"					],					"body" : [						"^ self removeFirst"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Returns the first element and remove it from the stack."					],					"hash" : 1941871,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolCircular" : {					"sourceCode" : [						"pop",						"",						"\t^ head nextLink == head",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | removingLink |",						"\t\t\t  removingLink := head nextLink.",						"\t\t\t  head",						"\t\t\t\t  value: head value - 1;",						"\t\t\t\t  nextLink: removingLink nextLink.",						"\t\t\t  removingLink value yourself: [ self releaseLink: removingLink ] ]"					],					"body" : [						"^ head nextLink == head",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | removingLink |",						"\t\t  removingLink := head nextLink.",						"\t\t  head",						"\t\t\t  value: head value - 1;",						"\t\t\t  nextLink: removingLink nextLink.",						"\t\t  removingLink value yourself: [ self releaseLink: removingLink ] ]"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 8695633,					"argumentNames" : [ ]				},				"CTHeapQ" : {					"sourceCode" : [						"pop",						"",						"\t^ self isEmpty",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | lastelt |",						"\t\t\t  lastelt := heap at: tally.",						"\t\t\t  tally := tally - 1.",						"\t\t\t  self isEmpty",						"\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t  indexes",						"\t\t\t\t\t\t  removeKey: lastelt;",						"\t\t\t\t\t\t  itself: lastelt ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  | returnElt |",						"\t\t\t\t\t  returnElt := heap first.",						"\t\t\t\t\t  indexes removeKey: returnElt.",						"\t\t\t\t\t  self",						"\t\t\t\t\t\t  at: 1 put: lastelt;",						"\t\t\t\t\t\t  siftUp: 1;",						"\t\t\t\t\t\t  itself: returnElt ] ]"					],					"body" : [						"^ self isEmpty",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | lastelt |",						"\t\t  lastelt := heap at: tally.",						"\t\t  tally := tally - 1.",						"\t\t  self isEmpty",						"\t\t\t  ifTrue: [ ",						"\t\t\t\t  indexes",						"\t\t\t\t\t  removeKey: lastelt;",						"\t\t\t\t\t  itself: lastelt ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  | returnElt |",						"\t\t\t\t  returnElt := heap first.",						"\t\t\t\t  indexes removeKey: returnElt.",						"\t\t\t\t  self",						"\t\t\t\t\t  at: 1 put: lastelt;",						"\t\t\t\t\t  siftUp: 1;",						"\t\t\t\t\t  itself: returnElt ] ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 3687999,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolQueue" : {					"sourceCode" : [						"pop",						"",						"\t^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t\t  | p |",						"\t\t  p := top.",						"\t\t  top := top nextLink.",						"\t\t  p value yourself: [ ",						"\t\t\t  self releaseLink: p.",						"\t\t\t  top ifNil: [ bottom := top ] ] ]"					],					"body" : [						"^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t  | p |",						"\t  p := top.",						"\t  top := top nextLink.",						"\t  p value yourself: [ ",						"\t\t  self releaseLink: p.",						"\t\t  top ifNil: [ bottom := top ] ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 8696516,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"CTHeapQTest>>#testPushPop",				"CTLinkedStoragePoolPolynomialTest>>#testPolynomialAdditionIsCommutativeFromKnuthTextbook",				"CTLinkedStoragePoolPolynomialTest>>#testPolynomialAdditionFromKnuthTextbook",				"CTLinkedStoragePoolTest>>#testPopFromEmptyStack",				"CTLinkedStoragePoolTest>>#testRemoveAllFromQueue",				"CTLinkedStoragePoolTest>>#testPopFromEmptyQueue",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnStack",				"CTLinkedStoragePoolTest>>#testRemoveAllFromStack",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnQueue",				"ConfigurableHistoryIterator>>#undoIfEmpty:",				"ConfigurableHistoryIterator>>#redoIfEmpty:",				"Context>>#methodReturnTop",				"Context>>#popIntoRemoteTemp:inVectorAt:",				"Context>>#pushConsArrayWithElements:",				"Context>>#directedSuperSend:numArgs:",				"Context>>#blockReturnTop",				"Context>>#popIntoReceiverVariable:",				"Context>>#runSimulated:contextAtEachStep:",				"Context>>#popIntoTemporaryVariable:",				"Context>>#popIntoLiteralVariable:",				"Context>>#jump",				"Context>>#jump:if:",				"Context>>#pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:",				"Context>>#send:super:numArgs:",				"Context>>#pushClosureCopyNumCopiedValues:numArgs:blockSize:",				"Context>>#doPop",				"DATarjanAlgorithm>>#popStackAndUpdateCurrentSCC:until:",				"FFIFunctionResolutionTest>>#testResolveConstantNULLShouldSetConstantNullLoader",				"FFIFunctionResolutionTest>>#testResolveConstantFalseShouldSetConstantZeroLoader",				"FFIFunctionResolutionTest>>#testResolveArgumentVariableShouldSetArgumentVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantTrueShouldSetConstantOneLoader",				"FFIFunctionResolutionTest>>#testResolveInstanceVariableShouldSetInstanceVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantIntegerShouldSetConstantLoader",				"FFIFunctionResolutionTest>>#testResolveConstantNilShouldSetConstantNullLoader",				"FFIFunctionResolutionTest>>#testResolveClassVariableShouldSetClassVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantSelfOfExternalObjectShouldSetConstantFirstInstanceVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantSelfStringShouldSetConstantLoader",				"FLAnalysis>>#run",				"FLSimpleStackTest>>#testPop",				"GTSpotterStepsBreadcrumb>>#onStepPopped",				"HiRulerBuilder>>#buildLinksStartingAt:",				"IRBuilder>>#popScope",				"IRBytecodeDecompiler>>#popScope",				"IRBytecodeGenerator>>#popTop",				"IRBytecodeGenerator>>#storePopTemp:",				"IRBytecodeGenerator>>#storePopRemoteTemp:inVectorAt:",				"IRBytecodeGenerator>>#storePopIntoLiteralVariable:",				"IRBytecodeGenerator>>#if:goto:otherwise:",				"IRBytecodeGenerator>>#storePopInstVar:",				"IRBytecodeGenerator>>#returnTop",				"IRBytecodeGenerator>>#pushFullBlockClosure:",				"IRTranslator>>#popScope",				"MCScanner>>#next",				"MalTarjan>>#popStackAndUpdateCurrentScc:until:",				"MicInlineSplitter>>#popFrom:to:",				"MicrodownStyleHelpBuilder>>#helpTopicFromFormattedString:title:",				"OupsDebuggerSelector>>#nextDebugger",				"POP3Client class>>#logFlag",				"PostorderGuide>>#show:",				"PreorderGuide>>#show:",				"RBRefactoryChangeManager>>#lastUndoPointer",				"RBRefactoryChangeManager>>#undoChange",				"SindarinDebugger>>#skipMessageNodeWith:",				"SindarinDebugger>>#skipAssignmentNodeWith:",				"SpMenuPresenterBuilder>>#visitCommandGroup:",				"StackTest>>#testSize",				"StackTest>>#testEmptyError",				"StackTest>>#testPop",				"TFRunner>>#returnCallback:",				"TypingVisitor>>#visitBlockNode:",				"WikiStyleHelpBuilder>>#helpTopicFromFormattedString:title:"			]		},		"testRemoveAllFromQueue" : {			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testRemoveAllFromQueue",						"",						"\t| queue |",						"\tqueue := (1 to: 5)",						"\t\t         inject: CTLinkedStoragePoolQueue new",						"\t\t         into: [ :pool :each | pool push: each ].",						"",						"\tqueue",						"\t\tpop;",						"\t\tpop.",						"",						"\tself exportSlotsGraphOf: queue pathSuffix: 'full'.",						"",						"\tqueue removeAll.",						"",						"\tself exportSlotsGraphOf: queue pathSuffix: 'empty'"					],					"body" : [						"| queue |",						"queue := (1 to: 5)",						"\t         inject: CTLinkedStoragePoolQueue new",						"\t         into: [ :pool :each | pool push: each ].",						"",						"queue",						"\tpop;",						"\tpop.",						"",						"self exportSlotsGraphOf: queue pathSuffix: 'full'.",						"",						"queue removeAll.",						"",						"self exportSlotsGraphOf: queue pathSuffix: 'empty'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8699557,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			]		},		"releaseLink:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"CTLinkedStoragePoolCircular>>#pop",				"CTLinkedStoragePoolCircularDoubly>>#pop",				"CTLinkedStoragePoolPolynomial>>#addPolynomial:headLink:",				"CTLinkedStoragePoolQueue>>#pop",				"CTLinkedStoragePoolStack>>#pop"			],			"implementors" : {				"CTLinkedStoragePool" : {					"sourceCode" : [						"releaseLink: aValueLink",						"",						"\taValueLink nextLink: avail.",						"\tavail := aValueLink"					],					"body" : [						"aValueLink nextLink: avail.",						"avail := aValueLink"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 25469779,					"argumentNames" : [						"aValueLink"					]				}			}		},		"testEmptyQueue" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testEmptyQueue",						"",						"\t| queue |",						"\tqueue := CTLinkedStoragePoolQueue new.",						"",						"\t^ self",						"\t\t  assert: queue isEmpty;",						"\t\t  exportSlotsGraphOf: queue"					],					"body" : [						"| queue |",						"queue := CTLinkedStoragePoolQueue new.",						"",						"^ self",						"\t  assert: queue isEmpty;",						"\t  exportSlotsGraphOf: queue"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8697304,					"argumentNames" : [ ]				}			}		},		"removeAll" : {			"implementors" : {				"OrderedCollection" : {					"sourceCode" : [						"removeAll",						"",						"\t\"remove all the elements from this collection.",						"\tKeep same amount of storage\"",						"",						"\tself setCollection: (self class arrayType new: array size)"					],					"body" : [						"self setCollection: (self class arrayType new: array size)"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"remove all the elements from this collection.",						"\tKeep same amount of storage"					],					"hash" : 1604282,					"argumentNames" : [ ]				},				"SpNotebookPresenter" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove all pages in notebook\"",						"",						"\tpagesHolder removeAll"					],					"body" : [						"pagesHolder removeAll"					],					"isTestMethod" : false,					"category" : "api",					"comment" : [						"Remove all pages in notebook"					],					"hash" : 3084535,					"argumentNames" : [ ]				},				"WeakRegistry" : {					"sourceCode" : [						"removeAll",						"",						"\t\"See super\"",						"",						"\tself protected: [ ",						"\t\tvalueDictionary removeAll.",						"\t\tlist swapWithNil \"prune finalization list as well\" ]"					],					"body" : [						"self protected: [ ",						"\tvalueDictionary removeAll.",						"\tlist swapWithNil \"prune finalization list as well\" ]"					],					"isTestMethod" : false,					"category" : "printing",					"comment" : [						"See super"					],					"hash" : 1981794,					"argumentNames" : [ ]				},				"CharacterSetComplement" : {					"sourceCode" : [						"removeAll",						"",						"\tself becomeForward: CharacterSet new"					],					"body" : [						"self becomeForward: CharacterSet new"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1678580,					"argumentNames" : [ ]				},				"WaitfreeQueue" : {					"sourceCode" : [						"removeAll",						"",						"\t\"",						"\tThis message makes no sense in concurrent environment. There is no way to guarantee that when this method returns to sender, the queue will remain empty,",						"\tbecause at any moment other process may interrupt current process and put new item(s) to queue.",						"",						"\tTherefore we just flush the queue and hope for the best\"",						"",						"\tself flush"					],					"body" : [						"self flush"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [						"",						"\tThis message makes no sense in concurrent environment. There is no way to guarantee that when this method returns to sender, the queue will remain empty,",						"\tbecause at any moment other process may interrupt current process and put new item(s) to queue.",						"",						"\tTherefore we just flush the queue and hope for the best"					],					"hash" : 1889604,					"argumentNames" : [ ]				},				"SpMorphicBoxAdapter" : {					"sourceCode" : [						"removeAll",						"",						"\tstartPanel removeAllMorphs.",						"\tendPanel removeAllMorphs.",						"\tself verifyBoxExtent"					],					"body" : [						"startPanel removeAllMorphs.",						"endPanel removeAllMorphs.",						"self verifyBoxExtent"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3697435,					"argumentNames" : [ ]				},				"SpBoxLayout" : {					"sourceCode" : [						"removeAll",						"",						"\tchildren removeAll.",						"\tadapter ifNotNil: [ :anAdapter | ",						"\t\tanAdapter unsubscribe.",						"\t\tanAdapter removeAll ]"					],					"body" : [						"children removeAll.",						"adapter ifNotNil: [ :anAdapter | ",						"\tanAdapter unsubscribe.",						"\tanAdapter removeAll ]"					],					"isTestMethod" : false,					"category" : "api - adding",					"comment" : [ ],					"hash" : 3270096,					"argumentNames" : [ ]				},				"SmallDictionary" : {					"sourceCode" : [						"removeAll",						"",						"\tself initialize"					],					"body" : [						"self initialize"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1932868,					"argumentNames" : [ ]				},				"ZnBasicAuthenticator" : {					"sourceCode" : [						"removeAll",						"",						"\tcredentials removeAll"					],					"body" : [						"credentials removeAll"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2187256,					"argumentNames" : [ ]				},				"SpMorphicMillerAdapter" : {					"sourceCode" : [						"removeAll",						"",						"\tneedRecalculatePages := true.",						"\tinnerWidget removeAllMorphs"					],					"body" : [						"needRecalculatePages := true.",						"innerWidget removeAllMorphs"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3697993,					"argumentNames" : [ ]				},				"AbstractCache" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove all key/value pairs that I currently hold,",						"\teffectiley resetting me, but not my statistics.\"",						"",						"\tself subclassResponsibility"					],					"body" : [						"self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Remove all key/value pairs that I currently hold,",						"\teffectiley resetting me, but not my statistics."					],					"hash" : 2424900,					"argumentNames" : [ ]				},				"OrderedDictionary" : {					"sourceCode" : [						"removeAll",						"",						"\t1 to: self size do: [ :i | orderedKeys at: i put: nil ].",						"\tdictionary removeAll"					],					"body" : [						"1 to: self size do: [ :i | orderedKeys at: i put: nil ].",						"dictionary removeAll"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 2405129,					"argumentNames" : [ ]				},				"Breakpoint class" : {					"sourceCode" : [						"removeAll",						"",						"\t<script>",						"\tself all copy do: #remove"					],					"body" : [						"self all copy do: #remove"					],					"isTestMethod" : false,					"category" : "cleanup",					"comment" : [ ],					"hash" : 4130695,					"argumentNames" : [ ]				},				"Watch class" : {					"sourceCode" : [						"removeAll",						"",						"\tself allWatches values do: [ :aWatchpoint | aWatchpoint uninstall ].",						"\tWatches := nil"					],					"body" : [						"self allWatches values do: [ :aWatchpoint | aWatchpoint uninstall ].",						"Watches := nil"					],					"isTestMethod" : false,					"category" : "cleanup",					"comment" : [ ],					"hash" : 4155321,					"argumentNames" : [ ]				},				"ArrayedCollection" : {					"sourceCode" : [						"removeAll",						"",						"\tself shouldNotImplement"					],					"body" : [						"self shouldNotImplement"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1648452,					"argumentNames" : [ ]				},				"DictionaryValueHolder" : {					"sourceCode" : [						"removeAll",						"",						"\tvalue removeAll.",						"\tself valueChanged"					],					"body" : [						"value removeAll.",						"self valueChanged"					],					"isTestMethod" : false,					"category" : "protocol",					"comment" : [ ],					"hash" : 1444788,					"argumentNames" : [ ]				},				"MethodDictionary" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove all elements from this collection. Preserve the capacity\"",						"",						"\t| newSelf |",						"\ttally = 0 ifTrue: [ ^ self ].",						"\tnewSelf := self species newForCapacity: self basicSize.",						"\tself copyFrom: newSelf"					],					"body" : [						"| newSelf |",						"tally = 0 ifTrue: [ ^ self ].",						"newSelf := self species newForCapacity: self basicSize.",						"self copyFrom: newSelf"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Remove all elements from this collection. Preserve the capacity"					],					"hash" : 1883568,					"argumentNames" : [ ]				},				"ZnCookieJar" : {					"sourceCode" : [						"removeAll",						"",						"\tcookies ifNotNil: [ cookies removeAll ]"					],					"body" : [						"cookies ifNotNil: [ cookies removeAll ]"					],					"isTestMethod" : false,					"category" : "operations",					"comment" : [ ],					"hash" : 2191244,					"argumentNames" : [ ]				},				"LGitIndex" : {					"sourceCode" : [						"removeAll",						"",						"\t| pathspec |",						"\tpathspec := LGitStringArray withAll: #(  ).",						"\tself withReturnHandlerDo: [ ",						"\t\tself",						"\t\t\tindex_remove_all: self",						"\t\t\tpathspec: pathspec",						"\t\t\tcallback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])",						"\t\t\tpayload: nil ]"					],					"body" : [						"| pathspec |",						"pathspec := LGitStringArray withAll: #(  ).",						"self withReturnHandlerDo: [ ",						"\tself",						"\t\tindex_remove_all: self",						"\t\tpathspec: pathspec",						"\t\tcallback: (LGitIndexMatchedPathCallback on: [ :a :b :c | 0 ])",						"\t\tpayload: nil ]"					],					"isTestMethod" : false,					"category" : "operations",					"comment" : [ ],					"hash" : 7612276,					"argumentNames" : [ ]				},				"Bag" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.",						"\tAn alternative implementation preserving capacity would be to create a new contents:",						"\tself setContents: (self class contentsClass new: contents size).\"",						"",						"\tcontents removeAll"					],					"body" : [						"contents removeAll"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Implementation Note: as contents will be overwritten, a shallowCopy of self would be modified.",						"\tAn alternative implementation preserving capacity would be to create a new contents:",						"\tself setContents: (self class contentsClass new: contents size)."					],					"hash" : 1657592,					"argumentNames" : [ ]				},				"SpCollectionListModel" : {					"sourceCode" : [						"removeAll",						"",						"\tcollection := #(  ).",						"",						"\tself refreshList.",						"\tself announcer announce: (ValueChanged newValue: self)"					],					"body" : [						"collection := #(  ).",						"",						"self refreshList.",						"self announcer announce: (ValueChanged newValue: self)"					],					"isTestMethod" : false,					"category" : "collection",					"comment" : [ ],					"hash" : 3039418,					"argumentNames" : [ ]				},				"RunArray" : {					"sourceCode" : [						"removeAll",						"",						"\truns := Array new.",						"\tvalues := Array new"					],					"body" : [						"runs := Array new.",						"values := Array new"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 2457676,					"argumentNames" : [ ]				},				"LRUCache" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove all key/value pairs that I currently hold,",						"\teffectiley resetting me, but not my statistics.\"",						"",						"\tself critical: [ ",						"\t\tlruList removeAll.",						"\t\tkeyIndex removeAll.",						"\t\tweight reset ]"					],					"body" : [						"self critical: [ ",						"\tlruList removeAll.",						"\tkeyIndex removeAll.",						"\tweight reset ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Remove all key/value pairs that I currently hold,",						"\teffectiley resetting me, but not my statistics."					],					"hash" : 2425698,					"argumentNames" : [ ]				},				"AlienWeakTable" : {					"sourceCode" : [						"removeAll",						"",						"\taccessProtect critical: [ ",						"\t\t1 to: lastUsedIndex do: [ :index | ",						"\t\t\tstrongArray at: index put: nil.",						"\t\t\tweakArray at: index put: nil ].",						"\t\tfirstUnusedIndex := 1.",						"\t\tlastUsedIndex := 0 ]"					],					"body" : [						"accessProtect critical: [ ",						"\t1 to: lastUsedIndex do: [ :index | ",						"\t\tstrongArray at: index put: nil.",						"\t\tweakArray at: index put: nil ].",						"\tfirstUnusedIndex := 1.",						"\tlastUsedIndex := 0 ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1280278,					"argumentNames" : [ ]				},				"SpecFocusOrder" : {					"sourceCode" : [						"removeAll",						"",						"\t^ presenters removeAll"					],					"body" : [						"^ presenters removeAll"					],					"isTestMethod" : false,					"category" : "to clean later",					"comment" : [ ],					"hash" : 1738787,					"argumentNames" : [ ]				},				"CollectionValueHolder" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Note: I'm not sure about the semantics here, because Collections normally don't return anything on #removeAll, even though one might expect the original content. Use with care.\"",						"",						"\tvalue removeAll.",						"\tself valueRemoved: nil"					],					"body" : [						"value removeAll.",						"self valueRemoved: nil"					],					"isTestMethod" : false,					"category" : "protocol",					"comment" : [						"Note: I'm not sure about the semantics here, because Collections normally don't return anything on #removeAll, even though one might expect the original content. Use with care."					],					"hash" : 1444372,					"argumentNames" : [ ]				},				"ExecutionCounter class" : {					"sourceCode" : [						"removeAll",						"",						"\tself allCounters values do: [ :aWatchpoint | aWatchpoint uninstall ].",						"\tCounters := nil"					],					"body" : [						"self allCounters values do: [ :aWatchpoint | aWatchpoint uninstall ].",						"Counters := nil"					],					"isTestMethod" : false,					"category" : "cleanup",					"comment" : [ ],					"hash" : 4132281,					"argumentNames" : [ ]				},				"Array2D" : {					"sourceCode" : [						"removeAll",						"",						"\tself shouldNotImplement"					],					"body" : [						"self shouldNotImplement"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1650244,					"argumentNames" : [ ]				},				"LinkedList" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Implementation note: this has to be fast\"",						"",						"\tfirstLink := lastLink := nil"					],					"body" : [						"firstLink := lastLink := nil"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Implementation note: this has to be fast"					],					"hash" : 1820059,					"argumentNames" : [ ]				},				"StSpotter" : {					"sourceCode" : [						"removeAll",						"",						"\tmutex critical: [ queue removeAll ].",						"\tcategories removeAll.",						"\tself allowUIToDraw"					],					"body" : [						"mutex critical: [ queue removeAll ].",						"categories removeAll.",						"self allowUIToDraw"					],					"isTestMethod" : false,					"category" : "private",					"comment" : [ ],					"hash" : 6941234,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolQueue" : {					"sourceCode" : [						"removeAll",						"",						"\ttop ifNotNil: [ ",						"\t\tbottom nextLink: avail.",						"\t\tavail := top.",						"\t\ttop := bottom := nil ]"					],					"body" : [						"top ifNotNil: [ ",						"\tbottom nextLink: avail.",						"\tavail := top.",						"\ttop := bottom := nil ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 8433851,					"argumentNames" : [ ]				},				"HashedCollection" : {					"sourceCode" : [						"removeAll",						"",						"\t\"remove all elements from this collection.",						"\tPreserve the capacity\"",						"",						"\tself initialize: self capacity"					],					"body" : [						"self initialize: self capacity"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"remove all elements from this collection.",						"\tPreserve the capacity"					],					"hash" : 1643060,					"argumentNames" : [ ]				},				"ProcessList" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Implementation note: this has to be fast\"",						"",						"\tfirstLink := lastLink := nil"					],					"body" : [						"firstLink := lastLink := nil"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Implementation note: this has to be fast"					],					"hash" : 1888411,					"argumentNames" : [ ]				},				"SharedQueue" : {					"sourceCode" : [						"removeAll",						"",						"\tmonitor critical: [ items removeAll ]"					],					"body" : [						"monitor critical: [ items removeAll ]"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 1926422,					"argumentNames" : [ ]				},				"DoubleLinkedList" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove all the elements that I hold.\"",						"",						"\thead := tail := nil"					],					"body" : [						"head := tail := nil"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Remove all the elements that I hold."					],					"hash" : 2423963,					"argumentNames" : [ ]				},				"WideCharacterSet" : {					"sourceCode" : [						"removeAll",						"",						"\tmap removeAll.",						"\tbyteArrayMap := ByteArray new: 256"					],					"body" : [						"map removeAll.",						"byteArrayMap := ByteArray new: 256"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1984151,					"argumentNames" : [ ]				},				"Heap" : {					"sourceCode" : [						"removeAll",						"",						"\tarray atAllPut: nil.",						"\ttally := 0"					],					"body" : [						"array atAllPut: nil.",						"tally := 0"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1798003,					"argumentNames" : [ ]				},				"Collection" : {					"sourceCode" : [						"removeAll",						"",						"\t\"Remove each element from the receiver and leave it empty.",						"\tArrayedCollections cannot respond to this message.",						"\tThere are two good reasons why a subclass should override this message:",						"\t1) the subclass does not support being modified while being iterated",						"\t2) the subclass provides a much faster way than iterating through each element\"",						"",						"\tself do: [ :each | self remove: each ]"					],					"body" : [						"self do: [ :each | self remove: each ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Remove each element from the receiver and leave it empty.",						"\tArrayedCollections cannot respond to this message.",						"\tThere are two good reasons why a subclass should override this message:",						"\t1) the subclass does not support being modified while being iterated",						"\t2) the subclass provides a much faster way than iterating through each element"					],					"hash" : 1643579,					"argumentNames" : [ ]				},				"CharacterSet" : {					"sourceCode" : [						"removeAll",						"",						"\tmap atAllPut: 0"					],					"body" : [						"map atAllPut: 0"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 1677657,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolStack" : {					"sourceCode" : [						"removeAll",						"",						"\t| link |",						"\ttop ifNotNil: [ ",						"\t\tlink := top.",						"\t\t[ link nextLink ] whileNotNil: [ link := link nextLink ].",						"\t\tlink nextLink: avail.",						"\t\tavail := top.",						"\t\ttop := nil ]"					],					"body" : [						"| link |",						"top ifNotNil: [ ",						"\tlink := top.",						"\t[ link nextLink ] whileNotNil: [ link := link nextLink ].",						"\tlink nextLink: avail.",						"\tavail := top.",						"\ttop := nil ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 8697257,					"argumentNames" : [ ]				},				"SpMillerLayout" : {					"sourceCode" : [						"removeAll",						"",						"\tchildren removeAll.",						"\tadapter ifNotNil: [ :anAdapter | ",						"\t\tanAdapter unsubscribe.",						"\t\tanAdapter removeAll ]"					],					"body" : [						"children removeAll.",						"adapter ifNotNil: [ :anAdapter | ",						"\tanAdapter unsubscribe.",						"\tanAdapter removeAll ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 3271632,					"argumentNames" : [ ]				},				"FreeTypeCache" : {					"sourceCode" : [						"removeAll",						"",						"\tfontTable := self dictionaryClass new: 100.",						"\tfifo := self fifoClass new.",						"\tused := 0"					],					"body" : [						"fontTable := self dictionaryClass new: 100.",						"fifo := self fifoClass new.",						"used := 0"					],					"isTestMethod" : false,					"category" : "add-remove",					"comment" : [ ],					"hash" : 2663980,					"argumentNames" : [ ]				}			},			"senders" : [				"ASTCache>>#reset",				"Alien class>>#startUp:",				"Announcer>>#gtInspectorAnnouncementsIn:context:",				"Bag>>#removeAll",				"BagTest>>#testRemoveAll",				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"Breakpoint class>>#cleanUp",				"Breakpoint class>>#debugWorldMenuOn:",				"BreakpointObserverTest>>#tearDown",				"BreakpointTest>>#tearDown",				"BreakpointTest>>#setUp",				"CTLinkedStoragePoolTest>>#testRemoveAllFromQueue",				"CTLinkedStoragePoolTest>>#testRemoveAllFromStack",				"ClyActiveBreakpointsQueryTest>>#tearDown",				"ClyFullEnvironmentUpdateStrategy>>#publishCollectedChanges",				"ClyMethodCallCountersQueryTest>>#tearDown",				"ClyMethodWatchQueryTest>>#tearDown",				"ClyNavigationHistory>>#recordState:",				"ClyNavigationHistory>>#clear",				"ClyNavigationHistoryTest>>#setUp",				"ClyNotebookManager>>#pageChanged:",				"ClyQueryResultMetadata>>#reset",				"ClyTabManager>>#tabSelected:",				"CoResultSet>>#resetFilter",				"Collection>>#removeAll:",				"CollectionValueHolder>>#removeAll",				"ConfigurableHistoryIterator>>#register:",				"DAPackageDependencyTest>>#testContainsOnlyExtensionDependency",				"DialogItemsChooserUI>>#removeSelectedItems",				"DialogItemsChooserUI>>#removeAllItems",				"DialogItemsChooserUI>>#addAllItems",				"DialogItemsChooserUI>>#selectedItemsSearchingString:",				"DialogItemsChooserUI>>#unselectedItemsSearchingString:",				"DialogItemsChooserUI>>#addSelectedItems",				"DictionaryTest>>#testIsHealthy",				"DictionaryTest>>#testRemoveAll",				"DictionaryValueHolder>>#removeAll",				"EDDebuggingAPITest>>#testResetStack",				"FBDOptimizedMessagesRewriter>>#rewriteSeq:with:",				"FFICallbackThunk class>>#startUp:",				"FFIMethodRegistry>>#reset",				"FreeTypeCache>>#shrinkTo:",				"FreeTypeCache class>>#startUp:",				"FreeTypeCache class>>#shutDown:",				"FreeTypeCacheTest>>#testGlyphAccessIsThreadSafeWhenAskingWidth",				"FreeTypeCacheTest>>#testRemoveAll",				"FreeTypeCacheTest>>#testGlyphAccessIsThreadSafe",				"FreeTypeSettings>>#hintingSymbol:",				"FreeTypeSettings>>#pretendBitBltSubPixelUnavailableDuring:",				"GLMBrick>>#privateRemoveAllBricks",				"GLMBrickStructureTrait>>#privateRemoveAllBricks",				"GLMBrowser>>#removeAllPanes",				"GLMPharoScriptPresentation>>#resetBindings",				"GTMockCandidatesList>>#reset",				"GTMockCandidatesList>>#addAllCandidates:in:",				"GTSpotterCandidatesList>>#removeAllCandidates",				"IceTipReadOnlyFormBuilder>>#items:",				"KMBuffer>>#clearBuffer",				"KMCatcherMorph>>#clear",				"KMDispatcher>>#detachAllKeymapCategories",				"LRUCache>>#removeAll",				"LRUCacheTest>>#testRemoveAll",				"LinkedListTest>>#testRemoveAll",				"ListPresenter>>#resetListSelection",				"ListPresenter>>#resetSelection",				"MetaLink>>#uninstall",				"MetaLinkInstaller>>#removeAllAnonymousNodesIn:fromAnonSubclassesOf:",				"MethodDictionaryTest>>#testRemoveAllPreservesCapacity",				"MorphTreeListManager>>#emptySelection",				"MorphTreeMorph>>#removeColumnResizers",				"NetworkSystemSettings class>>#removeAllHttpProxyExceptions",				"OSSDLPasteEventFilter>>#flushEvents",				"OSTouchFingerTracker>>#firstPosition:",				"OSWindowJoystickExample>>#reset",				"OrderedCollectionTest>>#testRemoveAll",				"OrderedDictionary>>#removeAll",				"OrderedDictionaryTest>>#testRemoveAll",				"PickListPresenter>>#items:",				"PluggableMenuSpec>>#addToMenuModel:",				"PragmaMenuAndShortcutRegistration>>#handOutItems",				"ProcessMonitorTestService>>#cleanUpAfterTest",				"Protocol>>#removeAllMethodSelectors",				"RBParser>>#getErrorFromClosuresWithMissingOpenings:",				"RBParser>>#saveCommentsDuring:",				"RSAnimationExamples>>#example45Beziers",				"RSDelaunay class>>#generateMesh:circle:vertices:",				"RSKeyNavigationCanvasInteraction>>#processKeyUp:",				"RadioButtonGroupPresenter>>#rebuildWidget",				"SDL2AthensDrawingExample>>#clearStrokes",				"STONReader>>#reset",				"STONTestKnownObject class>>#resetKnownObjects",				"STONWriter>>#reset",				"STONWriterTest>>#testMap",				"SetTest>>#testIsHealthy",				"SetTest>>#testRemoveAll",				"SettingDeclaration>>#emptyList",				"SharedQueue>>#removeAll",				"SharedQueue>>#flush",				"SindarinDebuggerTest>>#setUp",				"SindarinDebuggerTest>>#tearDown",				"SlotClassBuilderTest>>#cleanUpTrait:",				"SortedCollectionTest>>#testRemoveAll",				"SpApplication>>#reset",				"SpBoxLayout>>#removeAll",				"SpDemo>>#connectPresenters",				"SpDropListAdapterTest>>#testRemovingIconsAfterAddingThem",				"SpMenuPresenter>>#fromSpec:",				"SpMillerLayout>>#removeAll",				"SpMillerPaginatorPresenter>>#updatePaginator:",				"SpMorphicMenuBarAdapter>>#emptyAccumulator:",				"SpNotebookAdapterTest>>#testRemoveAll",				"SpNotebookPresenter>>#removeAll",				"SpPaginatorPresenter>>#pages:",				"SpPresenterSelectorPresenter>>#updatePresenter",				"SpecDemoDynamicMemoryGamePresenter>>#gameLogicWithShowedCards:objectConcerned:andAssociatedPresenter:",				"SpecFocusOrder>>#removeAll",				"SpecFocusOrderTest>>#testRemoveAll",				"SptQuery>>#updateFromContext:",				"SptWithoutDuplicatesDecorator>>#clearDuplicates",				"StMockCandidatesList>>#reset",				"StMockCandidatesList>>#addAllCandidates:in:",				"StQuery>>#updateFromContext:",				"StSpotter>>#showPreview:",				"StSpotter>>#removeAllResults",				"StSpotter>>#startNewProcess",				"StSpotter>>#removeAll",				"StSpotterCandidatesList>>#removeAllCandidates",				"StWithoutDuplicatesDecorator>>#clearDuplicates",				"StartupPreferencesLoader>>#load:",				"TFCallbackQueue>>#shutDown",				"TKTCommonQueueWorkerPool>>#purge",				"TKTCommonQueueWorkerPool>>#cleanUpImageToStart",				"TKTCommonQueueWorkerPool>>#stop",				"TKTQueueTaskScheduler>>#purge",				"TKTWatchDog>>#cleanUpImageToStart",				"TKTWorkerPool>>#stop",				"TabBarMorph>>#tabs:",				"TabManagerMorph>>#cleanProcesses",				"Termcap>>#flush",				"TestExecutionEnvironment>>#removeAllServices",				"ToolDockingBarMorph>>#emptyAccumulator:",				"WeakRegistry>>#removeAll",				"WideCharacterSet>>#removeAll",				"ZdcByteArrayManager>>#limit:",				"ZdcByteArrayManager class>>#cleanUp",				"ZnBasicAuthenticator>>#removeAll",				"ZnCookieJar>>#removeAll",				"ZnManagingMultiThreadedServer>>#closeConnections",				"ZnUrl>>#queryRemoveAll",				"ZnUrl>>#clearPath",				"ZnUserAgentSession>>#resetCookies"			]		},		"testPopFromEmptyStack" : {			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testPopFromEmptyStack",						"",						"\tself",						"\t\tshould: [ ",						"\t\t\tCTLinkedStoragePoolStack new",						"\t\t\t\tpush: 3;",						"\t\t\t\tpop;",						"\t\t\t\tpop ]",						"\t\traise: CollectionIsEmpty"					],					"body" : [						"self",						"\tshould: [ ",						"\t\tCTLinkedStoragePoolStack new",						"\t\t\tpush: 3;",						"\t\t\tpop;",						"\t\t\tpop ]",						"\traise: CollectionIsEmpty"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8434582,					"argumentNames" : [ ]				}			},			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			]		},		"testSomePushesThenPopsOnStack" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc"			],			"implementors" : {				"CTLinkedStoragePoolTest" : {					"sourceCode" : [						"testSomePushesThenPopsOnStack",						"",						"\t| stack steps |",						"\tsteps := OrderedCollection new",						"\t\t         add: (Message selector: #push: arguments: { 3 });",						"\t\t         add: (Message selector: #push: arguments: { 4 });",						"\t\t         add: (Message selector: #push: arguments: { 5 });",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #pop);",						"\t\t         add: (Message selector: #push: arguments: { 6 });",						"\t\t         yourself.",						"",						"\tstack := CTLinkedStoragePoolStack new.",						"",						"\tsteps withIndexDo: [ :each :i | ",						"\t\teach sendTo: stack.",						"\t\tself exportSlotsGraphOf: stack pathSuffix: i asString ]"					],					"body" : [						"| stack steps |",						"steps := OrderedCollection new",						"\t         add: (Message selector: #push: arguments: { 3 });",						"\t         add: (Message selector: #push: arguments: { 4 });",						"\t         add: (Message selector: #push: arguments: { 5 });",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #pop);",						"\t         add: (Message selector: #push: arguments: { 6 });",						"\t         yourself.",						"",						"stack := CTLinkedStoragePoolStack new.",						"",						"steps withIndexDo: [ :each :i | ",						"\teach sendTo: stack.",						"\tself exportSlotsGraphOf: stack pathSuffix: i asString ]"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 8961253,					"argumentNames" : [ ]				}			}		},		"push:" : {			"implementors" : {				"CTLinkedStoragePoolCircular" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\tp := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead",						"\t\tvalue: head value + 1;",						"\t\tnextLink: p.",						"\t^ p"					],					"body" : [						"| p |",						"p := self allocateOrReuseLink",						"\t     value: anObject;",						"\t     nextLink: head nextLink;",						"\t     yourself.",						"head",						"\tvalue: head value + 1;",						"\tnextLink: p.",						"^ p"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 25734638,					"argumentNames" : [						"anObject"					]				},				"CTHeapQ" : {					"sourceCode" : [						"push: anObject",						"",						"\ttally = heap size ifTrue: [ heap := heap grownBy: tally ].",						"\ttally := tally + 1.",						"\t^ self",						"\t\t  at: tally put: anObject;",						"\t\t  siftDown: 1 to: tally;",						"\t\t  itself: anObject"					],					"body" : [						"tally = heap size ifTrue: [ heap := heap grownBy: tally ].",						"tally := tally + 1.",						"^ self",						"\t  at: tally put: anObject;",						"\t  siftDown: 1 to: tally;",						"\t  itself: anObject"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 20202621,					"argumentNames" : [						"anObject"					]				},				"GTSpotterStepsBreadcrumb" : {					"sourceCode" : [						"push: aBrick",						"",						"\tself themer spotterThemer breadcrumbItemStyleFor: aBrick.",						"",						"\tself band layoutAfter: [ ",						"\t\tself items isEmpty ifFalse: [ ",						"\t\t\tself items last hideTriangle.",						"\t\t\tself addSeparator ].",						"\t\tself addItem: aBrick ].",						"",						"\t\"optimization. if first item was added we need to update root to reposition all bricks,",						"\totherwise only I need to be updated\"",						"\tself items size = 1",						"\t\tifTrue: [ self notifyBreadcrumbVisibilityChanged ]",						"\t\tifFalse: [ ",						"\t\t\tself scrollToTheLastOne.",						"\t\t\tself changed ]"					],					"body" : [						"self themer spotterThemer breadcrumbItemStyleFor: aBrick.",						"",						"self band layoutAfter: [ ",						"\tself items isEmpty ifFalse: [ ",						"\t\tself items last hideTriangle.",						"\t\tself addSeparator ].",						"\tself addItem: aBrick ].",						"",						"\"optimization. if first item was added we need to update root to reposition all bricks,",						"\totherwise only I need to be updated\"",						"self items size = 1",						"\tifTrue: [ self notifyBreadcrumbVisibilityChanged ]",						"\tifFalse: [ ",						"\t\tself scrollToTheLastOne.",						"\t\tself changed ]"					],					"isTestMethod" : false,					"category" : "adding/removing",					"comment" : [ ],					"hash" : 23718477,					"argumentNames" : [						"aBrick"					]				},				"DATarjanAlgorithm" : {					"sourceCode" : [						"push: aPDPackage",						"",						"\tstack push: aPDPackage.",						"\taPDPackage inStack: true \"use a flag to avoid stack access\""					],					"body" : [						"stack push: aPDPackage.",						"aPDPackage inStack: true \"use a flag to avoid stack access\""					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 19587669,					"argumentNames" : [						"aPDPackage"					]				},				"IRStackCount" : {					"sourceCode" : [						"push: n",						"",						"\t(position := position + n) > length ifTrue: [ length := position ]"					],					"body" : [						"(position := position + n) > length ifTrue: [ length := position ]"					],					"isTestMethod" : false,					"category" : "affecting",					"comment" : [ ],					"hash" : 19076653,					"argumentNames" : [						"n"					]				},				"Context" : {					"sourceCode" : [						"push: value",						"",						"\t\"Push value on the receiver's stack.\"",						"",						"\tself stackp: stackp + 1.",						"\tself at: stackp put: value"					],					"body" : [						"self stackp: stackp + 1.",						"self at: stackp put: value"					],					"isTestMethod" : false,					"category" : "controlling",					"comment" : [						"Push value on the receiver's stack."					],					"hash" : 17843628,					"argumentNames" : [						"value"					]				},				"FLSimpleStack" : {					"sourceCode" : [						"push: anObject",						"",						"\t\"Adds a new object of any kind on top of the stack.\"",						"",						"\tarray at: slotIndex put: anObject.",						"\tarray size = slotIndex ifTrue: [ self grow ].",						"\tslotIndex := slotIndex + 1.",						"\t^ anObject"					],					"body" : [						"array at: slotIndex put: anObject.",						"array size = slotIndex ifTrue: [ self grow ].",						"slotIndex := slotIndex + 1.",						"^ anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [						"Adds a new object of any kind on top of the stack."					],					"hash" : 19559752,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolStack" : {					"sourceCode" : [						"push: anObject",						"",						"\ttop := self allocateOrReuseLink",						"\t\t       value: anObject;",						"\t\t       nextLink: top;",						"\t\t       yourself"					],					"body" : [						"top := self allocateOrReuseLink",						"\t       value: anObject;",						"\t       nextLink: top;",						"\t       yourself"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 25472644,					"argumentNames" : [						"anObject"					]				},				"FileSystemGuide" : {					"sourceCode" : [						"push: anObject",						"",						"\twork add: anObject"					],					"body" : [						"work add: anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 19113546,					"argumentNames" : [						"anObject"					]				},				"Stack" : {					"sourceCode" : [						"push: anObject",						"",						"\t\"Adds a new object of any kind on top of the stack.\"",						"",						"\tself addFirst: anObject.",						"\t^ anObject"					],					"body" : [						"self addFirst: anObject.",						"^ anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [						"Adds a new object of any kind on top of the stack."					],					"hash" : 18981594,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolQueue" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\tp := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     nextLink: nil;",						"\t\t     yourself.",						"\ttop ifNil: [ top := p ] ifNotNil: [ bottom nextLink: p ].",						"\tbottom := p"					],					"body" : [						"| p |",						"p := self allocateOrReuseLink",						"\t     value: anObject;",						"\t     nextLink: nil;",						"\t     yourself.",						"top ifNil: [ top := p ] ifNotNil: [ bottom nextLink: p ].",						"bottom := p"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 25736948,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolCircularDoubly" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\t\"p := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     previousLink: head;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead nextLink previousLink: p.",						"\thead nextLink: p.",						"\t^ p\"",						"\tp := (super push: anObject)",						"\t\t     previousLink: head;",						"\t\t     yourself.",						"\thead nextLink nextLink previousLink: p.",						"\t^ p"					],					"body" : [						"| p |",						"\"p := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     previousLink: head;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead nextLink previousLink: p.",						"\thead nextLink: p.",						"\t^ p\"",						"p := (super push: anObject)",						"\t     previousLink: head;",						"\t     yourself.",						"head nextLink nextLink previousLink: p.",						"^ p"					],					"isTestMethod" : false,					"category" : "API-remotes",					"comment" : [ ],					"hash" : 25734239,					"argumentNames" : [						"anObject"					]				},				"LIFOQueue" : {					"sourceCode" : [						"push: anObject",						"",						"\t^ self nextPut: anObject"					],					"body" : [						"^ self nextPut: anObject"					],					"isTestMethod" : false,					"category" : "stack-compliant protocol",					"comment" : [ ],					"hash" : 18930067,					"argumentNames" : [						"anObject"					]				}			},			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"BreadthFirstGuide>>#show:",				"CTHeapQTest>>#testPushPop",				"CTLinkedStoragePoolArray2D>>#at:at:put:",				"CTLinkedStoragePoolCircularDoubly>>#push:",				"CTLinkedStoragePoolPolynomial class>>#termAssociations:",				"CTLinkedStoragePoolTest>>#testPopFromEmptyStack",				"CTLinkedStoragePoolTest>>#testRemoveAllFromQueue",				"CTLinkedStoragePoolTest>>#testPopFromEmptyQueue",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnStack",				"CTLinkedStoragePoolTest>>#testRemoveAllFromStack",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnQueue",				"CodeSimulationTest>>#testErrorCodeNotFoundIndexed",				"CodeSimulationTest>>#testErrorCodeNotFound",				"ConfigurableHistoryIterator>>#undoIfEmpty:",				"ConfigurableHistoryIterator>>#redoIfEmpty:",				"ConfigurableHistoryIterator>>#register:",				"Context>>#pushClosureTemps:",				"Context>>#pushTemporaryVariable:",				"Context>>#pushReceiver",				"Context>>#pushNewArrayOfSize:",				"Context>>#pushRemoteTemp:inVectorAt:",				"Context>>#doPrimitive:method:receiver:args:",				"Context>>#pushConsArrayWithElements:",				"Context>>#pushActiveProcess",				"Context>>#pushActiveContext",				"Context>>#jump",				"Context>>#pushConstant:",				"Context>>#pushLiteralVariable:",				"Context>>#callPrimitive:",				"Context>>#pushReceiverVariable:",				"Context>>#return:from:",				"Context>>#return:to:",				"Context>>#pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:",				"Context>>#pushClosureCopyNumCopiedValues:numArgs:blockSize:",				"Context>>#doDup",				"Context class>>#contextOn:do:",				"Context class>>#contextEnsure:",				"DATarjanAlgorithm>>#push:",				"DATarjanAlgorithm>>#traverse:",				"DATarjanAlgorithmTest>>#testPush",				"FFIFunctionResolutionTest>>#pushLiteral:",				"FFIFunctionResolutionTest>>#pushLiteralVariable:",				"FFIFunctionResolutionTest>>#pushReceiver",				"FFIFunctionResolutionTest>>#pushTemp:",				"FFIFunctionResolutionTest>>#pushInstVar:",				"FLAnalysis>>#privateTrace:",				"FLAnalysis>>#trace:",				"FLAnalysis>>#run",				"FLSimpleStackTest>>#testPop",				"FLSimpleStackTest>>#testGrow",				"FLSimpleStackTest>>#testPush",				"FileSystemGuide>>#pushAll:",				"GTSpotterStepsBreadcrumb>>#onStepAdded:",				"HiRulerBuilder>>#stackLinksFrom:in:",				"IRBuilder>>#pushScope:",				"IRBytecodeDecompiler>>#pushScope:numArgs:",				"IRStackCount>>#push",				"IRTranslator>>#pushOuterVectors:",				"IRTranslator>>#visitTempVector:",				"IRTranslator>>#pushScope:",				"LzwGifDecoder>>#handleCode:withPreviousCode:on:",				"MCScanner>>#next",				"MalTarjan>>#putOnStack:",				"MicInlineSplitter>>#pushNewOpener",				"MicrodownStyleHelpBuilder>>#helpTopicFromFormattedString:title:",				"PostorderGuide>>#pushVisit:",				"PostorderGuide>>#pushTraverse:",				"PreorderGuide>>#show:",				"Process>>#stepToHome:",				"RBRefactoryChangeManager>>#addUndo:",				"RBRefactoryChangeManager>>#addUndoPointer:",				"SindarinDebugger>>#skipMessageNodeWith:",				"SindarinDebugger>>#skipAssignmentNodeWith:",				"SpMenuPresenterBuilder>>#visitCommandGroup:",				"SpMenuPresenterBuilder>>#initialize",				"StackTest>>#testTop",				"StackTest>>#testSize",				"StackTest>>#testEmptyError",				"StackTest>>#setUp",				"StackTest>>#testPop",				"StackTest>>#testPush",				"TFRunner>>#executeCallback:",				"TypingVisitor>>#initialize",				"TypingVisitor>>#visitBlockNode:",				"WikiStyleHelpBuilder>>#helpTopicFromFormattedString:title:"			]		},		"newLink" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"CTLinkedStoragePool>>#allocateOrReuseLink",				"CTLinkedStoragePoolCircular>>#initialize",				"IceTipWorkingCopyStatusBar>>#refreshWithCommitId:",				"SpDemoLinksPresenter>>#initializePresenters",				"StSpotter>>#addTipsPanel"			],			"implementors" : {				"SpPresenter" : {					"sourceCode" : [						"newLink",						"",						"\t^ self instantiate: SpLinkPresenter"					],					"body" : [						"^ self instantiate: SpLinkPresenter"					],					"isTestMethod" : false,					"category" : "*Spec2-Morphic",					"comment" : [ ],					"hash" : 3067810,					"argumentNames" : [ ]				},				"SpPresenterBuilder" : {					"sourceCode" : [						"newLink",						"",						"\t^ self instantiate: SpLinkPresenter"					],					"body" : [						"^ self instantiate: SpLinkPresenter"					],					"isTestMethod" : false,					"category" : "*Spec2-Morphic",					"comment" : [ ],					"hash" : 3050402,					"argumentNames" : [ ]				},				"SpTPresenterBuilder" : {					"sourceCode" : [						"newLink",						"",						"\t^ self instantiate: SpLinkPresenter"					],					"body" : [						"^ self instantiate: SpLinkPresenter"					],					"isTestMethod" : false,					"category" : "*Spec2-Morphic",					"comment" : [ ],					"hash" : 3023266,					"argumentNames" : [ ]				},				"CTLinkedStoragePool" : {					"sourceCode" : [						"newLink",						"",						"\t^ ValueLink new"					],					"body" : [						"^ ValueLink new"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 8429871,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolCircularDoubly" : {					"sourceCode" : [						"newLink",						"",						"\t^ CTDoubleValueLink new"					],					"body" : [						"^ CTDoubleValueLink new"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 8430895,					"argumentNames" : [ ]				}			}		}	}}