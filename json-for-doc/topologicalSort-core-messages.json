{	"classes" : {		"TopologicalSortAlgorithm" : {			"hash" : 2244608,			"definition" : "Object subclass: #TopologicalSortAlgorithm\r\tinstanceVariableNames: 'size relation'\r\tclassVariableNames: ''\r\tpackage: 'Containers-Links'",			"comment" : [				"Implementation of the Algorithm T in TAOCP by Donald Knuth, Volume 1 page 264."			],			"category" : "Containers-Links"		},		"Dictionary" : {			"hash" : 802048,			"definition" : "HashedCollection subclass: #Dictionary\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Dictionaries'",			"comment" : [				"I am a collection of elements that associate a key object with a value object.",				"",				"## Description",				"",				"",				"I  can be viewed from one of two perspectives: a set of associations, or a container of values that are externally named where the name can be any object that responds to #=. The external name is referred to as the key.  I inherit many operations from Set.",				"I use the #= method to locate a key. If you want a collection that use the #== method (same pointers) you can use an IdentityDictionary.",				"",				"I'm used when we need a collection of objects which I can access with a key. For example if you associate some words with a definition, the word will be the key and the definition will be the value. Both of them can be any kind of objects.",				"",				"Internally I use Associations. The Association class can help to use me. (See examples lower)",				"",				"I assume that my keys do not change after they have been added. The behavior of operations involving keys that have changed is undefined.",				"",				"## Public API and Key Messages",				"",				"### Initializing and Adding",				"",				"A `Dictionary` can be created with values using the `Collection class>>#withAll:` class selector which will add the ",				"values of a collection as the values of the `Dictionary` using numeric keys.",				"",				"```",				"d := Dictionary withAll: #(1 2 3 4 5)  \"a Dictionary(1->1, 2->2, 3->3, 4->4, 5->5)\"",				"```",				"",				"Alternatively, both the keys and values can be supplied using the `Dictionary class>>#newFromKeys:andValues:` selector,",				"which requires two collections of the same length, or the `Dictionary class>>#newFromPairs:` selector, which ",				"uses every odd numbered index as a key and even numbered index as a value for the dictionary.",				"",				"Once a `Dictionary` has been created, the basic method for adding new keys is the `Dictionary>>#at:put:` selector.",				"",				"```",				"d at: 99 put: 89  \"a Dictionary(1->1, 2->2, 3->3, 4->4, 5->5, 99->89)\"",				"```",				"",				"### Accessing ",				"",				"Get the value of a key using the `Dictionary>>#at:` selector.",				"",				"```",				"d := Dictionary withAll: #(5 4 3 2 1)  \"a Dictionary(1->5, 2->4, 3->3, 4->2, 5->1)\"",				"d at: 1  \"5\"",				"```",				"However accessing a key that does not exist will result in an error. In which case use",				"the selectors `Dictionary>>#at:ifAbsent:`",				"",				"```",				"d at: 100 ifAbsent: [ \"execute code in the block if the key is not found\" ]",				"```",				"",				"A common operation is to add in a value for a key if it is absent using the `Dictionary>>#at:ifAbsentPut:` selector. Note that unlike the regular `Dictionary>>#at:put:` selector, this message uses the value of a block. ",				"",				"```",				"d at: 100 ifAbsentPut: [ 100 ]",				"```",				"",				"Alternatively, if you want to change the value of a key use `Dictionary>>#at:update:` selector,",				"which uses the value of a block.",				"",				"```",				"d at: 5 update: [ 12 ]",				"\"a Dictionary(1->5,2->4,3->3,4->2,5->12,100->100)\"",				"```",				"",				"### Iterating / Enumerating",				"",				"It's possible to iterate over all of the values, keys, and associations of a `Dictionary` using ",				"the `Dictionary>>#valuesDo:`, `Dictionary>>#keysDo:`, and `Dictionary>>#associationsDo:` selectors. These selectors evaluate a block for",				"each of the items",				"",				"```",				"\"do: is an alias for valuesDo:\"",				"d valuesDo: [ :eachValue | \"do something with the value\" ].",				"d keysDo: [ :eachKey | \"do something with the key\" ].",				"d associationsDo: [ :eachAssociation | \"do something with a key-value pair\" ]",				"```",				"",				"The `Dictionary>>#select:` selector is also implemented to return a subset of the `Dictionary` where the",				"block evaluates to true using the value.",				"",				"```",				"d select: [:each | each > 5]  \"a Dictionary(5->12,100->100)\"",				"``` ",				"\t\t",				"### Removing",				"",				"Use the `Dictionary>>#removeKey:` selector to remove the association from the `Dictionary`, which will cause",				"an error if the key is not found. Use the `Dictionary>>#removeKey:ifAbsent:` selector to control this behavior.",				"",				"```",				"d removeKey: 5.",				"d removeKey: 1200.  \"Error\"",				"d removeKey: 1200 ifAbsent: [ \"do something\" ].",				"```",				"",				"### Testing",				"",				"Check if a value or key is present in a `Dictionary` using the `Dictionary>>#includes:` or `Dictionary>>#includesKey:` selectors.",				"",				"```",				"\"Look if 12 is the value of any key in the Dictionary\"",				"d includes: 12.",				"",				"\"Look if 100 is a key in the Dictionary\"",				"d includesKey: 100.",				"```",				"## Examples ",				"",				"",				"To create a dictionary with indexes as key: ",				"",				"```",				"\tDictionary withAll: #(7 3 1 3)   \t\t\"returns:  a Dictionary(1->7 2->3 3->1 4->3 \"",				"```",				"",				"To use Objects as key (here symbols): ",				"",				"```",				"\tcolors := Dictionary new ",				"\t\t\t\tat: #yellow put: Color yellow; ",				"\t\t\t\tat: #blue put: Color blue;",				"\t\t\t\tat: #red put: Color red;",				"\t\t\t\tyourself.",				"\t\t\t\t",				"\tcolors at: #yellow. \t\"returns:  Color yellow\"",				"\tcolors keys          \"returns: a Set(#blue #yellow #red)\"",				"\tcolors values       \"returns:  {Color blue. Color yellow. Color red}\" ",				"```",				"",				"You can also directly use Associations: ",				"",				"```",				"\tcolors := Dictionary with: #yellow -> Color yellow with: #blue -> Color blue.",				"\tcolors add: #red -> Color red.",				"\t",				"\tcolors associations  \t\"returns: {#yellow->Color yellow. #red->Color red. #blue->Color blue}\"",				"```",				"\t",				"Here some more examples: ",				"",				"```",				"\tcolors := Dictionary newFrom: { #blue->Color blue . #red->Color red . #yellow->Color yellow }. ",				"\tcolors removeKey: #blue. ",				"\tcolors at: #red ifPresent: [ :color |  color darker] ifAbsent: [ Error signal: 'The red color should be here.' ] .\t\t\"return: (Color r: 0.92 g: 0.0 b: 0.0 alpha: 1.0)\"",				"\tcolors associations \t\t \"{#yellow->Color yellow. #red->Color red}\"",				"```",				"",				"## Internal Representation and Key Implementation Points.",				"",				"I am just a collection of associations. If I need my keys I will just return the keys of my associations. Idem for my values.",				"I use the #= method in order to manipulate my keys. I cannot have two associations that are equals with the #= method."			],			"category" : "Collections-Unordered-Dictionaries"		},		"Association" : {			"hash" : 791296,			"definition" : "LookupKey subclass: #Association\r\tinstanceVariableNames: 'value'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-Associations'",			"comment" : [				"I represent a pair of associated objects--a key and a value. My instances can serve as entries in a dictionary.",				"",				"",				"Implementation notes: ",				"Note that hash is not redefined even if the = was redefined because Association>>hash may cause extreme slowdowns in compiling Unicode methods. Association>>hash does not need to hash the value; it's slow and useless.",				""			],			"category" : "Collections-Support-Associations"		},		"CollectionTest" : {			"hash" : 4379648,			"definition" : "TestCase subclass: #CollectionTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-Tests-Base'",			"comment" : [				"Basic Collection tests"			],			"category" : "Collections-Support-Tests-Base"		},		"DictionaryTest" : {			"hash" : 4391936,			"definition" : "CollectionRootTest subclass: #DictionaryTest\r\tuses: TIncludesTest + TDictionaryAddingTest + TDictionaryComparingTest + TDictionaryCopyingTest + TDictionaryEnumeratingTest + (TDictionaryPrintingTest - {#testPrintElementsOn. #testStoreOn}) + TDictionaryRemovingTest + (TPutBasicTest - {#testAtPutOutOfBounds}) + TAsStringCommaAndDelimiterTest + TPrintTest + TConvertTest + TConvertAsSortedTest + (TCopyTest - {#testCopyEmptyWithout. #testCopyNonEmptyWithout. #testCopyNonEmptyWithoutNotIncluded}) + TSetArithmetic + TDictionaryIncludesWithIdentityCheckTest + TDictionaryValueAccessTest + TDictionaryKeysValuesAssociationsAccess + TDictionaryKeyAccessTest + TDictionaryAssociationAccessTest + TStructuralEqualityTest + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'emptyDict nonEmptyDict nonEmpty5ElementsNoDuplicates indexArray valueArray nonEmpty1Element collectionNotIncluded collectionIncluded associationNotIn valueNotIn keyNotIn dictionaryNotIncluded dictionaryWithDuplicateValues duplicateValue nonEmptyWithString'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Dictionaries'",			"comment" : [				"SUnit tests for dictionaries"			],			"category" : "Collections-Unordered-Tests-Dictionaries"		},		"ObjectTest" : {			"hash" : 4440064,			"definition" : "ClassTestCase subclass: #ObjectTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Tests-Objects'",			"comment" : [				"SUnit tests for objects"			],			"category" : "Kernel-Tests-Objects"		},		"SequenceableCollection" : {			"hash" : 856320,			"definition" : "Collection subclass: #SequenceableCollection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices."			],			"category" : "Collections-Abstract-Base"		}	},	"messages" : {		"initializeValueLinksTable:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"initializeValueLinksTable: table",						"",						"\t\"T2: next relation.\"",						"",						"\trelation do: [ :anAssoc | ",						"\t\t| j k |",						"\t\t\"Unpack `relation` such that `relation = (j -> k)` holds.\"",						"\t\tj := anAssoc key.",						"\t\tk := anAssoc value.",						"",						"\t\t\"T3: Increase COUNT by one.\"",						"\t\t(table at: k) in: [ :destAssoc | destAssoc key: destAssoc key + 1 ].",						"",						"\t\t\"T3: record the relation.\"",						"\t\t(table at: j) in: [ :sourceAssoc | \"Operation (8)\" ",						"\t\t\tsourceAssoc value: k ~~> sourceAssoc value ] ]"					],					"body" : [						"relation do: [ :anAssoc | ",						"\t| j k |",						"\t\"Unpack `relation` such that `relation = (j -> k)` holds.\"",						"\tj := anAssoc key.",						"\tk := anAssoc value.",						"",						"\t\"T3: Increase COUNT by one.\"",						"\t(table at: k) in: [ :destAssoc | destAssoc key: destAssoc key + 1 ].",						"",						"\t\"T3: record the relation.\"",						"\t(table at: j) in: [ :sourceAssoc | \"Operation (8)\" ",						"\t\tsourceAssoc value: k ~~> sourceAssoc value ] ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [						"T2: next relation."					],					"hash" : 20078642,					"argumentNames" : [						"table"					]				}			}		},		"isAcyclicWithRespectToAssociations:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"isAcyclicWithRespectToAssociations: aRelation",						"",						"\t| isAcyclic |",						"\tisAcyclic := true.",						"\tself",						"\t\ttopologicalSortByAssociations: aRelation",						"\t\tonCycleDo: [ isAcyclic := false ].",						"\t^ isAcyclic"					],					"body" : [						"| isAcyclic |",						"isAcyclic := true.",						"self",						"\ttopologicalSortByAssociations: aRelation",						"\tonCycleDo: [ isAcyclic := false ].",						"^ isAcyclic"					],					"isTestMethod" : false,					"category" : "*Containers-Links",					"comment" : [ ],					"hash" : 18953732,					"argumentNames" : [						"aRelation"					]				}			}		},		"testTopologicalSortOnCycleDo2" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo2",						"",						"\t\"The following test is kept from https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg.\"",						"",						"\tself",						"\t\tassert: ((1 to: 8)",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 4).",						"\t\t\t\t\t\t (2 -> 4).",						"\t\t\t\t\t\t (2 -> 5).",						"\t\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t\t (3 -> 8).",						"\t\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t\t (4 -> 7).",						"\t\t\t\t\t\t (4 -> 8).",						"\t\t\t\t\t\t (5 -> 7) }",						"\t\t\t\t onCycleDo: [ Error signal ])",						"\t\tequals: #( 1 2 4 6 3 5 7 8 )"					],					"body" : [						"self",						"\tassert: ((1 to: 8)",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 4).",						"\t\t\t\t\t (2 -> 4).",						"\t\t\t\t\t (2 -> 5).",						"\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t (3 -> 8).",						"\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t (4 -> 7).",						"\t\t\t\t\t (4 -> 8).",						"\t\t\t\t\t (5 -> 7) }",						"\t\t\t onCycleDo: [ Error signal ])",						"\tequals: #( 1 2 4 6 3 5 7 8 )"					],					"isTestMethod" : true,					"category" : "*Containers-Links-Tests",					"comment" : [						"The following test is kept from https://upload.wikimedia.org/wikipedia/commons/0/03/Directed_acyclic_graph_2.svg."					],					"hash" : 5175604,					"argumentNames" : [ ]				}			}		},		"makeValueLinksTable" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"makeValueLinksTable",						"",						"\t\"COUNT: the number of direct predecessors of this object.\"",						"",						"\t\"TOP: link to the beginning of the list of direct successors of this object.\"",						"",						"\t^ (1 to: size) collect: [ :k | 0 -> nil ]"					],					"body" : [						"^ (1 to: size) collect: [ :k | 0 -> nil ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [						"COUNT: the number of direct predecessors of this object."					],					"hash" : 3039287,					"argumentNames" : [ ]				}			}		},		"topologicalSortByAssociations:onCycleDo:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"CollectionTest>>#testTopologicalSortOnCycleDo",				"CollectionTest>>#testTopologicalSortOnCycleDo1",				"CollectionTest>>#testTopologicalSortOnCycleDo2",				"SequenceableCollection>>#topologicalSortByAssociations:acyclicDo:",				"SequenceableCollection>>#isAcyclicWithRespectToAssociations:"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"topologicalSortByAssociations: aRelation onCycleDo: cBlock",						"",						"\t| topo |",						"\ttopo := TopologicalSortAlgorithm new",						"\t\t        size: self size;",						"\t\t        relation: aRelation;",						"\t\t        yourself.",						"",						"\t^ topo",						"\t\t  value: [ :ordering | ordering do: [ :anIndex | self at: anIndex ] ]",						"\t\t  onCycleDo: [ :cycle | ",						"\t\t\t  | sequence |",						"\t\t\t  sequence := Array streamContents: [ :aStream | ",						"\t\t\t\t              aStream nextPut: (self at: cycle first key).",						"\t\t\t\t              cycle reverseDo: [ :anAssoc | ",						"\t\t\t\t\t              aStream nextPut: (self at: anAssoc key) ] ].",						"\t\t\t  cBlock cull: sequence cull: cycle ]"					],					"body" : [						"| topo |",						"topo := TopologicalSortAlgorithm new",						"\t        size: self size;",						"\t        relation: aRelation;",						"\t        yourself.",						"",						"^ topo",						"\t  value: [ :ordering | ordering do: [ :anIndex | self at: anIndex ] ]",						"\t  onCycleDo: [ :cycle | ",						"\t\t  | sequence |",						"\t\t  sequence := Array streamContents: [ :aStream | ",						"\t\t\t              aStream nextPut: (self at: cycle first key).",						"\t\t\t              cycle reverseDo: [ :anAssoc | ",						"\t\t\t\t              aStream nextPut: (self at: anAssoc key) ] ].",						"\t\t  cBlock cull: sequence cull: cycle ]"					],					"isTestMethod" : false,					"category" : "*Containers-Links",					"comment" : [ ],					"hash" : 35993754,					"argumentNames" : [						"aRelation",						"cBlock"					]				}			}		},		"sortOn:sinksValueLink:valueLinksTable:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"sortOn: aStream sinksValueLink: qlink valueLinksTable: table",						"",						"\t| f |",						"\tf := qlink.",						"\t[ f ] whileNotNil: [ ",						"\t\t| aValueLink anIndex |",						"\t\t\"T5: output front of queue.\"",						"\t\tanIndex := f value.",						"\t\taStream nextPut: anIndex.",						"",						"\t\t\"T7: remove from queue.\"",						"\t\tf := f nextLink.",						"",						"\t\taValueLink := (table at: anIndex) in: [ :anAssoc | ",						"\t\t\t              anAssoc value yourself: [ anAssoc value: nil ] ].",						"",						"\t\t\"T6: erase relations.\"",						"\t\taValueLink do: [ :k | ",						"\t\t\t| kIndex |",						"\t\t\tkIndex := k value.",						"\t\t\t(table at: kIndex)",						"\t\t\t\tdecrementCountIfZero: [ f := kIndex ~~> f ]",						"\t\t\t\tforTopologicalSortAlgorithm: self ] ]"					],					"body" : [						"| f |",						"f := qlink.",						"[ f ] whileNotNil: [ ",						"\t| aValueLink anIndex |",						"\t\"T5: output front of queue.\"",						"\tanIndex := f value.",						"\taStream nextPut: anIndex.",						"",						"\t\"T7: remove from queue.\"",						"\tf := f nextLink.",						"",						"\taValueLink := (table at: anIndex) in: [ :anAssoc | ",						"\t\t              anAssoc value yourself: [ anAssoc value: nil ] ].",						"",						"\t\"T6: erase relations.\"",						"\taValueLink do: [ :k | ",						"\t\t| kIndex |",						"\t\tkIndex := k value.",						"\t\t(table at: kIndex)",						"\t\t\tdecrementCountIfZero: [ f := kIndex ~~> f ]",						"\t\t\tforTopologicalSortAlgorithm: self ] ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 54420791,					"argumentNames" : [						"aStream",						"qlink",						"table"					]				}			}		},		"testTopologicalSortOnCycleDo1" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo1",						"",						"\t\"This test stress four small cycles detection.\"",						"",						"\t| cycleBlock |",						"\tcycleBlock := [ :sequence :cycle | sequence , cycle ].",						"\tself",						"\t\tassert: ({ #a }",						"\t\t\t\t topologicalSortByAssociations: { (1 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#a.",						"\t\t\t\t#a.",						"\t\t\t\t(1 -> 1) }.",						"\tself",						"\t\tassert: ({ #a. #b }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t#a.",						"\t\t\t\t(1 -> 2).",						"\t\t\t\t(2 -> 1) }.",						"\tself",						"\t\tassert: ({ #a. #b. #c }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t\t (3 -> 1) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t#c.",						"\t\t\t\t#a.",						"\t\t\t\t(1 -> 2).",						"\t\t\t\t(3 -> 1).",						"\t\t\t\t(2 -> 3) }.",						"\tself",						"\t\tassert: ({ #a. #b. #c. #d. #e }",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (5 -> 1).",						"\t\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t\t (3 -> 4) }",						"\t\t\t\t onCycleDo: cycleBlock)",						"\t\tequals: { ",						"\t\t\t\t#c.",						"\t\t\t\t#e.",						"\t\t\t\t#a.",						"\t\t\t\t#b.",						"\t\t\t\t#c.",						"\t\t\t\t(3 -> 5).",						"\t\t\t\t(2 -> 3).",						"\t\t\t\t(1 -> 2).",						"\t\t\t\t(5 -> 1) }"					],					"body" : [						"| cycleBlock |",						"cycleBlock := [ :sequence :cycle | sequence , cycle ].",						"self",						"\tassert: ({ #a }",						"\t\t\t topologicalSortByAssociations: { (1 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#a.",						"\t\t\t#a.",						"\t\t\t(1 -> 1) }.",						"self",						"\tassert: ({ #a. #b }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t#a.",						"\t\t\t(1 -> 2).",						"\t\t\t(2 -> 1) }.",						"self",						"\tassert: ({ #a. #b. #c }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t (3 -> 1) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t#c.",						"\t\t\t#a.",						"\t\t\t(1 -> 2).",						"\t\t\t(3 -> 1).",						"\t\t\t(2 -> 3) }.",						"self",						"\tassert: ({ #a. #b. #c. #d. #e }",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (5 -> 1).",						"\t\t\t\t\t (1 -> 2).",						"\t\t\t\t\t (2 -> 3).",						"\t\t\t\t\t (3 -> 5).",						"\t\t\t\t\t (3 -> 4) }",						"\t\t\t onCycleDo: cycleBlock)",						"\tequals: { ",						"\t\t\t#c.",						"\t\t\t#e.",						"\t\t\t#a.",						"\t\t\t#b.",						"\t\t\t#c.",						"\t\t\t(3 -> 5).",						"\t\t\t(2 -> 3).",						"\t\t\t(1 -> 2).",						"\t\t\t(5 -> 1) }"					],					"isTestMethod" : true,					"category" : "*Containers-Links-Tests",					"comment" : [						"This test stress four small cycles detection."					],					"hash" : 5438613,					"argumentNames" : [ ]				}			}		},		"value:onCycleDo:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"SequenceableCollection>>#topologicalSortByAssociations:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"value: aBlock onCycleDo: cycleBlock",						"",						"\t| table sort qlink |",						"\ttable := self makeValueLinksTable.",						"",						"\t\"T1: initialize. T4: scan for zeros.\"",						"\tqlink := self",						"\t\t         initializeValueLinksTable: table;",						"\t\t         sinksOfValueLinksTable: table.",						"",						"\tsort := Array streamContents: [ :aStream | ",						"\t\t        self",						"\t\t\t        sortOn: aStream",						"\t\t\t        sinksValueLink: qlink",						"\t\t\t        valueLinksTable: table ].",						"",						"\t^ sort size < size",						"\t\t  ifTrue: [ self handleCycleInValueLinksTable: table do: cycleBlock ]",						"\t\t  ifFalse: [ aBlock value: sort ]"					],					"body" : [						"| table sort qlink |",						"table := self makeValueLinksTable.",						"",						"\"T1: initialize. T4: scan for zeros.\"",						"qlink := self",						"\t         initializeValueLinksTable: table;",						"\t         sinksOfValueLinksTable: table.",						"",						"sort := Array streamContents: [ :aStream | ",						"\t        self",						"\t\t        sortOn: aStream",						"\t\t        sinksValueLink: qlink",						"\t\t        valueLinksTable: table ].",						"",						"^ sort size < size",						"\t  ifTrue: [ self handleCycleInValueLinksTable: table do: cycleBlock ]",						"\t  ifFalse: [ aBlock value: sort ]"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 37907399,					"argumentNames" : [						"aBlock",						"cycleBlock"					]				}			}		},		"topologicalSortByAssociations:acyclicDo:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"CollectionTest>>#testTopologicalSortOnCycleDo3"			],			"implementors" : {				"SequenceableCollection" : {					"sourceCode" : [						"topologicalSortByAssociations: aRelation acyclicDo: aBlock",						"",						"\t| ordering edges |",						"\tedges := Array streamContents: [ :aStream | ",						"\t\t         [ ",						"\t\t         | isAcyclic |",						"\t\t         isAcyclic := true.",						"\t\t         ordering := self",						"\t\t\t                     topologicalSortByAssociations: aRelation",						"\t\t\t                     onCycleDo: [ :sequence :cycle | ",						"\t\t\t\t                     | edge |",						"\t\t\t\t                     isAcyclic := false.",						"\t\t\t\t                     edge := cycle anyOne.",						"\t\t\t\t                     aStream nextPut: edge.",						"\t\t\t\t                     aRelation remove: edge.",						"\t\t\t\t                     sequence ].",						"\t\t         isAcyclic ] whileFalse ].",						"",						"\t^ aBlock value: ordering value: edges"					],					"body" : [						"| ordering edges |",						"edges := Array streamContents: [ :aStream | ",						"\t         [ ",						"\t         | isAcyclic |",						"\t         isAcyclic := true.",						"\t         ordering := self",						"\t\t                     topologicalSortByAssociations: aRelation",						"\t\t                     onCycleDo: [ :sequence :cycle | ",						"\t\t\t                     | edge |",						"\t\t\t                     isAcyclic := false.",						"\t\t\t                     edge := cycle anyOne.",						"\t\t\t                     aStream nextPut: edge.",						"\t\t\t                     aRelation remove: edge.",						"\t\t\t                     sequence ].",						"\t         isAcyclic ] whileFalse ].",						"",						"^ aBlock value: ordering value: edges"					],					"isTestMethod" : false,					"category" : "*Containers-Links",					"comment" : [ ],					"hash" : 36255159,					"argumentNames" : [						"aRelation",						"aBlock"					]				}			}		},		"sinksOfValueLinksTable:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"sinksOfValueLinksTable: table",						"",						"\t^ (1 to: size)",						"\t\t  foldr: [ :k :aValueLink | ",						"\t\t\t  (table at: k)",						"\t\t\t\t  ifSink: [ k ~~> aValueLink ]",						"\t\t\t\t  otherwise: [ aValueLink ]",						"\t\t\t\t  forTopologicalSortAlgorithm: self ]",						"\t\t  init: nil"					],					"body" : [						"^ (1 to: size)",						"\t  foldr: [ :k :aValueLink | ",						"\t\t  (table at: k)",						"\t\t\t  ifSink: [ k ~~> aValueLink ]",						"\t\t\t  otherwise: [ aValueLink ]",						"\t\t\t  forTopologicalSortAlgorithm: self ]",						"\t  init: nil"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 20078809,					"argumentNames" : [						"table"					]				}			}		},		"anyAssociation" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"DictionaryTest>>#testAnyAssociation",				"TopologicalSortAlgorithm>>#handleCycleInValueLinksTable:do:"			],			"implementors" : {				"Dictionary" : {					"sourceCode" : [						"anyAssociation",						"",						"\t\"I mimic the message `Collection>>#anyone` with respect to associations that I collect.\"",						"",						"\tself",						"\t\temptyCheck;",						"\t\tassociationsDo: [ :assoc | ^ assoc ]"					],					"body" : [						"self",						"\temptyCheck;",						"\tassociationsDo: [ :assoc | ^ assoc ]"					],					"isTestMethod" : false,					"category" : "*Containers-Essentials",					"comment" : [						"I mimic the message `Collection>>#anyone` with respect to associations that I collect."					],					"hash" : 1597219,					"argumentNames" : [ ]				}			}		},		"testAnyAssociation" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"DictionaryTest" : {					"sourceCode" : [						"testAnyAssociation",						"",						"\tself",						"\t\tshould: [ Dictionary new anyAssociation ]",						"\t\traise: CollectionIsEmpty.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t anyAssociation)",						"\t\tequals: 0 -> 1.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t at: 1 put: 2;",						"\t\t\t\t anyAssociation)",						"\t\tequals: 0 -> 1.",						"",						"\tself",						"\t\tassert: (Dictionary new",						"\t\t\t\t at: 0 put: 1;",						"\t\t\t\t at: 1 put: 2;",						"\t\t\t\t select: #even) anyAssociation",						"\t\tequals: 1 -> 2"					],					"body" : [						"self",						"\tshould: [ Dictionary new anyAssociation ]",						"\traise: CollectionIsEmpty.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t anyAssociation)",						"\tequals: 0 -> 1.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t at: 1 put: 2;",						"\t\t\t anyAssociation)",						"\tequals: 0 -> 1.",						"",						"self",						"\tassert: (Dictionary new",						"\t\t\t at: 0 put: 1;",						"\t\t\t at: 1 put: 2;",						"\t\t\t select: #even) anyAssociation",						"\tequals: 1 -> 2"					],					"isTestMethod" : true,					"category" : "*Containers-Essentials-Tests",					"comment" : [ ],					"hash" : 5188528,					"argumentNames" : [ ]				}			}		},		"ifSink:otherwise:forTopologicalSortAlgorithm:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#sinksOfValueLinksTable:"			],			"implementors" : {				"Association" : {					"sourceCode" : [						"ifSink: sBlock otherwise: oBlock forTopologicalSortAlgorithm: aTSA",						"",						"\t^ key ifZero: sBlock ifNotZero: oBlock"					],					"body" : [						"^ key ifZero: sBlock ifNotZero: oBlock"					],					"isTestMethod" : false,					"category" : "*Containers-Links",					"comment" : [ ],					"hash" : 52703686,					"argumentNames" : [						"sBlock",						"oBlock",						"aTSA"					]				}			}		},		"handleCycleInValueLinksTable:do:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#value:onCycleDo:"			],			"implementors" : {				"TopologicalSortAlgorithm" : {					"sourceCode" : [						"handleCycleInValueLinksTable: table do: cycleBlock",						"",						"\t| kk cycle qlink |",						"\t\"T9\"",						"\tqlink := Dictionary new.",						"\t1 to: size do: [ :k | ",						"\t\t| assoc p |",						"\t\tassoc := table at: k.",						"\t\tp := assoc value yourself: [ assoc value: 0 ].",						"",						"\t\t\"T10\"",						"\t\tp do: [ :each | qlink at: each value put: k ] ].",						"",						"\t\"T11\"",						"\tkk := qlink anyAssociation key.",						"",						"\t\"T12\"",						"\t[ ",						"\t(table at: kk) value: 1.",						"\tkk := qlink at: kk.",						"\t(table at: kk) value = 0 ] whileTrue.",						"",						"\t\"T13\"",						"\tcycle := Array streamContents: [ :aStream | ",						"\t\t         [ ",						"\t\t         aStream nextPut: kk.",						"\t\t         (table at: kk) value: 0.",						"\t\t         kk := qlink at: kk.",						"\t\t         (table at: kk) value = 1 ] whileTrue.",						"\t\t         aStream nextPut: kk ].",						"",						"\t\"Invoke the given block with the detected cycle.\"",						"\t^ cycleBlock value:",						"\t\t  (cycle overlappingPairsCollect: [ :a :b | b -> a ])"					],					"body" : [						"| kk cycle qlink |",						"\"T9\"",						"qlink := Dictionary new.",						"1 to: size do: [ :k | ",						"\t| assoc p |",						"\tassoc := table at: k.",						"\tp := assoc value yourself: [ assoc value: 0 ].",						"",						"\t\"T10\"",						"\tp do: [ :each | qlink at: each value put: k ] ].",						"",						"\"T11\"",						"kk := qlink anyAssociation key.",						"",						"\"T12\"",						"[ ",						"(table at: kk) value: 1.",						"kk := qlink at: kk.",						"(table at: kk) value = 0 ] whileTrue.",						"",						"\"T13\"",						"cycle := Array streamContents: [ :aStream | ",						"\t         [ ",						"\t         aStream nextPut: kk.",						"\t         (table at: kk) value: 0.",						"\t         kk := qlink at: kk.",						"\t         (table at: kk) value = 1 ] whileTrue.",						"\t         aStream nextPut: kk ].",						"",						"\"Invoke the given block with the detected cycle.\"",						"^ cycleBlock value:",						"\t  (cycle overlappingPairsCollect: [ :a :b | b -> a ])"					],					"isTestMethod" : false,					"category" : "enumerating",					"comment" : [ ],					"hash" : 38955116,					"argumentNames" : [						"table",						"cycleBlock"					]				}			}		},		"testTopologicalSortOnCycleDo3" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo3",						"",						"\t\"This test case shows how to iteratively removing edges",						"\t belonging to a cycle to yield an acyclic relation.\"",						"",						"\t| aRelation m |",						"\tm := 100.",						"\taRelation := self randomRelationOfSize: 1000 max: m.",						"",						"\t(1 to: m)",						"\t\ttopologicalSortByAssociations: aRelation",						"\t\tacyclicDo: [ :ordering :edges | ",						"\t\t\tself",						"\t\t\t\tassert: ordering",						"\t\t\t\tequals:",						"\t\t\t\t\t#( 64 78 75 80 84 95 70 71 85 99 62 97 73 88 90 82 60 92 81 83 77",						"\t\t\t\t\t   93 59 96 98 89 91 69 67 74 86 7 48 100 55 39 68 65 44 20 87 66",						"\t\t\t\t\t   58 35 41 46 32 76 37 43 94 40 57 72 16 33 54 47 1 2 13 21 38",						"\t\t\t\t\t   30 19 50 6 29 4 14 52 9 11 42 10 22 61 18 12 24 25 34 27 28 31",						"\t\t\t\t\t   45 17 3 79 36 63 8 56 49 51 15 26 23 53 5 ).",						"",						"\t\t\tself assert_testTopologicalSortOnCycleDo3_edgesEqualsTo: edges ]"					],					"body" : [						"| aRelation m |",						"m := 100.",						"aRelation := self randomRelationOfSize: 1000 max: m.",						"",						"(1 to: m)",						"\ttopologicalSortByAssociations: aRelation",						"\tacyclicDo: [ :ordering :edges | ",						"\t\tself",						"\t\t\tassert: ordering",						"\t\t\tequals:",						"\t\t\t\t#( 64 78 75 80 84 95 70 71 85 99 62 97 73 88 90 82 60 92 81 83 77",						"\t\t\t\t   93 59 96 98 89 91 69 67 74 86 7 48 100 55 39 68 65 44 20 87 66",						"\t\t\t\t   58 35 41 46 32 76 37 43 94 40 57 72 16 33 54 47 1 2 13 21 38 30",						"\t\t\t\t   19 50 6 29 4 14 52 9 11 42 10 22 61 18 12 24 25 34 27 28 31 45",						"\t\t\t\t   17 3 79 36 63 8 56 49 51 15 26 23 53 5 ).",						"",						"\t\tself assert_testTopologicalSortOnCycleDo3_edgesEqualsTo: edges ]"					],					"isTestMethod" : true,					"category" : "*Containers-Links-Tests",					"comment" : [						"This test case shows how to iteratively removing edges",						"\t belonging to a cycle to yield an acyclic relation."					],					"hash" : 5699826,					"argumentNames" : [ ]				}			}		},		"testTopologicalSortOnCycleDo" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"CollectionTest" : {					"sourceCode" : [						"testTopologicalSortOnCycleDo",						"",						"\t\"The following test is kept from TAOCP by Donald Knuth, Volume 1 page 272.\"",						"",						"\tself",						"\t\tassert: ((1 to: 9)",						"\t\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t\t (9 -> 2).",						"\t\t\t\t\t\t (3 -> 7).",						"\t\t\t\t\t\t (7 -> 5).",						"\t\t\t\t\t\t (5 -> 8).",						"\t\t\t\t\t\t (8 -> 6).",						"\t\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t\t (1 -> 3).",						"\t\t\t\t\t\t (7 -> 4).",						"\t\t\t\t\t\t (9 -> 5).",						"\t\t\t\t\t\t (2 -> 8) }",						"\t\t\t\t onCycleDo: [ Error signal ])",						"\t\tequals: #( 1 3 7 4 9 2 5 8 6 )"					],					"body" : [						"self",						"\tassert: ((1 to: 9)",						"\t\t\t topologicalSortByAssociations: { ",						"\t\t\t\t\t (9 -> 2).",						"\t\t\t\t\t (3 -> 7).",						"\t\t\t\t\t (7 -> 5).",						"\t\t\t\t\t (5 -> 8).",						"\t\t\t\t\t (8 -> 6).",						"\t\t\t\t\t (4 -> 6).",						"\t\t\t\t\t (1 -> 3).",						"\t\t\t\t\t (7 -> 4).",						"\t\t\t\t\t (9 -> 5).",						"\t\t\t\t\t (2 -> 8) }",						"\t\t\t onCycleDo: [ Error signal ])",						"\tequals: #( 1 3 7 4 9 2 5 8 6 )"					],					"isTestMethod" : true,					"category" : "*Containers-Links-Tests",					"comment" : [						"The following test is kept from TAOCP by Donald Knuth, Volume 1 page 272."					],					"hash" : 5175837,					"argumentNames" : [ ]				}			}		},		"decrementCountIfZero:forTopologicalSortAlgorithm:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc",				"TopologicalSortAlgorithm>>#sortOn:sinksValueLink:valueLinksTable:"			],			"implementors" : {				"Association" : {					"sourceCode" : [						"decrementCountIfZero: zBlock forTopologicalSortAlgorithm: aTSA",						"",						"\t^ (key := key - 1) ifZero: zBlock"					],					"body" : [						"^ (key := key - 1) ifZero: zBlock"					],					"isTestMethod" : false,					"category" : "*Containers-Links",					"comment" : [ ],					"hash" : 35664669,					"argumentNames" : [						"zBlock",						"aTSA"					]				}			}		},		"testYourselfBlock" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptValueLinkMessagesForDoc",				"BaselineOfBookletDSst>>#scriptTopologicalSortMessagesForDoc"			],			"implementors" : {				"ObjectTest" : {					"sourceCode" : [						"testYourselfBlock",						"",						"\t| var |",						"\tself",						"\t\tassert: (3 yourself: [ 3 + 4 ]) equals: 3;",						"\t\tassert: (3 + 4 yourself: [ :seven | seven + 5 ]) equals: 7.",						"",						"\tvar := 7.",						"\tself",						"\t\tassert: (var yourself: [ var := var + 1 ]) equals: 7;",						"\t\tassert: var equals: 8"					],					"body" : [						"| var |",						"self",						"\tassert: (3 yourself: [ 3 + 4 ]) equals: 3;",						"\tassert: (3 + 4 yourself: [ :seven | seven + 5 ]) equals: 7.",						"",						"var := 7.",						"self",						"\tassert: (var yourself: [ var := var + 1 ]) equals: 7;",						"\tassert: var equals: 8"					],					"isTestMethod" : true,					"category" : "*Containers-Essentials-Tests",					"comment" : [ ],					"hash" : 5499091,					"argumentNames" : [ ]				}			}		}	}}