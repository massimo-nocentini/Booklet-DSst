{	"classes" : {		"MetacelloScriptEngine" : {			"hash" : 1481472,			"definition" : "Object subclass: #MetacelloScriptEngine\r\tinstanceVariableNames: 'root projectSpec options'\r\tclassVariableNames: 'DefaultRepositoryDescription DefaultVersionString'\r\tpackage: 'Metacello-Core-Scripts'",			"comment" : [				"MetacelloScriptEngine runs the execution of the script for one projectSpec"			],			"category" : "Metacello-Core-Scripts"		},		"CTSplayHeapTest" : {			"hash" : 2314240,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTSplayHeapTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-SplayHeap-Tests'",			"comment" : [				"A CTSplayHeapTest is a test class for testing the behavior of CTSplayHeap"			],			"category" : "Containers-SplayHeap-Tests"		},		"TSequencedConcatenationTest" : {			"hash" : 4353280,			"definition" : "Trait named: #TSequencedConcatenationTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TCloneTest" : {			"hash" : 4333312,			"definition" : "Trait named: #TCloneTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTLeftistHeapTest" : {			"hash" : 2316800,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTLeftistHeapTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-LeftistHeap-Tests'",			"comment" : [				"A CTLeftistHeapTest is a test class for testing the behavior of CTLeftistHeap"			],			"category" : "Containers-LeftistHeap-Tests"		},		"Collection" : {			"hash" : 850688,			"definition" : "Object subclass: #Collection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am the abstract superclass of all classes that represent a group of elements.",				"",				"To get more information you read the explanation on Pharo by Example book in the next link: [Pharo by Example - Collections](https://github.com/SquareBracketAssociates/UpdatedPharoByExample/blob/pharo5/Collections/Collections.pillar).",				"",				"Or if you want to read in PDF format, download it from [Pharo by Example](https://github.com/SquareBracketAssociates/PharoByExample80/releases/tag/continuous) and look for Chapter 13: Collections. "			],			"category" : "Collections-Abstract-Base"		},		"MCSnapshotTest" : {			"hash" : 3801344,			"definition" : "MCTestCase subclass: #MCSnapshotTest\r\tinstanceVariableNames: 'snapshot'\r\tclassVariableNames: ''\r\tpackage: 'Monticello-Tests-Snapshots'",			"comment" : [				"This class contains tests"			],			"category" : "Monticello-Tests-Snapshots"		},		"CTBinomialHeapTest" : {			"hash" : 2305280,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTBinomialHeapTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinomialHeap-Tests'",			"comment" : [				"A BinomialHeapTest is a test class for testing the behavior of BinomialHeap"			],			"category" : "Containers-BinomialHeap-Tests"		},		"MorphTreeMorphSingleSelection" : {			"hash" : 2020352,			"definition" : "MorphTreeMorphSelection subclass: #MorphTreeMorphSingleSelection\r\tinstanceVariableNames: 'selectedNodePath'\r\tclassVariableNames: ''\r\tpackage: 'Morphic-Widgets-Tree'",			"comment" : [				"Single selections in a morphic based tree"			],			"category" : "Morphic-Widgets-Tree"		},		"SpJob class" : {			"hash" : 592128,			"definition" : "SpJob class\r\tinstanceVariableNames: ''",			"comment" : [				"A Job is a task to run and potentially notified to the user.",				"It is tipically used by a `SpJobPresenter` to display its progress.",				"",				"By default, a progress state is a value between 0 and 1.",				"",				"```",				"job := self newBlock: [ :job | ",				"\tjob title: 'Let us get started'.",				"\t1 to: 10 do: [:each |",				"\t\tjob",				"\t\t\tprogress: (0.1 * each);",				"\t\t\ttitle: 'Youpi ', each printString.",				"\t\t(Delay forMilliseconds: 100) wait.",				"\t\t] ]",				"job run.",				"```",				"",				"See `SpJobPresenter` for a graphical example."			],			"category" : "Spec2-Core-Job"		},		"CTLinkedStoragePoolQueue" : {			"hash" : 2294272,			"definition" : "CTLinkedStoragePoolStack subclass: #CTLinkedStoragePoolQueue\r\tinstanceVariableNames: 'bottom'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tbottom:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"CTLeftistHeap" : {			"hash" : 2315264,			"definition" : "CTBinaryTreeAbstract subclass: #CTLeftistHeap\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-LeftistHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LeftistHeap"		},		"Collection class" : {			"hash" : 850432,			"definition" : "Collection class\r\tinstanceVariableNames: ''",			"comment" : [				"I am the abstract superclass of all classes that represent a group of elements.",				"",				"To get more information you read the explanation on Pharo by Example book in the next link: [Pharo by Example - Collections](https://github.com/SquareBracketAssociates/UpdatedPharoByExample/blob/pharo5/Collections/Collections.pillar).",				"",				"Or if you want to read in PDF format, download it from [Pharo by Example](https://github.com/SquareBracketAssociates/PharoByExample80/releases/tag/continuous) and look for Chapter 13: Collections. "			],			"category" : "Collections-Abstract-Base"		},		"MTHandlerProfiling" : {			"hash" : 2278400,			"definition" : "MTHandlerPrePostPlugging subclass: #MTHandlerProfiling\r\tinstanceVariableNames: 'tree runWithInMethod timedReturns orphans'\r\tclassVariableNames: ''\r\tpackage: 'MethodTracker'",			"comment" : [				"I am a variant that waits a delay before returning from the hook notification message."			],			"category" : "MethodTracker"		},		"ComplexTest" : {			"hash" : 2224128,			"definition" : "TestCase subclass: #ComplexTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-Essentials-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "Containers-Essentials-Tests"		},		"AbstractEnumerationVisitorTest" : {			"hash" : 4504576,			"definition" : "SingleTreeTest subclass: #AbstractEnumerationVisitorTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'FileSystem-Tests-Core-Visitors'",			"comment" : [				"SUnit tests for AbstractEnumerationVisitor"			],			"category" : "FileSystem-Tests-Core-Visitors"		},		"UUIDPrimitivesTest" : {			"hash" : 4298496,			"definition" : "TestCase subclass: #UUIDPrimitivesTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Network-Tests-UUID'",			"comment" : [				"SUnit tests for UUIDPrimitives "			],			"category" : "Network-Tests-UUID"		},		"Srfi41Stream class" : {			"hash" : 8132096,			"definition" : "Srfi41Stream class\r\tinstanceVariableNames: ''",			"comment" : [				"Title",				"Streams",				"Author",				"Philip L. Bewig",				"Status",				"This SRFI is currently in ``final'' status. To see an explanation of each status that a SRFI can hold, see here. To comment on this SRFI, please mailto:srfi minus 41 at srfi dot schemers dot org. See instructions here to subscribe to the list. You can access the discussion via the archive of the mailing list. You can access post-finalization messages via the archive of the mailing list.",				"Received: 2007/10/24",				"Revised: 2007/11/14",				"Revised: 2007/11/14",				"Revised: 2007/12/17",				"Final: 2008/01/24",				"Post-finalization improvement to stream-constant: 2015/11/2",				"Draft: 2007/10/21 - 2007/12/22",				"Abstract",				"Streams, sometimes called lazy lists, are a sequential data structure containing elements computed only on demand. A stream is either null or is a pair with a stream in its cdr. Since elements of a stream are computed only when accessed, streams can be infinite. Once computed, the value of a stream element is cached in case it is needed again.",				"",				"Streams without memoization were first described by Peter Landin in 1965. Memoization became accepted as an essential feature of streams about a decade later. Today, streams are the signature data type of functional programming languages such as Haskell.",				"",				"This Scheme Request for Implementation describes two libraries for operating on streams: a canonical set of stream primitives and a set of procedures and syntax derived from those primitives that permits convenient expression of stream operations. They rely on facilities provided by R6RS, including libraries, records, and error reporting. To load both stream libraries, say:",				"",				"(import (streams))",				"",				"Rationale",				"Harold Abelson and Gerald Jay Sussman discuss streams at length, giving a strong justification for their use. The streams they provide are represented as a cons pair with a promise to return a stream in its cdr; for instance, a stream with elements the first three counting numbers is represented conceptually as (cons 1 (delay (cons 2 (delay (cons 3 (delay '())))))). Philip Wadler, Walid Taha and David MacQueen describe such streams as odd because, regardless of their length, the parity of the number of constructors (delay, cons, '()) in the stream is odd.",				"",				"The streams provided here differ from those of Abelson and Sussman, being represented as promises that contain a cons pair with a stream in its cdr; for instance, the stream with elements the first three counting numbers is represented conceptually as (delay (cons 1 (delay (cons 2 (delay (cons 3 (delay '()))))))); this is an even stream because the parity of the number of constructors in the stream is even.",				"",				"Even streams are more complex than odd streams in both definition and usage, but they offer a strong benefit: they fix the off-by-one error of odd streams. Wadler, Taha and MacQueen show, for instance, that an expression like (stream->list 4 (stream-map / (stream-from 4 -1))) evaluates to (1/4 1/3 1/2 1) using even streams but fails with a divide-by-zero error using odd streams, because the next element in the stream, which will be 1/0, is evaluated before it is accessed. This extra bit of laziness is not just an interesting oddity; it is vitally critical in many circumstances, as will become apparent below.",				"",				"When used effectively, the primary benefit of streams is improved modularity. Consider a process that takes a sequence of items, operating on each in turn. If the operation is complex, it may be useful to split it into two or more procedures in which the partially-processed sequence is an intermediate result. If that sequence is stored as a list, the entire intermediate result must reside in memory all at once; however, if the intermediate result is stored as a stream, it can be generated piecemeal, using only as much memory as required by a single item. This leads to a programming style that uses many small operators, each operating on the sequence of items as a whole, similar to a pipeline of unix commands.",				"",				"In addition to improved modularity, streams permit a clear exposition of backtracking algorithms using the “stream of successes” technique, and they can be used to model generators and co-routines. The implicit memoization of streams makes them useful for building persistent data structures, and the laziness of streams permits some multi-pass algorithms to be executed in a single pass. Savvy programmers use streams to enhance their programs in countless ways.",				"",				"There is an obvious space/time trade-off between lists and streams; lists take more space, but streams take more time (to see why, look at all the type conversions in the implementation of the stream primitives). Streams are appropriate when the sequence is truly infinite, when the space savings are needed, or when they offer a clearer exposition of the algorithms that operate on the sequence.",				"",				"Specification",				"The (streams primitive) library",				"The (streams primitive) library provides two mutually-recursive abstract data types: An object of the stream abstract data type is a promise that, when forced, is either stream-null or is an object of type stream-pair. An object of the stream-pair abstract data type contains a stream-car and a stream-cdr, which must be a stream. The essential feature of streams is the systematic suspensions of the recursive promises between the two data types.",				"",				"α stream",				"  :: (promise stream-null)",				"  |  (promise (α stream-pair))",				"α stream-pair",				"  :: (promise α) × (promise (α stream))",				"The object stored in the stream-car of a stream-pair is a promise that is forced the first time the stream-car is accessed; its value is cached in case it is needed again. The object may have any type, and different stream elements may have different types. If the stream-car is never accessed, the object stored there is never evaluated. Likewise, the stream-cdr is a promise to return a stream, and is only forced on demand.",				"",				"This library provides eight operators: constructors for stream-null and stream-pairs, type recognizers for streams and the two kinds of streams, accessors for both fields of a stream-pair, and a lambda that creates procedures that return streams.",				"",				"constructor: stream-null",				"Stream-null is a promise that, when forced, is a single object, distinguishable from all other objects, that represents the null stream. Stream-null is immutable and unique.",				"",				"constructor: (stream-cons object stream)",				"Stream-cons is a macro that accepts an object and a stream and creates a newly-allocated stream containing a promise that, when forced, is a stream-pair with the object in its stream-car and the stream in its stream-cdr. Stream-cons must be syntactic, not procedural, because neither object nor stream is evaluated when stream-cons is called. Since stream is not evaluated, when the stream-pair is created, it is not an error to call stream-cons with a stream that is not of type stream; however, doing so will cause an error later when the stream-cdr of the stream-pair is accessed. Once created, a stream-pair is immutable; there is no stream-set-car! or stream-set-cdr! that modifies an existing stream-pair. There is no dotted-pair or improper stream as with lists.",				"",				"recognizer: (stream? object)",				"Stream? is a procedure that takes an object and returns #t if the object is a stream and #f otherwise. If object is a stream, stream? does not force its promise. If (stream? obj) is #t, then one of (stream-null? obj) and (stream-pair? obj) will be #t and the other will be #f; if (stream? obj) is #f, both (stream-null? obj) and (stream-pair? obj) will be #f.",				"",				"recognizer: (stream-null? object)",				"Stream-null? is a procedure that takes an object and returns #t if the object is the distinguished null stream and #f otherwise. If object is a stream, stream-null? must force its promise in order to distinguish stream-null from stream-pair.",				"",				"recognizer: (stream-pair? object)",				"Stream-pair? is a procedure that takes an object and returns #t if the object is a stream-pair constructed by stream-cons and #f otherwise. If object is a stream, stream-pair? must force its promise in order to distinguish stream-null from stream-pair.",				"",				"accessor: (stream-car stream)",				"Stream-car is a procedure that takes a stream and returns the object stored in the stream-car of the stream. Stream-car signals an error if the object passed to it is not a stream-pair. Calling stream-car causes the object stored there to be evaluated if it has not yet been; the object’s value is cached in case it is needed again.",				"",				"accessor: (stream-cdr stream)",				"Stream-cdr is a procedure that takes a stream and returns the stream stored in the stream-cdr of the stream. Stream-cdr signals an error if the object passed to it is not a stream-pair. Calling stream-cdr does not force the promise containing the stream stored in the stream-cdr of the stream.",				"",				"lambda: (stream-lambda args body)",				"Stream-lambda creates a procedure that returns a promise to evaluate the body of the procedure. The last body expression to be evaluated must yield a stream. As with normal lambda, args may be a single variable name, in which case all the formal arguments are collected into a single list, or a list of variable names, which may be null if there are no arguments, proper if there are an exact number of arguments, or dotted if a fixed number of arguments is to be followed by zero or more arguments collected into a list. Body must contain at least one expression, and may contain internal definitions preceding any expressions to be evaluated.",				"",				"",				"(define strm123",				"  (stream-cons 1",				"    (stream-cons 2",				"      (stream-cons 3",				"        stream-null))))",				"(stream-car strm123) ⇒ 1",				"",				"(stream-car (stream-cdr strm123) ⇒ 2",				"",				"",				"(stream-pair?",				"  (stream-cdr",				"    (stream-cons (/ 1 0) stream-null))) ⇒ #f",				"(stream? (list 1 2 3)) ⇒ #f",				"",				"",				"(define iter",				"  (stream-lambda (f x)",				"    (stream-cons x (iter f (f x)))))",				"(define nats (iter (lambda (x) (+ x 1)) 0))",				"",				"(stream-car (stream-cdr nats)) ⇒ 1",				"",				"",				"(define stream-add",				"  (stream-lambda (s1 s2)",				"    (stream-cons",				"      (+ (stream-car s1) (stream-car s2))",				"      (stream-add (stream-cdr s1)",				"                  (stream-cdr s2)))))",				"(define evens (stream-add nats nats))",				"",				"(stream-car evens) ⇒ 0",				"",				"(stream-car (stream-cdr evens)) ⇒ 2",				"",				"(stream-car (stream-cdr (stream-cdr evens))) ⇒ 4",				"",				"The (streams derived) library",				"The (streams derived) library provides useful procedures and syntax that depend on the primitives defined above. In the operator templates given below, an ellipsis ... indicates zero or more repetitions of the preceding subexpression and square brackets […] indicate optional elements. In the type annotations given below, square brackets […] refer to lists, curly braces {…} refer to streams, and nat refers to exact non-negative integers.",				"",				"syntax: (define-stream (name args) body)",				"Define-stream creates a procedure that returns a stream, and may appear anywhere a normal define may appear, including as an internal definition, and may have internal definitions of its own, including other define-streams. The defined procedure takes arguments in the same way as stream-lambda. Define-stream is syntactic sugar on stream-lambda; see also stream-let, which is also a sugaring of stream-lambda.",				"",				"A simple version of stream-map that takes only a single input stream calls itself recursively:",				"",				"",				"(define-stream (stream-map proc strm)",				"  (if (stream-null? strm)",				"      stream-null",				"      (stream-cons",				"        (proc (stream-car strm))",				"        (stream-map proc (stream-cdr strm))))))",				"procedure: (list->stream list-of-objects)",				"[α] → {α}",				"List->stream takes a list of objects and returns a newly-allocated stream containing in its elements the objects in the list. Since the objects are given in a list, they are evaluated when list->stream is called, before the stream is created. If the list of objects is null, as in (list->stream '()), the null stream is returned. See also stream.",				"",				"(define strm123 (list->stream '(1 2 3)))",				"",				"",				"; fails with divide-by-zero error",				"(define s (list->stream (list 1 (/ 1 0) -1)))",				"procedure: (port->stream [port])",				"port → {char}",				"Port->stream takes a port and returns a newly-allocated stream containing in its elements the characters on the port. If port is not given it defaults to the current input port. The returned stream has finite length and is terminated by stream-null.",				"",				"It looks like one use of port->stream would be this:",				"",				"",				"(define s ;wrong!",				"  (with-input-from-file filename",				"    (lambda () (port->stream))))",				"But that fails, because with-input-from-file is eager, and closes the input port prematurely, before the first character is read. To read a file into a stream, say:",				"",				"",				"(define-stream (file->stream filename)",				"  (let ((p (open-input-file filename)))",				"    (stream-let loop ((c (read-char p)))",				"      (if (eof-object? c)",				"          (begin (close-input-port p)",				"                 stream-null)",				"          (stream-cons c",				"            (loop (read-char p)))))))",				"syntax: (stream object ...)",				"Stream is syntax that takes zero or more objects and creates a newly-allocated stream containing in its elements the objects, in order. Since stream is syntactic, the objects are evaluated when they are accessed, not when the stream is created. If no objects are given, as in (stream), the null stream is returned. See also list->stream.",				"",				"(define strm123 (stream 1 2 3))",				"",				"",				"; (/ 1 0) not evaluated when stream is created",				"(define s (stream 1 (/ 1 0) -1))",				"procedure: (stream->list [n] stream)",				"nat × {α} → [α]",				"Stream->list takes a natural number n and a stream and returns a newly-allocated list containing in its elements the first n items in the stream. If the stream has less than n items all the items in the stream will be included in the returned list. If n is not given it defaults to infinity, which means that unless stream is finite stream->list will never return.",				"",				"",				"(stream->list 10",				"  (stream-map (lambda (x) (* x x))",				"    (stream-from 0)))",				"  ⇒ (0 1 4 9 16 25 36 49 64 81)",				"procedure: (stream-append stream ...)",				"{α} ... → {α}",				"Stream-append returns a newly-allocated stream containing in its elements those elements contained in its input streams, in order of input. If any of the input streams is infinite, no elements of any of the succeeding input streams will appear in the output stream; thus, if x is infinite, (stream-append x y) ≡ x. See also stream-concat.",				"",				"Quicksort can be used to sort a stream, using stream-append to build the output; the sort is lazy; so if only the beginning of the output stream is needed, the end of the stream is never sorted.",				"",				"",				"(define-stream (qsort lt? strm)",				"  (if (stream-null? strm)",				"      stream-null",				"      (let ((x (stream-car strm))",				"            (xs (stream-cdr strm)))",				"        (stream-append",				"          (qsort lt?",				"            (stream-filter",				"              (lambda (u) (lt? u x))",				"              xs))",				"          (stream x)",				"          (qsort lt?",				"            (stream-filter",				"              (lambda (u) (not (lt? u x)))",				"              xs))))))",				"Note also that, when used in tail position as in qsort, stream-append does not suffer the poor performance of append on lists. The list version of append requires re-traversal of all its list arguments except the last each time it is called. But stream-append is different. Each recursive call to stream-append is suspended; when it is later forced, the preceding elements of the result have already been traversed, so tail-recursive loops that produce streams are efficient even when each element is appended to the end of the result stream. This also implies that during traversal of the result only one promise needs to be kept in memory at a time.",				"",				"procedure: (stream-concat stream)",				"{{α}} ... → {α}",				"Stream-concat takes a stream consisting of one or more streams and returns a newly-allocated stream containing all the elements of the input streams. If any of the streams in the input stream is infinite, any remaining streams in the input stream will never appear in the output stream. See also stream-append.",				"",				"",				"(stream->list",				"  (stream-concat",				"    (stream",				"      (stream 1 2) (stream) (stream 3 2 1))))",				"  ⇒ (1 2 3 2 1)",				"The permutations of a finite stream can be determined by interleaving each element of the stream in all possible positions within each permutation of the other elements of the stream. Interleave returns a stream of streams with x inserted in each possible position of yy:",				"",				"",				"(define-stream (interleave x yy)",				"  (stream-match yy",				"    (() (stream (stream x)))",				"    ((y . ys)",				"      (stream-append",				"        (stream (stream-cons x yy))",				"        (stream-map",				"          (lambda (z) (stream-cons y z))",				"          (interleave x ys))))))",				"",				"(define-stream (perms xs)",				"  (if (stream-null? xs)",				"      (stream (stream))",				"      (stream-concat",				"        (stream-map",				"          (lambda (ys)",				"            (interleave (stream-car xs) ys))",				"          (perms (stream-cdr xs))))))",				"procedure: (stream-constant object ...)",				"α ... → {α}",				"Stream-constant takes one or more objects and returns a newly-allocated stream containing in its elements the objects, repeating the objects in succession forever.",				"",				"(stream-constant 1) ⇒ 1 1 1 ...",				"",				"(stream-constant #t #f) ⇒ #t #f #t #f #t #f ...",				"",				"procedure: (stream-drop n stream) procedure",				"nat × {α} → {α}",				"Stream-drop returns the suffix of the input stream that starts at the next element after the first n elements. The output stream shares structure with the input stream; thus, promises forced in one instance of the stream are also forced in the other instance of the stream. If the input stream has less than n elements, stream-drop returns the null stream. See also stream-take.",				"",				"",				"(define (stream-split n strm)",				"  (values (stream-take n strm)",				"          (stream-drop n strm)))",				"procedure: (stream-drop-while pred? stream)",				"(α → boolean) × {α} → {α}",				"Stream-drop-while returns the suffix of the input stream that starts at the first element x for which (pred? x) is #f. The output stream shares structure with the input stream. See also stream-take-while.",				"",				"Stream-unique creates a new stream that retains only the first of any sub-sequences of repeated elements.",				"",				"",				"(define-stream (stream-unique eql? strm)",				"  (if (stream-null? strm)",				"      stream-null",				"      (stream-cons (stream-car strm)",				"        (stream-unique eql?",				"          (stream-drop-while",				"            (lambda (x)",				"              (eql? (stream-car strm) x))",				"            strm)))))",				"procedure: (stream-filter pred? stream)",				"(α → boolean) × {α} → {α}",				"Stream-filter returns a newly-allocated stream that contains only those elements x of the input stream for which (pred? x) is non-#f.",				"",				"",				"(stream-filter odd? (stream-from 0))",				"   ⇒ 1 3 5 7 9 ...",				"procedure: (stream-fold proc base stream)",				"(α × β → α) × α × {β} → α",				"Stream-fold applies a binary procedure to base and the first element of stream to compute a new base, then applies the procedure to the new base and the next element of stream to compute a succeeding base, and so on, accumulating a value that is finally returned as the value of stream-fold when the end of the stream is reached. Stream must be finite, or stream-fold will enter an infinite loop. See also stream-scan, which is similar to stream-fold, but useful for infinite streams. For readers familiar with other functional languages, this is a left-fold; there is no corresponding right-fold, since right-fold relies on finite streams that are fully-evaluated, at which time they may as well be converted to a list.",				"",				"Stream-fold is often used to summarize a stream in a single value, for instance, to compute the maximum element of a stream.",				"",				"",				"(define (stream-maximum lt? strm)",				"  (stream-fold",				"    (lambda (x y) (if (lt? x y) y x))",				"    (stream-car strm)",				"    (stream-cdr strm)))",				"Sometimes, it is useful to have stream-fold defined only on non-null streams:",				"",				"",				"(define (stream-fold-one proc strm)",				"  (stream-fold proc",				"    (stream-car strm)",				"    (stream-cdr strm)))",				"Stream-minimum can then be defined as:",				"",				"",				"(define (stream-minimum lt? strm)",				"  (stream-fold-one",				"    (lambda (x y) (if (lt? x y) x y))",				"    strm))",				"Stream-fold can also be used to build a stream:",				"",				"",				"(define-stream (isort lt? strm)",				"    (define-stream (insert strm x)",				"      (stream-match strm",				"        (() (stream x))",				"        ((y . ys)",				"          (if (lt? y x)",				"              (stream-cons y (insert ys x))",				"              (stream-cons x strm)))))",				"    (stream-fold insert stream-null strm))",				"procedure: (stream-for-each proc stream ...)",				"(α × β × ...) × {α} × {β} ...",				"Stream-for-each applies a procedure element-wise to corresponding elements of the input streams for its side-effects; it returns nothing. Stream-for-each stops as soon as any of its input streams is exhausted.",				"",				"The following procedure displays the contents of a file:",				"",				"",				"(define (display-file filename)",				"  (stream-for-each display",				"    (file->stream filename)))",				"procedure: (stream-from first [step])",				"number × number → {number}",				"Stream-from creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. If step is not given it defaults to 1. First and step may be of any numeric type. Stream-from is frequently useful as a generator in stream-of expressions. See also stream-range for a similar procedure that creates finite streams.",				"",				"Stream-from could be implemented as (stream-iterate (lambda (x) (+ x step)) first).",				"",				"(define nats (stream-from 0)) ⇒ 0 1 2 ...",				"",				"(define odds (stream-from 1 2)) ⇒ 1 3 5 ...",				"",				"procedure: (stream-iterate proc base)",				"(α → α) × α → {α}",				"Stream-iterate creates a newly-allocated stream containing base in its first element and applies proc to each element in turn to determine the succeeding element. See also stream-unfold and stream-unfolds.",				"",				"",				"(stream-iterate (lambda (x) (+ x 1)) 0)",				"  ⇒ 0 1 2 3 4 ...",				"",				"(stream-iterate (lambda (x) (* x 2)) 1)",				"  ⇒ 1 2 4 8 16 ...",				"Given a seed between 0 and 232, exclusive, the following expression creates a stream of pseudo-random integers between 0 and 232, exclusive, beginning with seed, using the method described by Stephen Park and Keith Miller:",				"",				"",				"(stream-iterate",				"  (lambda (x) (modulo (* x 16807) 2147483647))",				"  seed)",				"Successive values of the continued fraction shown below approach the value of the “golden ratio” φ ≈ 1.618:",				"",				"Continued fraction",				"",				"The fractions can be calculated by the stream",				"",				"(stream-iterate (lambda (x) (+ 1 (/ x))) 1)",				"",				"procedure: (stream-length stream)",				"{α} → nat",				"Stream-length takes an input stream and returns the number of elements in the stream; it does not evaluate its elements. Stream-length may only be used on finite streams; it enters an infinite loop with infinite streams.",				"",				"(stream-length strm123) ⇒ 3",				"",				"syntax: (stream-let tag ((var expr) ...) body)",				"Stream-let creates a local scope that binds each variable to the value of its corresponding expression. It additionally binds tag to a procedure which takes the bound variables as arguments and body as its defining expressions, binding the tag with stream-lambda. Tag is in scope within body, and may be called recursively. When the expanded expression defined by the stream-let is evaluated, stream-let evaluates the expressions in its body in an environment containing the newly-bound variables, returning the value of the last expression evaluated, which must yield a stream.",				"",				"Stream-let provides syntactic sugar on stream-lambda, in the same manner as normal let provides syntactic sugar on normal lambda. However, unlike normal let, the tag is required, not optional, because unnamed stream-let is meaningless.",				"",				"Stream-member returns the first stream-pair of the input strm with a stream-car x that satisfies (eql? obj x), or the null stream if x is not present in strm.",				"",				"",				"(define-stream (stream-member eql? obj strm)",				"  (stream-let loop ((strm strm))",				"    (cond ((stream-null? strm) strm)",				"          ((eql? obj (stream-car strm)) strm)",				"          (else (loop (stream-cdr strm))))))",				"procedure: (stream-map proc stream ...)",				"(α × β ... → ω) × {α} × {β} ... → {ω}",				"Stream-map applies a procedure element-wise to corresponding elements of the input streams, returning a newly-allocated stream containing elements that are the results of those procedure applications. The output stream has as many elements as the minimum-length input stream, and may be infinite.",				"",				"(define (square x) (* x x))",				"",				"(stream-map square (stream 9 3)) ⇒ 81 9",				"",				"",				"(define (sigma f m n)",				"  (stream-fold + 0",				"    (stream-map f (stream-range m (+ n 1)))))",				"(sigma square 1 100) ⇒ 338350",				"",				"In some functional languages, stream-map takes only a single input stream, and stream-zipwith provides a companion function that takes multiple input streams.",				"",				"syntax: (stream-match stream clause ...)",				"Stream-match provides the syntax of pattern-matching for streams. The input stream is an expression that evaluates to a stream. Clauses are of the form (pattern [fender] expr), consisting of a pattern that matches a stream of a particular shape, an optional fender that must succeed if the pattern is to match, and an expression that is evaluated if the pattern matches. There are four types of patterns:",				"",				"() — Matches the null stream.",				"(pat0 pat1 ...) — Matches a finite stream with length exactly equal to the number of pattern elements.",				"(pat0 pat1 ... . patrest) — Matches an infinite stream, or a finite stream with length at least as great as the number of pattern elements before the literal dot.",				"pat — Matches an entire stream. Should always appear last in the list of clauses; it’s not an error to appear elsewhere, but subsequent clauses could never match.",				"Each pattern element pati may be either:",				"",				"An identifier — Matches any stream element. Additionally, the value of the stream element is bound to the variable named by the identifier, which is in scope in the fender and expression of the corresponding clause. Each identifier in a single pattern must be unique.",				"A literal underscore — Matches any stream element, but creates no bindings.",				"The patterns are tested in order, left-to-right, until a matching pattern is found; if fender is present, it must evaluate as non-#f for the match to be successful. Pattern variables are bound in the corresponding fender and expression. Once the matching pattern is found, the corresponding expression is evaluated and returned as the result of the match. An error is signaled if no pattern matches the input stream.",				"",				"Stream-match is often used to distinguish null streams from non-null streams, binding head and tail:",				"",				"",				"(define (len strm)",				"  (stream-match strm",				"    (() 0)",				"    ((head . tail) (+ 1 (len tail)))))",				"Fenders can test the common case where two stream elements must be identical; the else pattern is an identifier bound to the entire stream, not a keyword as in cond.",				"",				"",				"(stream-match strm",				"  ((x y . _) (equal? x y) 'ok)",				"  (else 'error))",				"A more complex example uses two nested matchers to match two different stream arguments; (stream-merge lt? . strms) stably merges two or more streams ordered by the lt? predicate:",				"",				"",				"(define-stream (stream-merge lt? . strms)",				"  (define-stream (merge xx yy)",				"    (stream-match xx (() yy) ((x . xs)",				"      (stream-match yy (() xx) ((y . ys)",				"        (if (lt? y x)",				"            (stream-cons y (merge xx ys))",				"            (stream-cons x (merge xs yy))))))))",				"  (stream-let loop ((strms strms))",				"    (cond ((null? strms) stream-null)",				"          ((null? (cdr strms)) (car strms))",				"          (else (merge (car strms)",				"                       (apply stream-merge lt?",				"                         (cdr strms)))))))",				"syntax: (stream-of expr clause ...)",				"Stream-of provides the syntax of stream comprehensions, which generate streams by means of looping expressions. The result is a stream of objects of the type returned by expr. There are four types of clauses:",				"",				"(var in stream-expr) — Loop over the elements of stream-expr, in order from the start of the stream, binding each element of the stream in turn to var. Stream-from and stream-range are frequently useful as generators for stream-expr.",				"(var is expr) — Bind var to the value obtained by evaluating expr.",				"(pred? expr) — Include in the output stream only those elements x for which (pred? x) is non-#f.",				"The scope of variables bound in the stream comprehension is the clauses to the right of the binding clause (but not the binding clause itself) plus the result expression.",				"",				"When two or more generators are present, the loops are processed as if they are nested from left to right; that is, the rightmost generator varies fastest. A consequence of this is that only the first generator may be infinite and all subsequent generators must be finite. If no generators are present, the result of a stream comprehension is a stream containing the result expression; thus, (stream-of 1) produces a finite stream containing only the element 1.",				"",				"",				"(stream-of (* x x)",				"  (x in (stream-range 0 10))",				"  (even? x))",				"  ⇒ 0 4 16 36 64",				"",				"(stream-of (list a b)",				"  (a in (stream-range 1 4))",				"  (b in (stream-range 1 3))) ",				"  ⇒ (1 1) (1 2) (2 1) (2 2) (3 1) (3 2)",				"",				"(stream-of (list i j)",				"  (i in (stream-range 1 5))",				"  (j in (stream-range (+ i 1) 5)))",				"  ⇒ (1 2) (1 3) (1 4) (2 3) (2 4) (3 4)",				"procedure: (stream-range first past [step])",				"number × number × number → {number}",				"Stream-range creates a newly-allocated stream that contains first as its first element and increments each succeeding element by step. The stream is finite and ends before past, which is not an element of the stream. If step is not given it defaults to 1 if first is less than past and -1 otherwise. First, past and step may be of any numeric type. Stream-range is frequently useful as a generator in stream-of expressions. See also stream-from for a similar procedure that creates infinite streams.",				"",				"(stream-range 0 10) ⇒ 0 1 2 3 4 5 6 7 8 9",				"",				"(stream-range 0 10 2) → 0 2 4 6 8",				"",				"Successive elements of the stream are calculated by adding step to first, so if any of first, past or step are inexact, the length of the output stream may differ from (ceiling (- (/ (- past first) step) 1).",				"",				"procedure: (stream-ref stream n)",				"{α} × nat → α",				"Stream-ref returns the nth element of stream, counting from zero. An error is signaled if n is greater than or equal to the length of stream.",				"",				"",				"(define (fact n)",				"  (stream-ref",				"    (stream-scan * 1 (stream-from 1))",				"    n))",				"procedure: (stream-reverse stream)",				"{α} → {α}",				"Stream-reverse returns a newly-allocated stream containing the elements of the input stream but in reverse order. Stream-reverse may only be used with finite streams; it enters an infinite loop with infinite streams. Stream-reverse does not force evaluation of the elements of the stream.",				"",				"",				"> (define s (stream 1 (/ 1 0) -1))",				"> (define r (stream-reverse s))",				"> (stream-ref r 0)",				"> (stream-ref r 2)",				"1",				"> (stream-ref r 1)",				"error: division by zero",				"procedure: (stream-scan proc base stream)",				"(α × β → α) × α × {β} → {α}",				"Stream-scan accumulates the partial folds of an input stream into a newly-allocated output stream. The output stream is the base followed by (stream-fold proc base (stream-take i stream)) for each of the first i elements of stream.",				"",				"",				"(stream-scan + 0 (stream-from 1))",				"  ⇒ (stream 0 1 3 6 10 15 ...)",				"",				"(stream-scan * 1 (stream-from 1))",				"  ⇒ (stream 1 1 2 6 24 120 ...)",				"procedure: (stream-take n stream)",				"nat × {α} → {α}",				"Stream-take takes a non-negative integer n and a stream and returns a newly-allocated stream containing the first n elements of the input stream. If the input stream has less than n elements, so does the output stream. See also stream-drop.",				"",				"Mergesort splits a stream into two equal-length pieces, sorts them recursively and merges the results:",				"",				"",				"(define-stream (msort lt? strm)",				"  (let* ((n (quotient (stream-length strm) 2))",				"         (ts (stream-take n strm))",				"         (ds (stream-drop n strm)))",				"    (if (zero? n)",				"        strm",				"        (stream-merge lt?",				"          (msort < ts) (msort < ds)))))",				"procedure: (stream-take-while pred? stream)",				"(α → boolean) × {α} → {α}",				"Stream-take-while takes a predicate and a stream and returns a newly-allocated stream containing those elements x that form the maximal prefix of the input stream for which (pred? x) is non-#f. See also stream-drop-while.",				"",				"",				"(stream-car",				"  (stream-reverse",				"    (stream-take-while",				"      (lambda (x) (< x 1000))",				"        primes))) ⇒ 997",				"procedure: (stream-unfold map pred? gen base)",				"(α → β) × (α → boolean) × (α → α) × α → {β}",				"Stream-unfold is the fundamental recursive stream constructor. It constructs a stream by repeatedly applying gen to successive values of base, in the manner of stream-iterate, then applying map to each of the values so generated, appending each of the mapped values to the output stream as long as (pred? base) is non-#f. See also stream-iterate and stream-unfolds.",				"",				"The expression below creates the finite stream 0 1 4 9 16 25 36 49 64 81. Initially the base is 0, which is less than 10, so map squares the base and the mapped value becomes the first element of the output stream. Then gen increments the base by 1, so it becomes 1; this is less than 10, so map squares the new base and 1 becomes the second element of the output stream. And so on, until the base becomes 10, when pred? stops the recursion and stream-null ends the output stream.",				"",				"",				"(stream-unfold",				"  (lambda (x) (expt x 2)) ; map",				"  (lambda (x) (< x 10))   ; pred?",				"  (lambda (x) (+ x 1))    ; gen",				"  0)                      ; base",				"procedure: (stream-unfolds proc seed)",				"(α → (values α × β ...)) × α → (values {β} ...)",				"Stream-unfolds returns n newly-allocated streams containing those elements produced by successive calls to the generator proc, which takes the current seed as its argument and returns n+1 values",				"",				"(proc seed → seed result0 ... resultn-1",				"",				"where the returned seed is the input seed to the next call to the generator and resulti indicates how to produce the next element of the ith result stream:",				"",				"(value) — value is the next car of the result stream",				"#f — no value produced by this iteration of the generator proc for the result stream",				"() — the end of the result stream",				"It may require multiple calls of proc to produce the next element of any particular result stream. See also stream-iterate and stream-unfold.",				"",				"Stream-unfolds is especially useful when writing expressions that return multiple streams. For instance, (stream-partition pred? strm) is equivalent to",				"",				"",				"(values",				"  (stream-filter pred? strm)",				"  (stream-filter",				"    (lambda (x) (not (pred? x))) strm))",				"but only tests pred? once for each element of strm.",				"",				"",				"(define (stream-partition pred? strm)",				"  (stream-unfolds",				"    (lambda (s)",				"      (if (stream-null? s)",				"          (values s '() '())",				"          (let ((a (stream-car s))",				"                (d (stream-cdr s)))",				"            (if (pred? a)",				"                (values d (list a) #f)",				"                (values d #f (list a))))))",				"    strm))",				"",				"(call-with-values",				"  (lambda ()",				"    (stream-partition odd?",				"      (stream-range 1 6)))",				"  (lambda (odds evens)",				"    (list (stream->list odds)",				"          (stream->list evens))))",				"  ⇒ ((1 3 5) (2 4))",				"procedure: (stream-zip stream ...)",				"{α} × {β} × ... → {[α β ...]}",				"Stream-zip takes one or more input streams and returns a newly-allocated stream in which each element is a list (not a stream) of the corresponding elements of the input streams. The output stream is as long as the shortest input stream, if any of the input streams is finite, or is infinite if all the input streams are infinite.",				"",				"A common use of stream-zip is to add an index to a stream, as in (stream-finds eql? obj strm), which returns all the zero-based indices in strm at which obj appears; (stream-find eql? obj strm) returns the first such index, or #f if obj is not in strm.",				"",				"",				"(define-stream (stream-finds eql? obj strm)",				"  (stream-of (car x)",				"    (x in (stream-zip (stream-from 0) strm))",				"    (eql? obj (cadr x))))",				"",				"(define (stream-find eql? obj strm)",				"  (stream-car",				"    (stream-append",				"      (stream-finds eql? obj strm)",				"      (stream #f))))",				"",				"(stream-find char=? #\\l",				"  (list->stream",				"    (string->list \"hello\"))) ⇒ 2",				"",				"(stream-find char=? #\\l",				"  (list->stream",				"    (string->list \"goodbye\"))) ⇒ #f",				"Stream-find is not as inefficient as it looks; although it calls stream-finds, which finds all matching indices, the matches are computed lazily, and only the first match is needed for stream-find.",				"",				"Utilities",				"Streams, being the signature structured data type of functional programming languages, find useful expression in conjunction with higher-order functions. Some of these higher-order functions, and their relationship to streams, are described below.",				"",				"The identity and constant procedures are frequently useful as the recursive base for maps and folds; (identity obj) always returns obj, and (const obj) creates a procedure that takes any number of arguments and always returns the same obj, no matter its arguments:",				"",				"(define (identity obj) obj)",				"",				"(define (const obj) (lambda x obj))",				"",				"Many of the stream procedures take a unary predicate that accepts an element of a stream and returns a boolean. Procedure (negate pred?) takes a unary predicate and returns a new unary predicate that, when called, returns the opposite boolean value as the original predicate.",				"",				"",				"(define (negate pred?)",				"  (lambda (x) (not (pred? x))))",				"Negate is useful for procedures like stream-take-while that take a predicate, allowing them to be used in the opposite direction from which they were written; for instance, with the predicate reversed, stream-take-while becomes stream-take-until. Stream-remove is the opposite of stream-filter:",				"",				"",				"(define-stream (stream-remove pred? strm)",				"  (stream-filter (negate pred?) strm))",				"A section is a procedure which has been partially applied to some of its arguments; for instance, (double x), which returns twice its argument, is a partial application of the multiply operator to the number 2. Sections come in two kinds: left sections partially apply arguments starting from the left, and right sections partially apply arguments starting from the right. Procedure (lsec proc args ...) takes a procedure and some prefix of its arguments and returns a new procedure in which those arguments are partially applied. Procedure (rsec proc args ...) takes a procedure and some reversed suffix of its arguments and returns a new procedure in which those arguments are partially applied.",				"",				"",				"(define (lsec proc . args)",				"  (lambda x (apply proc (append args x))))",				"",				"(define (rsec proc . args)",				"  (lambda x (apply proc (reverse",				"    (append (reverse args) (reverse x))))))",				"Since most of the stream procedures take a stream as their last (right-most) argument, left sections are particularly useful in conjunction with streams.",				"",				"(define stream-sum (lsec stream-fold + 0))",				"",				"Function composition creates a new function by partially applying multiple functions, one after the other. In the simplest case there are only two functions, f and g, composed as ((compose f g) ≡ x)); the composition can be bound to create a new function, as in (define fg (compose f g)). Procedure (compose proc ...) takes one or more procedures and returns a new procedure that performs the same action as the individual procedures would if called in succession.",				"",				"",				"(define (compose . fns)",				"  (let comp ((fns fns))",				"    (cond",				"      ((null? fns) 'error)",				"      ((null? (cdr fns)) (car fns))",				"      (else",				"        (lambda args",				"          (call-with-values",				"            (lambda ()",				"              (apply",				"                (comp (cdr fns))",				"                args))",				"            (car fns)))))))",				"Compose works with sections to create succinct but highly expressive procedure definitions. The expression to compute the squares of the integers from 1 to 10 given above at stream-unfold could be written by composing stream-map, stream-take-while, and stream-iterate:",				"",				"",				"((compose",				"  (lsec stream-map (rsec expt 2))",				"  (lsec stream-take-while (negate (rsec > 10)))",				"  (lsec stream-iterate (rsec + 1)))",				" 1)",				"Examples",				"The examples below show a few of the myriad ways streams can be exploited, as well as a few ways they can trip the unwary user. All the examples are drawn from published sources; it is instructive to compare the Scheme versions to the originals in other languages.",				"",				"Infinite streams",				"As a simple illustration of infinite streams, consider this definition of the natural numbers:",				"",				"",				"(define nats",				"  (stream-cons 0",				"    (stream-map add1 nats)))",				"The recursion works because it is offset by one from the initial stream-cons. Another sequence that uses the offset trick is this definition of the fibonacci numbers:",				"",				"",				"(define fibs",				"  (stream-cons 1",				"    (stream-cons 1",				"      (stream-map +",				"        fibs",				"        (stream-cdr fibs)))))",				"Yet another sequence that uses the same offset trick is the Hamming numbers, named for the mathematician and computer scientist Richard Hamming, defined as all numbers that have no prime factors greater than 5; in other words, Hamming numbers are all numbers expressible as 2i·3j·5k, where i, j and k are non-negative integers. The Hamming sequence starts with 1 2 3 4 5 6 8 9 10 12 and is computed starting with 1, taking 2, 3 and 5 times all the previous elements with stream-map, then merging sub-streams and eliminating duplicates.",				"",				"",				"(define hamming",				"  (stream-cons 1",				"    (stream-unique =",				"      (stream-merge <",				"        (stream-map (lsec * 2) hamming)",				"        (stream-map (lsec * 3) hamming)",				"        (stream-map (lsec * 5) hamming)))))",				"It is possible to have an infinite stream of infinite streams. Consider the definition of power-table:",				"",				"",				"(define power-table",				"  (stream-of",				"    (stream-of (expt m n)",				"      (m in (stream-from 1)))",				"      (n in (stream-from 2))))",				"which evaluates to an infinite stream of infinite streams:",				"",				"",				"(stream",				"  (stream 1 4 9 16 25 ...)",				"  (stream 1 8 27 64 125 ...)",				"  (stream 1 16 81 256 625 ...)",				"  ...)",				"But even though it is impossible to display power-table in its entirety, it is possible to select just part of it:",				"",				"",				"(stream->list 10 (stream-ref power-table 1))",				"  ⇒ (1 8 27 64 125 216 343 512 729 1000)",				"This example clearly shows that the elements of a stream are computed lazily, as they are needed; (stream-ref power-table 0) is not computed, even when its successor is displayed, since computing it would enter an infinite loop.",				"",				"Chris Reade shows how to calculate the stream of prime numbers according to the sieve of Eratosthenes, using a method that eliminates multiples of the sifting base with addition rather than division:",				"",				"",				"(define primes (let ()",				"  (define-stream (next base mult strm)",				"    (let ((first (stream-car strm))",				"          (rest (stream-cdr strm)))",				"      (cond ((< first mult)",				"              (stream-cons first",				"                (next base mult rest)))",				"            ((< mult first)",				"              (next base (+ base mult) strm))",				"            (else (next base",				"                    (+ base mult) rest)))))",				"  (define-stream (sift base strm)",				"    (next base (+ base base) strm))",				"  (define-stream (sieve strm)",				"    (let ((first (stream-car strm))>",				"          (rest (stream-cdr strm)))",				"      (stream-cons first",				"        (sieve (sift first rest)))))",				"  (sieve (stream-from 2))))",				"A final example of infinite streams is a functional pearl from Jeremy Gibbons, David Lester and Richard Bird that enumerates the positive rational numbers without duplicates:",				"",				"",				"(define rats",				"  (stream-iterate",				"    (lambda (x)",				"      (let* ((n (floor x)) (y (- x n)))",				"        (/ (- n -1 y))))",				"    1))",				"Backtracking via the stream of successes",				"Philip Wadler describes the stream of successes technique that uses streams to perform backtracking search. The basic idea is that each procedure returns a stream of possible results, so that its caller can decide which result it wants; an empty stream signals failure, and causes backtracking to a previous choice point. The stream of successes technique is useful because the program is written as if to simply enumerate all possible solutions; no backtracking is explicit in the code.",				"",				"The Eight Queens puzzle, which asks for a placement of eight queens on a chessboard so that none of them attack any other, is an example of a problem that can be solved using the stream of successes technique. The algorithm is to place a queen in the first column of a chessboard; any column is satisfactory. Then a queen is placed in the second column, in any position not held in check by the queen in the first column. Then a queen is placed in the third column, in any position not held in check by the queens in the first two columns. And so on, until all eight queens have been placed. If at any point there is no legal placement for the next queen, backtrack to a different legal position for the previous queens, and try again.",				"",				"The chessboard is represented as a stream of length m, where there are queens in the first m columns, each position in the stream representing the rank on which the queen appears in that column. For example, stream 4 6 1 5 2 8 3 7 represents the following chessboard:",				"",				"Chessboard",				"",				"Two queens at column i row j and column m row n check each other if their columns i and m are the same, or if their rows j and n are the same, or if they are on the same diagonal with i + j = m + n or i – j = m – n. There is no need to test the columns, because the placement algorithm enforces that they differ, so the check? procedure tests if two queens hold each other in check.",				"",				"",				"(define (check? i j m n)",				"  (or (= j n)",				"      (= (+ i j) (+ m n))",				"      (= (- i j) (- m n))))",				"The algorithm walks through the columns, extending position p by adding a new queen in row n with (stream-append p (stream n)). Safe? tests if it is safe to do so, using the utility procedure stream-and.",				"",				"",				"(define (stream-and strm)",				"  (let loop ((strm strm))",				"    (cond ((stream-null? strm) #t)",				"          ((not (stream-car strm)) #f)",				"          (else (loop (stream-cdr strm))))))",				"",				"(define (safe? p n)",				"  (let* ((len (stream-length p))",				"         (m (+ len 1)))",				"    (stream-and",				"      (stream-of",				"        (not (check? (car ij) (cadr ij) m n))",				"          (ij in (stream-zip",				"                   (stream-range 1 m)",				"                   p))))))",				"Procedure (queens m) returns all the ways that queens can safely be placed in the first m columns.",				"",				"",				"(define (queens m)",				"  (if (zero? m)",				"      (stream (stream))",				"      (stream-of (stream-append p (stream n))",				"        (p in (queens (- m 1)))",				"        (n in (stream-range 1 9))",				"        (safe? p n))))",				"To see the first solution to the Eight Queens problem, say",				"",				"(stream->list (stream-car (queens 8)))",				"",				"To see all 92 solutions, say",				"",				"",				"(stream->list",				"  (stream-map stream->list",				"    (queens 8)))",				"There is no explicit backtracking in the code. The stream-of expression in queens returns all possible streams that satisfy safe?; implicit backtracking occurs in the recursive call to queens.",				"",				"Generators and co-routines",				"It is possible to model generators and co-routines using streams. Consider the task, due to Carl Hewitt, of determining if two trees have the same sequence of leaves:",				"",				"(same-fringe? = '(1 (2 3)) '((1 2) 3)) ⇒ #t",				"",				"(same-fringe? = '(1 2 3) '(1 (3 2))) ⇒ #f",				"",				"The simplest solution is to flatten both trees into lists and compare them element-by-element:",				"",				"",				"(define (flatten tree)",				"  (cond ((null? tree) '())",				"        ((pair? (car tree))",				"          (append (flatten (car tree))",				"                  (flatten (cdr tree))))",				"        (else (cons (car tree)",				"                    (flatten (cdr tree))))))",				"",				"(define (same-fringe? eql? tree1 tree2)",				"  (let loop ((t1 (flatten tree1))",				"             (t2 (flatten tree2)))",				"    (cond ((and (null? t1) (null? t2)) #t)",				"          ((or (null? t1) (null? t2)) #f)",				"          ((not (eql? (car t1) (car t2))) #f)",				"          (else (loop (cdr t1) (cdr t2))))))",				"That works, but requires time to flatten both trees and space to store the flattened versions; if the trees are large, that can be a lot of time and space, and if the fringes differ, much of that time and space is wasted.",				"",				"Hewitt used a generator to flatten the trees one element at a time, storing only the current elements of the trees and the machines needed to continue flattening them, so same-fringe? could stop early if the trees differ. Dorai Sitaram presents both the generator solution and a co-routine solution, which both involve tricky calls to call-with-current-continuation and careful coding to keep them synchronized.",				"",				"An alternate solution flattens the two trees to streams instead of lists, which accomplishes the same savings of time and space, and involves code that looks little different than the list solution presented above:",				"",				"",				"(define-stream (flatten tree)",				"  (cond ((null? tree) stream-null)",				"        ((pair? (car tree))",				"          (stream-append",				"            (flatten (car tree))",				"            (flatten (cdr tree))))",				"        (else (stream-cons",				"                (car tree)",				"                (flatten (cdr tree))))))",				"",				"(define (same-fringe? eql? tree1 tree2)",				"  (let loop ((t1 (flatten tree1))",				"             (t2 (flatten tree2)))",				"    (cond ((and (stream-null? t1)",				"                (stream-null? t2)) #t)",				"          ((or  (stream-null? t1)",				"                (stream-null? t2)) #f)",				"          ((not (eql? (stream-car t1)",				"                      (stream-car t2))) #f)",				"          (else (loop (stream-cdr t1)",				"                      (stream-cdr t2))))))",				"Note that streams, a data structure, replace generators or co-routines, which are control structures, providing a fine example of how lazy streams enhance modularity.",				"",				"A pipeline of procedures",				"Another way in which streams promote modularity is enabling the use of many small procedures that are easily composed into larger programs, in the style of unix pipelines, where streams are important because they allow a large dataset to be processed one item at a time. Bird and Wadler provide the example of a text formatter. Their example uses right-folds:",				"",				"",				"(define (stream-fold-right f base strm) ",				"  (if (stream-null? strm)",				"      base",				"      (f (stream-car strm)",				"         (stream-fold-right f base",				"           (stream-cdr strm)))))",				"",				"(define (stream-fold-right-one f strm)",				"  (stream-match strm",				"  ((x) x)",				"  ((x . xs)",				"    (f x (stream-fold-right-one f xs)))))",				"Bird and Wadler define text as a stream of characters, and develop a standard package for operating on text, which they derive mathematically (this assumes the line-separator character is a single #\\newline):",				"",				"",				"(define (breakon a)",				"  (stream-lambda (x xss)",				"    (if (equal? a x)",				"        (stream-append (stream (stream)) xss)",				"        (stream-append",				"          (stream (stream-append",				"              (stream x) (stream-car xss)))",				"          (stream-cdr xss)))))",				"",				"(define-stream (lines strm) ",				"  (stream-fold-right",				"    (breakon #\\newline)",				"    (stream (stream))",				"    strm))",				"",				"(define-stream (words strm)",				"  (stream-filter stream-pair?",				"    (stream-fold-right",				"      (breakon #\\space)",				"      (stream (stream))",				"      strm)))",				"",				"(define-stream (paras strm)",				"  (stream-filter stream-pair?",				"    (stream-fold-right",				"      (breakon stream-null)",				"      (stream (stream))",				"      strm)))",				"",				"(define (insert a)",				"  (stream-lambda (xs ys)",				"    (stream-append xs (stream a) ys)))",				"",				"(define unlines",				"  (lsec stream-fold-right-one",				"    (insert #\\newline)))",				"",				"(define unwords",				"  (lsec stream-fold-right-one",				"    (insert #\\space)))",				"",				"(define unparas",				"  (lsec stream-fold-right-one",				"    (insert stream-null)))",				"These versatile procedures can be composed to count words, lines and paragraphs; the normalize procedure squeezes out multiple spaces and blank lines:",				"",				"",				"(define countlines",				"  (compose stream-length lines))",				"",				"(define countwords",				"  (compose stream-length",				"           stream-concat",				"           (lsec stream-map words)",				"           lines))",				"",				"(define countparas",				"  (compose stream-length paras lines))",				"",				"(define parse",				"  (compose (lsec stream-map",				"             (lsec stream-map words))",				"           paras",				"           lines))",				"",				"(define unparse",				"  (compose unlines",				"           unparas",				"           (lsec stream-map",				"             (lsec stream-map unwords))))",				"",				"(define normalize (compose unparse parse))",				"More useful than normalization is text-filling, which packs as many words onto each line as will fit.",				"",				"",				"(define (greedy m ws)",				"  (- (stream-length",				"       (stream-take-while (rsec <= m)",				"         (stream-scan",				"           (lambda (n word)",				"             (+ n (stream-length word) 1))",				"           -1",				"           ws))) 1))",				"",				"(define-stream (fill m ws)",				"  (if (stream-null? ws)",				"      stream-null",				"      (let* ((n (greedy m ws))",				"             (fstline (stream-take n ws))",				"             (rstwrds (stream-drop n ws)))",				"        (stream-append",				"          (stream fstline)",				"          (fill m rstwrds)))))",				"",				"(define linewords",				"  (compose stream-concat",				"           (lsec stream-map words)))",				"",				"(define textparas",				"  (compose (lsec stream-map linewords)",				"           paras",				"           lines))",				"",				"(define (filltext m strm)",				"  (unparse (stream-map (lsec fill m) (textparas strm))))",				"To display filename in lines of n characters, say:",				"",				"",				"(stream-for-each display",				"  (filltext n (file->stream filename)))",				"Though each operator performs only a single task, they can be composed powerfully and expressively. The alternative is to build a single monolithic procedure for each task, which would be harder and involve repetitive code. Streams ensure procedures are called as needed.",				"",				"Persistent data",				"Queues are one of the fundamental data structures of computer science. In functional languages, queues are commonly implemented using two lists, with the front half of the queue in one list, where the head of the queue can be accessed easily, and the rear half of the queue in reverse order in another list, where new items can easily be added to the end of a queue. The standard form of such a queue holds that the front list can only be null if the rear list is also null:",				"",				"(define queue-null (cons '() '())",				"",				"",				"(define (queue-null? obj)",				"  (and (pair? obj) (null? (car obj))))",				"",				"(define (queue-check f r)",				"  (if (null? f)",				"      (cons (reverse r) '())",				"      (cons f r)))",				"",				"(define (queue-snoc q x)",				"  (queue-check (car q) (cons x (cdr q))))",				"",				"(define (queue-head q)",				"  (if (null? (car q))",				"      (error \"empty queue: head\")",				"      (car (car q))))",				"",				"(define (queue-tail q)",				"  (if (null? (car q))",				"      (error \"empty-head: tail\")",				"      (queue-check (cdr (car q)) (cdr q))))",				"This queue operates in amortized constant time per operation, with two conses per element, one when it is added to the rear list, and another when the rear list is reversed to become the front list. Queue-snoc and queue-head operate in constant time; queue-tail operates in worst-case linear time when the front list is empty.",				"",				"Chris Okasaki points out that, if the queue is used persistently, its time-complexity rises from linear to quadratic since each persistent copy of the queue requires its own linear-time access. The problem can be fixed by implementing the front and rear parts of the queue as streams, rather than lists, and rotating one element from rear to front whenever the rear list is larger than the front list:",				"",				"",				"(define queue-null",				"  (cons stream-null stream-null))",				"",				"(define (queue-null? x)",				"  (and (pair? x) (stream-null (car x))))",				"",				"(define (queue-check f r)",				"  (if (< (stream-length r) (stream-length f))",				"      (cons f r)",				"      (cons (stream-append f (stream-reverse r))",				"            stream-null)))",				"",				"(define (queue-snoc q x)",				"  (queue-check (car q) (stream-cons x (cdr q))))",				"",				"(define (queue-head q)",				"  (if (stream-null? (car q))",				"      (error \"empty queue: head\")",				"      (stream-car (car q))))",				"",				"(define (queue-tail q)",				"  (if (stream-null? (car q))",				"      (error \"empty queue: tail\")",				"      (queue-check (stream-cdr (car q))",				"                   (cdr q))))",				"Memoization solves the persistence problem; once a queue element has moved from rear to front, it need never be moved again in subsequent traversals of the queue. Thus, the linear time-complexity to access all elements in the queue, persistently, is restored.",				"",				"Reducing two passes to one",				"The final example is a lazy dictionary, where definitions and uses may occur in any order; in particular, uses may precede their corresponding definitions. This is a common problem. Many programming languages allow procedures to be used before they are defined. Macro processors must collect definitions and emit uses of text in order. An assembler needs to know the address that a linker will subsequently give to variables. The usual method is to make two passes over the data, collecting the definitions on the first pass and emitting the uses on the second pass. But Chris Reade shows how streams allow the dictionary to be built lazily, so that only a single pass is needed. Consider a stream of requests:",				"",				"",				"(define requests",				"  (stream",				"    '(get 3)",				"    '(put 1 \"a\")    ; use follows definition",				"    '(put 3 \"c\")    ; use precedes definition",				"    '(get 1)",				"    '(get 2)",				"    '(put 2 \"b\")    ; use precedes definition",				"    '(put 4 \"d\")))  ; unused definition",				"We want a procedure that will display cab, which is the result of (get 3), (get 1), and (get 2), in order. We first separate the request stream into gets and puts:",				"",				"",				"(define (get? obj) (eq? (car obj) 'get))",				"",				"(define-stream (gets strm)",				"  (stream-map cadr (stream-filter get? strm)))",				"",				"(define-stream (puts strm)",				"  (stream-map cdr  (stream-remove get? strm)))",				"Now, run-dict inserts each element of the puts stream into a lazy dictionary, represented as a stream of key/value pairs (an association stream), then looks up each element of the gets stream with stream-assoc:",				"",				"",				"(define-stream (run-dict requests)",				"  (let ((dict (build-dict (puts requests))))",				"    (stream-map (rsec stream-assoc dict)",				"      (gets requests))))",				"",				"(define (stream-assoc key dict)",				"    (cond ((stream-null? dict) #f)",				"          ((equal? key (car (stream-car dict)))",				"            (stream-car dict))",				"          (else (stream-assoc key",				"                  (stream-cdr dict)))))",				"Dict is created in the let, but nothing is initially added to it. Each time stream-assoc performs a lookup, enough of dict is built to satisfy the lookup, but no more. We are assuming that each item is defined once and only once. All that is left is to define the procedure that inserts new items into the dictionary, lazily:",				"",				"",				"(define-stream (build-dict puts)",				"  (if (stream-null? puts)",				"      stream-null",				"      (stream-cons",				"        (stream-car puts)",				"        (build-dict (stream-cdr puts)))))",				"Now we can run the requests and print the result:",				"",				"",				"(stream-for-each display",				"  (stream-map cadr (run-dict requests)))",				"The (put 4 \"d\") definition is never added to the dictionary because it is never needed.",				"",				"Pitfalls",				"Programming with streams, or any lazy evaluator, can be tricky, even for programmers experienced in the genre. Programming with streams is even worse in Scheme than in a purely functional language, because, though the streams are lazy, the surrounding Scheme expressions in which they are embedded are eager. The impedance between lazy and eager can occasionally lead to astonishing results. Thirty-two years ago, William Burge warned:",				"",				"Some care must be taken when a stream is produced to make sure that its elements are not really a list in disguise, in other words, to make sure that the stream elements are not materialized too soon.",				"",				"For example, a simple version of stream-map that returns a stream built by applying a unary procedure to the elements of an input stream could be defined like this:",				"",				"",				"(define-stream (stream-map proc strm) ;wrong!",				"  (let loop ((strm strm))",				"    (if (stream-null? strm)",				"        stream-null",				"        (stream-cons",				"          (proc (stream-car strm))",				"          (loop (stream-cdr strm))))))",				"That looks right. It properly wraps the procedure in stream-lambda, and the two legs of the if both return streams, so it type-checks. But it fails because the named let binds loop to a procedure using normal lambda rather than stream-lambda, so even though the first element of the result stream is lazy, subsequent elements are eager. Stream-map can be written using stream-let:",				"",				"",				"(define-stream (stream-map proc strm)",				"  (stream-let loop ((strm strm))",				"    (if (stream-null? strm)",				"        stream-null",				"        (stream-cons",				"          (proc (stream-car strm))",				"          (loop (stream-cdr strm))))))",				"Here, stream-let assures that each element of the result stream is properly delayed, because each is subject to the stream-lambda that is implicit in stream-let, so the result is truly a stream, not a “list in disguise.” Another version of this procedure was given previously at the description of define-stream.",				"",				"Another common problem occurs when a stream-valued procedure requires the next stream element in its definition. Consider this definition of stream-unique:",				"",				"",				"(define-stream (stream-unique eql? strm) ;wrong!",				"  (stream-match strm",				"    (() strm)",				"    ((_) strm)",				"    ((a b . _)",				"      (if (eql? a b)",				"          (stream-unique eql?",				"            (stream-cdr strm))",				"          (stream-cons a",				"            (stream-unique eql?",				"              (stream-cdr strm)))))))",				"The (a b . _) pattern requires the value of the next stream element after the one being considered. Thus, to compute the nth element of the stream, one must know the n+1st element, and to compute the n+1st element, one must know the n+2nd element, and to compute…. The correct version, given above in the description of stream-drop-while, only needs the current stream element.",				"",				"A similar problem occurs when the stream expression uses the previous element to compute the current element:",				"",				"",				"(define (nat n)",				"  (stream-ref",				"    (stream-let loop ((s (stream 0)))",				"      (stream-cons (stream-car s)",				"        (loop (stream (add1 (stream-car s))))))",				"    n))",				"This program traverses the stream of natural numbers, building the stream as it goes. The definition is correct; (nat 15) evaluates to 15. But it needlessly uses unbounded space because each stream element holds the value of the prior stream element in the binding to s.",				"",				"When traversing a stream, it is easy to write the expression in such a way that evaluation requires unbounded space, even when that is not strictly necessary. During the discussion of SRFI-40, Joe Marshall created this infamous procedure:",				"",				"",				"(define (times3 n)",				"  (stream-ref",				"    (stream-filter",				"      (lambda (x)",				"        (zero? (modulo x n)))",				"      (stream-from 0))",				"    3))",				"(times3 5) evaluates to 15 and (times3 #e1e9) evaluates to three billion, though it takes a while. In either case, times3 should operate in bounded space, since each iteration mutates the promise that holds the next value. But it is easy to write times3 so that it does not operate in bounded space, as the follies of SRFI-40 showed. The common problem is that some element of the stream (often the first element) is bound outside the expression that is computing the stream, so it holds the head of the stream, which holds the second element, and so on. In addition to testing the programmer, this procedure tests the stream primitives (it caught several errors during development) and also tests the underlying Scheme system (it found a bug in one implementation).",				"",				"Laziness is no defense against an infinite loop; for instance, the expression below never returns, because the odd? predicate never finds an odd stream element.",				"",				"",				"(stream-null?",				"  (stream-filter odd?",				"    (stream-from 0 2)))",				"Ultimately, streams are defined as promises, which are implemented as thunks (lambda with no arguments). Since a stream is a procedure, comparisons such as eq?, eqv? and equal? are not meaningful when applied to streams. For instance, the expression (define s ((stream-lambda () stream-null))) defines s as the null stream, and (stream-null? s) is #t, but (eq? s stream-null) is #f. To determine if two streams are equal, it is necessary to evaluate the elements in their common prefixes, reporting #f if two elements ever differ and #t if both streams are exhausted at the same time.",				"",				"",				"(define (stream-equal? eql? xs ys)",				"  (cond ((and (stream-null? xs)",				"              (stream-null? ys)) #t)",				"        ((or (stream-null? xs)",				"             (stream-null? ys)) #f)",				"        ((not (eql? (stream-car xs)",				"                    (stream-car ys))) #f)",				"        (else (stream-equal? eql?",				"                (stream-cdr xs)",				"                (stream-cdr ys)))))",				"It is generally not a good idea to mix lazy streams with eager side-effects, because the order in which stream elements are evaluated determines the order in which the side-effects occur. For a simple example, consider this side-effecting version of strm123:",				"",				"",				"(define strm123-with-side-effects",				"  (stream-cons (begin (display \"one\") 1)",				"    (stream-cons (begin (display \"two\") 2)",				"      (stream-cons (begin (display \"three\") 3)",				"        stream-null))))",				"The stream has elements 1 2 3. But depending on the order in which stream elements are accessed, \"one\", \"two\" and \"three\" could be printed in any order.",				"",				"Since the performance of streams can be very poor, normal (eager) lists should be preferred to streams unless there is some compelling reason to the contrary. For instance, computing pythagorean triples with streams",				"",				"",				"(stream-ref",				"  (stream-of (list a b c)",				"    (n in (stream-from 1))",				"    (a in (stream-range 1 n))",				"    (b in (stream-range a n))",				"    (c is (- n a b))",				"    (= (+ (* a a) (* b b)) (* c c)))",				"  50)",				"is about two orders of magnitude slower than the equivalent expression using loops.",				"",				"",				"(do ((n 1 (+ n 1))) ((> n 228))",				"  (do ((a 1 (+ a 1))) ((> a n))",				"    (do ((b a (+ b 1))) ((> b n))",				"      (let ((c (- n a b)))",				"        (if (= (+ (* a a) (* b b)) (* c c))",				"            (display (list a b c)))))))",				"Implementation",				"Bird and Wadler describe streams as either null or a pair with a stream in the tail:",				"",				"α list :: null | α * α list",				"",				"That works in a purely functional language such as Miranda or Haskell because the entire language is lazy. In an eager language like ML or Scheme, of course, it’s just a normal, eager list.",				"",				"Using ML, Wadler, Taha and MacQueen give the type of even streams as:",				"",				"",				"datatype 'a stream_",				"  = Nil_",				"  | Cons_ of 'a * 'a stream",				"withtype 'a stream",				"  = 'a stream_ susp;",				"Their susp type is similar to Scheme’s promise type. Since Scheme conflates the notions of record and type (the only way to create a new type disjoint from all other types is to create a record), it is necessary to distribute the suspension through the two constructors of the stream data type:",				"",				"",				"α stream",				"  :: (promise stream-null)",				"  |  (promise (α stream-pair))",				"",				"α stream-pair",				"  :: α × (α stream)",				"That type captures the systematic suspension of recursive promises that is the essence of “streamness.” But it doesn’t quite work, because Scheme is eager rather than lazy, and both the car and the cdr of the stream are evaluated too early. So the final type of streams delays both the car and the cdr of the stream-pair:",				"",				"",				"α stream",				"  :: (promise stream-null)",				"  |  (promise (α stream-pair))",				"",				"α stream-pair",				"  :: (promise α) × (promise (α stream))",				"The two outer promises, in the stream type, provide streams without memoization. The two inner promises, in the stream-pair type, add the memoization that is characteristic of streams in modern functional languages.",				"",				"Lists provide seven primitive operations: the two constructors '() and cons, the type predicates list?, null? and pair?, and the accessors car and cdr for pairs. All other list operations can be derived from those primitives.",				"",				"It would seem that the same set of primitives could apply to streams, but in fact one additional primitive is required. André van Tonder describes the reason in his discussion of the promise data type. The promises of R6RS are inadequate to support iterative algorithms because each time a promise is called iteratively it binds the old promise in the closure that defines the new promise (so the old promise can be forced later, if requested). However, in the case of iteration, the old promise becomes unreachable, so instead of creating a new promise that binds the old promise within, it is better to mutate the promise; that way, no space is wasted by the old promise.",				"",				"Van Tonder describes this new promise type, and provides a recipe for its use: all constructors are wrapped with delay, all accessors are wrapped with force, and all function bodies are wrapped with lazy. Given the seven primitives above, the first two parts of van Tonder’s recipe are simple: the two constructors stream-null and stream-pair hide delay, and the two accessors stream-car and stream-cdr hide force (stream-null? and stream-pair? also hide force, so they can distinguish the two constructors of the stream type).",				"",				"Although the new promise type prevents a space leak, it creates a new problem: there is no place to hide the lazy that is the third part of van Tonder’s recipe. SRFI-40 solved this problem by exposing it (actually, it exposed delay, which was incorrect). But that violates good software engineering by preventing the stream data type from being fully abstract. The solution of SRFI-41 is to create a new primitive, stream-lambda, that returns a function that hides lazy.",				"",				"Besides hiding lazy and making the types work out correctly, stream-lambda is obvious and easy-to-use for competent Scheme programmers, especially when augmented with the syntactic sugar of define-stream and named stream-let. The alternative of exposing stream-lazy would be less clear and harder to use.",				"",				"One of the hardest tasks when writing any program library is to decide what to include and, more importantly, what to exclude. One important guideline is minimalism, since once an operator enters a library it must remain forever: Il semble que la perfection soit atteinte non quand il n’y a plus rien à ajouter, mais quand il n’y a plus rien à retrancher.",				"",				"Since streams are substantially slower than lists (the stream primitives require numerous type conversions, and list operations in most Scheme implementations are heavily optimized), most programmers will use streams only when the sequence of elements is truly infinite (such as mathematical series) or when there is some clear advantage of laziness (such as reducing the number of passes though a large data set). Thus, the library is biased toward functions that work with infinite streams left-to-right. In particular, there is no right-fold; if you need to materialize an entire stream, it’s best to use a list.",				"",				"Implementation of (streams primitive)",				"(library (streams primitive)",				"",				"",				"  (export stream-null stream-cons stream? stream-null? stream-pair?",				"          stream-car stream-cdr stream-lambda)",				"",				"  (import (rnrs) (rnrs mutable-pairs))",				"",				"  (define-record-type (stream-type make-stream stream?)",				"    (fields (mutable box stream-promise stream-promise!)))",				"",				"  (define-syntax stream-lazy",				"    (syntax-rules ()",				"      ((stream-lazy expr)",				"        (make-stream",				"          (cons 'lazy (lambda () expr))))))",				"",				"  (define (stream-eager expr)",				"    (make-stream",				"      (cons 'eager expr)))",				"",				"  (define-syntax stream-delay",				"    (syntax-rules ()",				"      ((stream-delay expr)",				"        (stream-lazy (stream-eager expr)))))",				"",				"  (define (stream-force promise)",				"    (let ((content (stream-promise promise)))",				"      (case (car content)",				"        ((eager) (cdr content))",				"        ((lazy)  (let* ((promise* ((cdr content)))",				"                        (content  (stream-promise promise)))",				"                   (if (not (eqv? (car content) 'eager))",				"                       (begin (set-car! content (car (stream-promise promise*)))",				"                              (set-cdr! content (cdr (stream-promise promise*)))",				"                              (stream-promise! promise* content)))",				"                   (stream-force promise))))))",				"",				"  (define stream-null (stream-delay (cons 'stream 'null)))",				"",				"  (define-record-type (stream-pare-type make-stream-pare stream-pare?)",				"    (fields (immutable kar stream-kar) (immutable kdr stream-kdr)))",				"",				"  (define (stream-pair? obj)",				"    (and (stream? obj) (stream-pare? (stream-force obj))))",				"",				"  (define (stream-null? obj)",				"    (and (stream? obj)",				"         (eqv? (stream-force obj)",				"               (stream-force stream-null))))",				"",				"  (define-syntax stream-cons",				"    (syntax-rules ()",				"      ((stream-cons obj strm)",				"        (stream-eager (make-stream-pare (stream-delay obj) (stream-lazy strm))))))",				"",				"  (define (stream-car strm)",				"    (cond ((not (stream? strm)) (error 'stream-car \"non-stream\"))",				"          ((stream-null? strm) (error 'stream-car \"null stream\"))",				"          (else (stream-force (stream-kar (stream-force strm))))))",				"",				"  (define (stream-cdr strm)",				"    (cond ((not (stream? strm)) (error 'stream-cdr \"non-stream\"))",				"          ((stream-null? strm) (error 'stream-cdr \"null stream\"))",				"          (else (stream-kdr (stream-force strm)))))",				"",				"  (define-syntax stream-lambda",				"    (syntax-rules ()",				"      ((stream-lambda formals body0 body1 ...)",				"        (lambda formals (stream-lazy (let () body0 body1 ...)))))))",				"Implementation of (streams derived)",				"(library (streams derived)",				"",				"",				"  (export stream-null stream-cons stream? stream-null? stream-pair? stream-car",				"          stream-cdr stream-lambda define-stream list->stream port->stream stream",				"          stream->list stream-append stream-concat stream-constant stream-drop",				"          stream-drop-while stream-filter stream-fold stream-for-each stream-from",				"          stream-iterate stream-length stream-let stream-map stream-match _",				"          stream-of stream-range stream-ref stream-reverse stream-scan stream-take",				"          stream-take-while stream-unfold stream-unfolds stream-zip)",				"",				"  (import (rnrs) (streams primitive))",				"",				"  (define-syntax define-stream",				"    (syntax-rules ()",				"      ((define-stream (name . formal) body0 body1 ...)",				"        (define name (stream-lambda formal body0 body1 ...)))))",				"",				"  (define (list->stream objs)",				"    (define list->stream",				"      (stream-lambda (objs)",				"        (if (null? objs)",				"            stream-null",				"            (stream-cons (car objs) (list->stream (cdr objs))))))",				"    (if (not (list? objs))",				"        (error 'list->stream \"non-list argument\")",				"        (list->stream objs)))",				"",				"  (define (port->stream . port)",				"    (define port->stream",				"      (stream-lambda (p)",				"        (let ((c (read-char p)))",				"          (if (eof-object? c)",				"              stream-null",				"              (stream-cons c (port->stream p))))))",				"    (let ((p (if (null? port) (current-input-port) (car port))))",				"      (if (not (input-port? p))",				"          (error 'port->stream \"non-input-port argument\")",				"          (port->stream p))))",				"",				"  (define-syntax stream",				"    (syntax-rules ()",				"      ((stream) stream-null)",				"      ((stream x y ...) (stream-cons x (stream y ...)))))",				"",				"  (define (stream->list . args)",				"    (let ((n (if (= 1 (length args)) #f (car args)))",				"          (strm (if (= 1 (length args)) (car args) (cadr args))))",				"      (cond ((not (stream? strm)) (error 'stream->list \"non-stream argument\"))",				"            ((and n (not (integer? n))) (error 'stream->list \"non-integer count\"))",				"            ((and n (negative? n)) (error 'stream->list \"negative count\"))",				"            (else (let loop ((n (if n n -1)) (strm strm))",				"                    (if (or (zero? n) (stream-null? strm))",				"                        '()",				"                        (cons (stream-car strm) (loop (- n 1) (stream-cdr strm)))))))))",				"",				"  (define (stream-append . strms)",				"    (define stream-append",				"      (stream-lambda (strms)",				"        (cond ((null? (cdr strms)) (car strms))",				"              ((stream-null? (car strms)) (stream-append (cdr strms)))",				"              (else (stream-cons (stream-car (car strms))",				"                                 (stream-append (cons (stream-cdr (car strms)) (cdr strms))))))))",				"    (cond ((null? strms) stream-null)",				"          ((exists (lambda (x) (not (stream? x))) strms)",				"            (error 'stream-append \"non-stream argument\"))",				"          (else (stream-append strms))))",				"",				"  (define (stream-concat strms)",				"    (define stream-concat",				"      (stream-lambda (strms)",				"        (cond ((stream-null? strms) stream-null)",				"              ((not (stream? (stream-car strms)))",				"                (error 'stream-concat \"non-stream object in input stream\"))",				"              ((stream-null? (stream-car strms))",				"                (stream-concat (stream-cdr strms)))",				"              (else (stream-cons",				"                      (stream-car (stream-car strms))",				"                      (stream-concat",				"                        (stream-cons (stream-cdr (stream-car strms)) (stream-cdr strms))))))))",				"    (if (not (stream? strms))",				"        (error 'stream-concat \"non-stream argument\")",				"        (stream-concat strms)))",				"",				"  (define stream-constant",				"    (stream-lambda objs",				"      (cond ((null? objs) stream-null)",				"            ((null? (cdr objs)) (stream-cons (car objs) (stream-constant (car objs))))",				"            (else (stream-cons (car objs)",				"                               (apply stream-constant (append (cdr objs) (list (car objs)))))))))",				"",				"  (define (stream-drop n strm)",				"    (define stream-drop",				"      (stream-lambda (n strm)",				"        (if (or (zero? n) (stream-null? strm))",				"            strm",				"            (stream-drop (- n 1) (stream-cdr strm)))))",				"    (cond ((not (integer? n)) (error 'stream-drop \"non-integer argument\"))",				"          ((negative? n) (error 'stream-drop \"negative argument\"))",				"          ((not (stream? strm)) (error 'stream-drop \"non-stream argument\"))",				"          (else (stream-drop n strm))))",				"",				"  (define (stream-drop-while pred? strm)",				"    (define stream-drop-while",				"      (stream-lambda (strm)",				"        (if (and (stream-pair? strm) (pred? (stream-car strm)))",				"            (stream-drop-while (stream-cdr strm))",				"            strm)))",				"    (cond ((not (procedure? pred?)) (error 'stream-drop-while \"non-procedural argument\"))",				"          ((not (stream? strm)) (error 'stream-drop-while \"non-stream argument\"))",				"          (else (stream-drop-while strm))))",				"",				"  (define (stream-filter pred? strm)",				"    (define stream-filter",				"      (stream-lambda (strm)",				"        (cond ((stream-null? strm) stream-null)",				"              ((pred? (stream-car strm))",				"                (stream-cons (stream-car strm) (stream-filter (stream-cdr strm))))",				"              (else (stream-filter (stream-cdr strm))))))",				"    (cond ((not (procedure? pred?)) (error 'stream-filter \"non-procedural argument\"))",				"          ((not (stream? strm)) (error 'stream-filter \"non-stream argument\"))",				"          (else (stream-filter strm))))",				"",				"  (define (stream-fold proc base strm)",				"    (cond ((not (procedure? proc)) (error 'stream-fold \"non-procedural argument\"))",				"          ((not (stream? strm)) (error 'stream-fold \"non-stream argument\"))",				"          (else (let loop ((base base) (strm strm))",				"                  (if (stream-null? strm)",				"                      base",				"                      (loop (proc base (stream-car strm)) (stream-cdr strm)))))))",				"",				"  (define (stream-for-each proc . strms)",				"    (define (stream-for-each strms)",				"      (if (not (exists stream-null? strms))",				"          (begin (apply proc (map stream-car strms))",				"                 (stream-for-each (map stream-cdr strms)))))",				"    (cond ((not (procedure? proc)) (error 'stream-for-each \"non-procedural argument\"))",				"          ((null? strms) (error 'stream-for-each \"no stream arguments\"))",				"          ((exists (lambda (x) (not (stream? x))) strms)",				"            (error 'stream-for-each \"non-stream argument\"))",				"          (else (stream-for-each strms))))",				"",				"  (define (stream-from first . step)",				"    (define stream-from",				"      (stream-lambda (first delta)",				"        (stream-cons first (stream-from (+ first delta) delta))))",				"    (let ((delta (if (null? step) 1 (car step))))",				"      (cond ((not (number? first)) (error 'stream-from \"non-numeric starting number\"))",				"            ((not (number? delta)) (error 'stream-from \"non-numeric step size\"))",				"            (else (stream-from first delta)))))",				"",				"  (define (stream-iterate proc base)",				"    (define stream-iterate",				"      (stream-lambda (base)",				"        (stream-cons base (stream-iterate (proc base)))))",				"    (if (not (procedure? proc))",				"        (error 'stream-iterate \"non-procedural argument\")",				"        (stream-iterate base)))",				"",				"  (define (stream-length strm)",				"    (if (not (stream? strm))",				"        (error 'stream-length \"non-stream argument\")",				"        (let loop ((len 0) (strm strm))",				"          (if (stream-null? strm)",				"              len",				"              (loop (+ len 1) (stream-cdr strm))))))",				"",				"  (define-syntax stream-let",				"    (syntax-rules ()",				"      ((stream-let tag ((name val) ...) body1 body2 ...)",				"       ((letrec ((tag (stream-lambda (name ...) body1 body2 ...))) tag) val ...))))",				"",				"  (define (stream-map proc . strms)",				"    (define stream-map",				"      (stream-lambda (strms)",				"        (if (exists stream-null? strms)",				"            stream-null",				"            (stream-cons (apply proc (map stream-car strms))",				"                         (stream-map (map stream-cdr strms))))))",				"    (cond ((not (procedure? proc)) (error 'stream-map \"non-procedural argument\"))",				"          ((null? strms) (error 'stream-map \"no stream arguments\"))",				"          ((exists (lambda (x) (not (stream? x))) strms)",				"            (error 'stream-map \"non-stream argument\"))",				"          (else (stream-map strms))))",				"",				"  (define-syntax stream-match",				"    (syntax-rules ()",				"      ((stream-match strm-expr clause ...)",				"        (let ((strm strm-expr))",				"          (cond",				"            ((not (stream? strm)) (error 'stream-match \"non-stream argument\"))",				"            ((stream-match-test strm clause) => car) ...",				"            (else (error 'stream-match \"pattern failure\")))))))",				"",				"  (define-syntax stream-match-test",				"    (syntax-rules ()",				"      ((stream-match-test strm (pattern fender expr))",				"        (stream-match-pattern strm pattern () (and fender (list expr))))",				"      ((stream-match-test strm (pattern expr))",				"        (stream-match-pattern strm pattern () (list expr)))))",				"",				"  (define-syntax stream-match-pattern ",				"    (lambda (x)",				"      (define (wildcard? x)",				"        (and (identifier? x)",				"             (free-identifier=? x (syntax _))))",				"      (syntax-case x () ",				"        ((stream-match-pattern strm () (binding ...) body)",				"          (syntax (and (stream-null? strm) (let (binding ...) body))))",				"        ((stream-match-pattern strm (w? . rest) (binding ...) body)",				"          (wildcard? #'w?) ",				"          (syntax (and (stream-pair? strm)",				"                       (let ((strm (stream-cdr strm)))",				"                         (stream-match-pattern strm rest (binding ...) body)))))",				"        ((stream-match-pattern strm (var . rest) (binding ...) body)",				"          (syntax (and (stream-pair? strm)",				"                       (let ((temp (stream-car strm)) (strm (stream-cdr strm))) ",				"                         (stream-match-pattern strm rest ((var temp) binding ...) body)))))",				"        ((stream-match-pattern strm w? (binding ...) body)",				"          (wildcard? #'w?)",				"          (syntax (let (binding ...) body)))",				"        ((stream-match-pattern strm var (binding ...) body) ",				"          (syntax (let ((var strm) binding ...) body))))))",				"",				"  (define-syntax stream-of",				"    (syntax-rules ()",				"      ((_ expr rest ...)",				"        (stream-of-aux expr stream-null rest ...))))",				"",				"  (define-syntax stream-of-aux",				"    (syntax-rules (in is)",				"      ((stream-of-aux expr base)",				"        (stream-cons expr base))",				"      ((stream-of-aux expr base (var in stream) rest ...)",				"        (stream-let loop ((strm stream))",				"          (if (stream-null? strm)",				"              base",				"              (let ((var (stream-car strm)))",				"                (stream-of-aux expr (loop (stream-cdr strm)) rest ...)))))",				"      ((stream-of-aux expr base (var is exp) rest ...)",				"        (let ((var exp)) (stream-of-aux expr base rest ...)))",				"      ((stream-of-aux expr base pred? rest ...)",				"        (if pred? (stream-of-aux expr base rest ...) base))))",				"",				"  (define (stream-range first past . step)",				"    (define stream-range",				"      (stream-lambda (first past delta lt?)",				"        (if (lt? first past)",				"            (stream-cons first (stream-range (+ first delta) past delta lt?))",				"            stream-null)))",				"    (cond ((not (number? first)) (error 'stream-range \"non-numeric starting number\"))",				"          ((not (number? past)) (error 'stream-range \"non-numeric ending number\"))",				"          (else (let ((delta (cond ((pair? step) (car step)) ((< first past) 1) (else -1))))",				"                  (if (not (number? delta))",				"                      (error 'stream-range \"non-numeric step size\")",				"                      (let ((lt? (if (< 0 delta) < >)))",				"                        (stream-range first past delta lt?)))))))",				"",				"  (define (stream-ref strm n)",				"    (cond ((not (stream? strm)) (error 'stream-ref \"non-stream argument\"))",				"          ((not (integer? n)) (error 'stream-ref \"non-integer argument\"))",				"          ((negative? n) (error 'stream-ref \"negative argument\"))",				"          (else (let loop ((strm strm) (n n))",				"                  (cond ((stream-null? strm) (error 'stream-ref \"beyond end of stream\"))",				"                        ((zero? n) (stream-car strm))",				"                        (else (loop (stream-cdr strm) (- n 1))))))))",				"",				"  (define (stream-reverse strm)",				"    (define stream-reverse",				"      (stream-lambda (strm rev)",				"        (if (stream-null? strm)",				"            rev",				"            (stream-reverse (stream-cdr strm) (stream-cons (stream-car strm) rev)))))",				"    (if (not (stream? strm))",				"        (error 'stream-reverse \"non-stream argument\")",				"        (stream-reverse strm stream-null)))",				"",				"  (define (stream-scan proc base strm)",				"    (define stream-scan",				"      (stream-lambda (base strm)",				"        (if (stream-null? strm)",				"            (stream base)",				"            (stream-cons base (stream-scan (proc base (stream-car strm)) (stream-cdr strm))))))",				"    (cond ((not (procedure? proc)) (error 'stream-scan \"non-procedural argument\"))",				"          ((not (stream? strm)) (error 'stream-scan \"non-stream argument\"))",				"          (else (stream-scan base strm))))",				"",				"  (define (stream-take n strm)",				"    (define stream-take",				"      (stream-lambda (n strm)",				"        (if (or (stream-null? strm) (zero? n))",				"            stream-null",				"            (stream-cons (stream-car strm) (stream-take (- n 1) (stream-cdr strm))))))",				"    (cond ((not (stream? strm)) (error 'stream-take \"non-stream argument\"))",				"          ((not (integer? n)) (error 'stream-take \"non-integer argument\"))",				"          ((negative? n) (error 'stream-take \"negative argument\"))",				"          (else (stream-take n strm))))",				"",				"  (define (stream-take-while pred? strm)",				"    (define stream-take-while",				"      (stream-lambda (strm)",				"        (cond ((stream-null? strm) stream-null)",				"              ((pred? (stream-car strm))",				"                (stream-cons (stream-car strm) (stream-take-while (stream-cdr strm))))",				"              (else stream-null))))",				"    (cond ((not (stream? strm)) (error 'stream-take-while \"non-stream argument\"))",				"          ((not (procedure? pred?)) (error 'stream-take-while \"non-procedural argument\"))",				"          (else (stream-take-while strm))))",				"",				"  (define (stream-unfold mapper pred? generator base)",				"    (define stream-unfold",				"      (stream-lambda (base)",				"        (if (pred? base)",				"            (stream-cons (mapper base) (stream-unfold (generator base)))",				"            stream-null)))",				"    (cond ((not (procedure? mapper)) (error 'stream-unfold \"non-procedural mapper\"))",				"          ((not (procedure? pred?)) (error 'stream-unfold \"non-procedural pred?\"))",				"          ((not (procedure? generator)) (error 'stream-unfold \"non-procedural generator\"))",				"          (else (stream-unfold base))))",				"",				"  (define (stream-unfolds gen seed)",				"    (define (len-values gen seed)",				"      (call-with-values",				"        (lambda () (gen seed))",				"        (lambda vs (- (length vs) 1))))",				"    (define unfold-result-stream",				"      (stream-lambda (gen seed)",				"        (call-with-values",				"          (lambda () (gen seed))",				"          (lambda (next . results)",				"            (stream-cons results (unfold-result-stream gen next))))))",				"    (define result-stream->output-stream",				"      (stream-lambda (result-stream i)",				"        (let ((result (list-ref (stream-car result-stream) (- i 1))))",				"          (cond ((pair? result)",				"                  (stream-cons",				"                    (car result)",				"                    (result-stream->output-stream (stream-cdr result-stream) i)))",				"                ((not result)",				"                  (result-stream->output-stream (stream-cdr result-stream) i))",				"                ((null? result) stream-null)",				"                (else (error 'stream-unfolds \"can't happen\"))))))",				"    (define (result-stream->output-streams result-stream)",				"      (let loop ((i (len-values gen seed)) (outputs '()))",				"        (if (zero? i)",				"            (apply values outputs)",				"            (loop (- i 1) (cons (result-stream->output-stream result-stream i) outputs)))))",				"    (if (not (procedure? gen))",				"        (error 'stream-unfolds \"non-procedural argument\")",				"        (result-stream->output-streams (unfold-result-stream gen seed))))",				"",				"  (define (stream-zip . strms)",				"    (define stream-zip",				"      (stream-lambda (strms)",				"        (if (exists stream-null? strms)",				"            stream-null",				"            (stream-cons (map stream-car strms) (stream-zip (map stream-cdr strms))))))",				"    (cond ((null? strms) (error 'stream-zip \"no stream arguments\"))",				"          ((exists (lambda (x) (not (stream? x))) strms)",				"            (error 'stream-zip \"non-stream argument\"))",				"          (else (stream-zip strms)))))",				"Implementation of (streams)",				"(library (streams)",				"",				"",				"  (export stream-null stream-cons stream? stream-null? stream-pair? stream-car",				"          stream-cdr stream-lambda define-stream list->stream port->stream stream",				"          stream->list stream-append stream-concat stream-constant stream-drop",				"          stream-drop-while stream-filter stream-fold stream-for-each stream-from",				"          stream-iterate stream-length stream-let stream-map stream-match _",				"          stream-of stream-range stream-ref stream-reverse stream-scan stream-take",				"          stream-take-while stream-unfold stream-unfolds stream-zip)",				"",				"  (import (streams primitive) (streams derived)))",				"Acknowledgements",				"Jos Koot sharpened my thinking during many e-mail discussions, suggested several discussion points in the text, and contributed the final version of stream-match. Michael Sperber and Abdulaziz Ghuloum gave advice on R6RS.",				"",				"References",				"Harold Abelson and Gerald Jay Sussman with Julie Sussman. Structure and Interpretation of Computer Programs. MIT Press, Cambridge, Massachusetts. Second edition, 1996. mitpress.mit.edu/sicp. The classic text on computer science. Section 3.5 includes extensive discussion of odd streams.",				"",				"Anne L. Bewig. “Golden Ratio” (personal communication). Homework for the high school course Calculus. Teaching my daughter how to calculate the 200th element of a continued fraction was a moment of sheer joy in the development of the stream libraries.",				"",				"Philip L. Bewig. Scheme Request for Implementation 40: A Library of Streams. August, 2004. srfi.schemers.org/srfi-40. Describes an implementation of the stream data type.",				"",				"Richard Bird and Philip Wadler. Introduction to Functional Programming. Prentice Hall, 1988. The classic text on functional programming. Even streams are discussed in the context of purely functional programming.",				"",				"William H. Burge. Recursive Programming Techniques. Addison-Wesley, 1975. An early text on functional programming, and still one of the best, though the terminology is dated. Discusses even streams in Section 3.10.",				"",				"Jeremy Gibbons, David Lester and Richard Bird, “Functional Pearl: Enumerating the Rationals,” under consideration for publication in Journal of Functional Programming. http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/rationals.pdf. Discusses a series of expressions that enumerate the rational numbers without duplicates.",				"",				"Carl Hewitt. “Viewing control structures as patterns of passing messages,” in Journal of Artificial Intelligence, Volume 8, Number 3 (June, 1977), pp 323-364. Also published as Artificial Intelligence Memo 410 by the Massachusetts Institute of Technology, ftp://publications.ai.mit.edu/ai-publications/pdf/AIM-410.pdf. Describes the Actor message-passing system; one of the examples used is the same-fringe? problem.",				"",				"Peter J. Landin. “A correspondence between ALGOL 60 and Church’s lambda-notation: Part I,” Communications of the ACM, Volume 8, Number 2, February 1965., pages 89–101. The seminal description of streams.",				"",				"Joe Marshall. “Stream problem redux”, from Usenet comp.lang.scheme, June 28, 2002. groups.google.com/group/comp.lang.scheme/msg/db4b4a1f33e3eea8. The original post on comp.lang.scheme that describes the times3 problem.",				"",				"Chris Okasaki. Purely Functional Data Structures. Cambridge University Press, 2003. Revised version of Okasaki’s thesis Purely Functional Data Structures, Carnegie-Mellon University, 1996, www.cs.cmu.edu/~rwh/theses/okasaki.pdf. Provides a strong defense of laziness, and describes several data structures that exploit laziness, including streams and queues.",				"",				"Stephen K. Park and Keith W. Miller. “Random number generators: good ones are hard to find,” Communications of the ACM, Volume 31, Issue 10 (October 1988), pages 1192–1201. Describes a minimal standard random number generator.",				"",				"Simon Peyton-Jones, et al, editors. Haskell 98: Haskell 98 Language and Libraries: The Revised Report. December 2002. www.haskell.org/onlinereport. Haskell is the prototypical purely functional language, and includes even streams, which it calls lists, as its fundamental structured data type.",				"",				"Chris Reade. Elements of Functional Programming. Addison-Wesley, April 1989. A textbook on functional programming.",				"",				"Antoine de Saint-Exupéry. Chapter III “L’Avion” of Terre des Hommes. 1939. “Perfection is achieved, not when there is nothing more to add, but when there is nothing left to take away.”",				"",				"Dorai Sitaram. Teach Yourself Scheme in Fixnum Days. www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html. A useful introduction to Scheme; includes generator and co-routine solutions to the same-fringe? problem.",				"",				"Michael Sperber, R. Kent Dybvig, Matthew Flatt, and Anton von Straaten, editors. Revised6 Report on the Algorithmic Language Scheme. September 26, 2007. www.r6rs.org. The standard definition of the Scheme programming language.",				"",				"André van Tonder. Scheme Request for Implementation 45: Primitives for Expressing Iterative Lazy Algorithms. srfi.schemers.org/srfi-45. April, 2004. Describes the problems inherent in the promise data type of R5RS (also present in R6RS), and provides the alternate promise data type used in the stream primitives.",				"",				"Philip Wadler. “How to replace failure by a list of successes,” in Proceedings of the conference on functional programming languages and computer architecture, Nancy, France, 1985, pages 113–128. Describes the “list of successes” technique for implementing backtracking algorithms using streams.",				"",				"Philip Wadler, Walid Taha, and David MacQueen, “How to add laziness to a strict language without even being odd.” 1998 ACM SIGPLAN Workshop on ML, pp. 24ff. homepages.inf.ed.ac.uk/wadler/papers/lazyinstrict/lazyinstrict.ps. Describes odd and even styles of lazy evaluation, and shows how to add lazy evaluation to the strict functional language SML.",				"",				"All cited web pages visited during September 2007.",				"",				"Copyright",				"Copyright (C) Philip L. Bewig (2007). All Rights Reserved.",				"",				"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:",				"",				"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.",				"",				"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",				"",				"Several files related to this document are available from srfi.schemers.org/srfi-41: A version of this document suitable for printing is available at streams.pdf. The complete source corresponding to the three Appendices is available in files streams.ss, primitive.ss, and derived.ss. Samples from the text are available at samples.ss, and a test suite is available at r6rs-test.ss. Source code and tests for R5RS are available at r5rs.ss, and r5rs-test.ss.",				"",				"Editor: Michael Sperber"			],			"category" : "Collections-Streams-Srfi41"		},		"MCClassDefinitionTest" : {			"hash" : 3793664,			"definition" : "MCTestCase subclass: #MCClassDefinitionTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Monticello-Tests-Base'",			"comment" : [				"This class contains tests"			],			"category" : "Monticello-Tests-Base"		},		"TIncludesTest" : {			"hash" : 4344576,			"definition" : "Trait named: #TIncludesTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"MCSnapshot class" : {			"hash" : 294912,			"definition" : "MCSnapshot class\r\tinstanceVariableNames: ''",			"comment" : [				"MCSnapshot represents a list of entities compared to a given base entities. ",				"",				"It holds a list of definitions (instances of MCDefinition subclasses). It can install these entities or update a package."			],			"category" : "Monticello-Base"		},		"ArrayedCollection" : {			"hash" : 855808,			"definition" : "SequenceableCollection subclass: #ArrayedCollection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Base'",			"comment" : [				"I am an abstract collection of elements with a fixed range of integers (from 1 to n>=0) as external keys."			],			"category" : "Collections-Abstract-Base"		},		"CTLinkedStoragePoolCircularDoubly" : {			"hash" : 2286592,			"definition" : "CTLinkedStoragePoolCircular subclass: #CTLinkedStoragePoolCircularDoubly\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"MorphTreeMorphMultipleSelection" : {			"hash" : 2019840,			"definition" : "MorphTreeMorphSelection subclass: #MorphTreeMorphMultipleSelection\r\tinstanceVariableNames: 'selectedNodePathList'\r\tclassVariableNames: ''\r\tpackage: 'Morphic-Widgets-Tree'",			"comment" : [				"Multiple selections in a morphic based tree"			],			"category" : "Morphic-Widgets-Tree"		},		"SpAbstractPresenter" : {			"hash" : 612864,			"definition" : "Model subclass: #SpAbstractPresenter\r\tuses: TObservable\r\tinstanceVariableNames: 'owner adapter needRebuild eventHandler'\r\tclassVariableNames: ''\r\tpackage: 'Spec2-Core-Base'",			"comment" : [				"A base for all presenters. ",				"I define common behaviors for widget presenters and also for composable presenters (the ones an user regularly uses).",				"",				"From a Spec2 users, my key methods are ",				"- `SpAbstractPresenter>>#application` to get access to the application into which I play.",				"- `SpAbstractPresenter>>#initializeDialogWindow:` defines the default buttons that decorated a dialog. Subclasses can override it to be able to customize how dialog get decorated.",				"- `SpAbstractPresenter>>#initializeWindow:` is a hook to define the window title and extend.",				"- `SpAbstractPresenter>>#openWithSpec` to open the receiver with the default layout. ",				"- `SpAbstractPresenter>>#openWithSpec: aSpecLayout` to open the receiver with the specified layout."			],			"category" : "Spec2-Core-Base"		},		"CTBinaryTreeAbstract class" : {			"hash" : 2300160,			"definition" : "CTBinaryTreeAbstract class\r\tinstanceVariableNames: ''",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinaryTreeAbstract"		},		"LinkedListTest" : {			"hash" : 4360960,			"definition" : "TestCase subclass: #LinkedListTest\r\tuses: TAddTest - {#testTAddWithOccurrences. #testTAddTwice. #testTWriteTwice} + TEmptyTest + TIterateTest + TIterateSequencedReadableTest + TPrintTest + TAsStringCommaAndDelimiterSequenceableTest + TIndexAccess + TSequencedElementAccessTest + TSubCollectionAccess + (TConvertTest - {#testAsByteArray. #integerCollectionWithoutEqualElements}) + (TCopyPartOfSequenceable - {#testCopyEmptyMethod}) + (TCopySequenceableSameContents - {#testSortBy. #integerCollection}) + TCopySequenceableWithOrWithoutSpecificElements + TCopyTest + (TCopySequenceableWithReplacement - {#testCopyReplaceAllWithManyOccurrence. #collectionWith2TimeSubcollection}) + TBeginsEndsWith + TRemoveTest + TSetArithmetic + TIncludesWithIdentityCheckTest + TStructuralEqualityTest + TOccurrencesTest + TSortTest\r\tinstanceVariableNames: 'nextLink n list link1 link2 link3 link4 nonEmpty otherList link collectionWithoutNil nonEmpty1Element collectionWithoutEqualElements elementNotIn elementIn collection5Elements collectResult unsortedCollection sortedCollection'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Base'",			"comment" : [				"A set of test cases which thoroughly test functionality of the LinkedList class."			],			"category" : "Collections-Sequenceable-Tests-Base"		},		"TCopySequenceableWithReplacementForSorted" : {			"hash" : 4339968,			"definition" : "Trait named: #TCopySequenceableWithReplacementForSorted\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TOccurrencesForMultiplinessTest" : {			"hash" : 4348672,			"definition" : "Trait named: #TOccurrencesForMultiplinessTest\r\tuses: TOccurrencesTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinaryTreeNodeSplayHeap" : {			"hash" : 2313728,			"definition" : "CTBinaryTreeNode subclass: #CTBinaryTreeNodeSplayHeap\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-SplayHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-SplayHeap"		},		"Protocol class" : {			"hash" : 846080,			"definition" : "Protocol class\r\tinstanceVariableNames: ''",			"comment" : [				"A Protocol is a simple value holder representing a protocol.",				"It's composed of a name and a set of method selectors"			],			"category" : "Kernel-Protocols"		},		"Morph" : {			"hash" : 1672960,			"definition" : "Object subclass: #Morph\r\tinstanceVariableNames: 'bounds owner submorphs fullBounds color extension'\r\tclassVariableNames: 'CmdGesturesEnabled CycleHalosBothDirections DefaultYellowButtonMenuEnabled EmptyArray EventDispatcher HalosEnabled ShortcutsHandler'\r\tpackage: 'Morphic-Core-Kernel'",			"comment" : [				"A Morph (from the Greek \"shape\" or \"form\") is an interactive graphical object. General information on the Morphic system can be found at http://minnow.cc.gatech.edu/squeak/30. ",				"",				"Morphs exist in a tree, rooted at a World (generally a PasteUpMorph). The morphs owned by a morph are its submorphs. Morphs are drawn recursively; if a Morph has no owner it never gets drawn. To hide a Morph and its submorphs, set its #visible property to false using the #visible: method. ",				"",				"The World (screen) coordinate system is used for most coordinates, but can be changed if there is a TransformMorph somewhere in the owner chain. ",				"",				"My instance variables have accessor methods (e.g., #bounds, #bounds:). Most users should use the accessor methods instead of using the instance variables directly.",				"",				"Structure:",				"instance var \tType \t\t\tDescription ",				"bounds \t\t\tRectangle \t\tA Rectangle indicating my position and a size that will enclose \t\t\t\t\t\t\t\t\tme. ",				"owner \t\t\tMorph\t\t \tMy parent Morph, or nil for the top-level Morph, which is a",				" \t\t\t\tor nil\t\t\tworld, typically a PasteUpMorph.",				"submorphs \t\tArray \t\t\tMy child Morphs. ",				"fullBounds \t\tRectangle \t\tA Rectangle minimally enclosing me and my submorphs. ",				"color \t\t\tColor \t\t\tMy primary color. Subclasses can use this in different ways. ",				"extension \t\tMorphExtension Allows extra properties to be stored without adding a",				"\t\t\t\tor nil  \t\t\t\tstorage burden to all morphs. ",				"",				"By default, Morphs do not position their submorphs. Morphs may position their submorphs directly or use a LayoutPolicy to automatically control their submorph positioning.",				"",				"Although Morph has some support for BorderStyle, most users should use BorderedMorph if they want borders."			],			"category" : "Morphic-Core-Kernel"		},		"DTTreeNode class" : {			"hash" : 3493376,			"definition" : "DTTreeNode class\r\tinstanceVariableNames: ''",			"comment" : [				"I am a node from a tree used to show results in DrTestUI."			],			"category" : "DrTests-Model"		},		"TRemoveByIndexTest" : {			"hash" : 4351232,			"definition" : "Trait named: #TRemoveByIndexTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTUnbalancedSetTest" : {			"hash" : 2311168,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTUnbalancedSetTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet-Tests'",			"comment" : [				"A CTUnbalancedSetTest is a test class for testing the behavior of CTUnbalancedSet"			],			"category" : "Containers-RedBlackSet-Tests"		},		"CTSBRAL" : {			"hash" : 2297344,			"definition" : "SkewBinaryCanonicalNumber subclass: #CTSBRAL\r\tinstanceVariableNames: 'lastAddedObject'\r\tclassVariableNames: ''\r\tpackage: 'Containers-SBRAL'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tlastAddedObject:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-SBRAL"		},		"IntervalTest" : {			"hash" : 4364032,			"definition" : "CollectionRootTest subclass: #IntervalTest\r\tuses: TSortTest - {#testSort. #testSortUsingSortBlock} + TCloneTest + TIncludesWithIdentityCheckTest + TSequencedElementAccessTest + TIterateSequencedReadableTest + TSequencedConcatenationTest + TSubCollectionAccess + TAsStringCommaAndDelimiterSequenceableTest + TIndexAccess + TPrintOnSequencedTest + TConvertTest + (TCopySequenceableWithReplacement - {#testCopyReplaceAllWithManyOccurrence. #collectionWith2TimeSubcollection}) + TCopySequenceableWithOrWithoutSpecificElements + (TCopySequenceableSameContents - {#testShuffled}) + (TCopyPartOfSequenceable - {#testCopyEmptyMethod}) + TCopyTest + TBeginsEndsWith + TConvertAsSortedTest + TSequencedStructuralEqualityTest + TOccurrencesTest\r\tinstanceVariableNames: 'empty nonEmpty one elementIn elementNotIn subCollectionNotIn collectionOfFloat anotherCollection nonEmpty1Element subCollection collectionWithSubCollection subCollectionInNonEmpty collectionWithoutNil collectResult collectionOfLargeIntegers'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Base'",			"comment" : [				"SUnit tests for intervals"			],			"category" : "Collections-Sequenceable-Tests-Base"		},		"MTObservedDataset" : {			"hash" : 2280448,			"definition" : "Object subclass: #MTObservedDataset\r\tinstanceVariableNames: 'tree metadata'\r\tclassVariableNames: ''\r\tpackage: 'MethodTracker'",			"comment" : [				"I am a container of `MTObservedDatarow`, also I compute some statistics."			],			"category" : "MethodTracker"		},		"TIncludesWithIdentityCheckTest" : {			"hash" : 4345088,			"definition" : "Trait named: #TIncludesWithIdentityCheckTest\r\tuses: TIncludesTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinaryTreeEmptyUnbalanced" : {			"hash" : 2308608,			"definition" : "CTBinaryTreeEmpty subclass: #CTBinaryTreeEmptyUnbalanced\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-RedBlackSet"		},		"Stack" : {			"hash" : 1144064,			"definition" : "LinkedList subclass: #Stack\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Stack-Base'",			"comment" : [				"I implement a simple Stack. #push: adds a new object of any kind on top of the stack. #pop returns the first element and remove it from the stack. #top answer the first element of the stack without removing it."			],			"category" : "Collections-Stack-Base"		},		"CTHeapQ" : {			"hash" : 2301440,			"definition" : "Object subclass: #CTHeapQ\r\tinstanceVariableNames: 'heap indexes tally'\r\tclassVariableNames: ''\r\tpackage: 'Containers-HeapQ'",			"comment" : [				"I am a binary heap and mimic the one found in the Python standard library.",				"! Heapify",				"Consider the following shuffled array of 63 elements:",				"${example:name=CTHeapQTest>>#test100ShuffledInterval|previewShow=#gtBoxesFor:|noCode=}$",				"that can be heapified as ${example:name=CTHeapQTest>>#test100ShuffledIntervalRawHeapSlot|previewShow=#gtBoxesFor:|noCode=}$",				"and visualized as a tree",				"${example:name=CTHeapQTest>>#test100ShuffledIntervalHeapified|noCode=|previewShow=#gtLiveFor:|previewHeight=800}$",				"and the same heap can also be visualized as \"bubbles\" in order to emphasize the __heap invariant__:",				"${example:name=CTHeapQTest>>#test100ShuffledIntervalHeapified|noCode=|previewShow=#gtBubblesLiveFor:|previewHeight=800}$",				""			],			"category" : "Containers-HeapQ"		},		"CTLinkedStoragePoolCircular" : {			"hash" : 2286080,			"definition" : "CTLinkedStoragePool subclass: #CTLinkedStoragePoolCircular\r\tinstanceVariableNames: 'head'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\thead:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"SmallDictionary" : {			"hash" : 1134848,			"definition" : "Collection subclass: #SmallDictionary\r\tinstanceVariableNames: 'keys values size'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Dictionaries'",			"comment" : [				"`SmallDictionary` is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an `#empty` message which \"empties\" the collection but may hang on to the original elements (so it could collect garbage). Without `#empty` we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and `#empty`. Be careful, I cannot have *nil* as key. ",				"",				"### Public API and Key Messages",				"",				"- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue \t\tallow to add an element.  ",				"- #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock \t\tallow to access my values.",				"- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: \t\tallow to iterate on me effectively",				"",				"### Examples ",				"",				"",				"To create a dictiony with indexes as key: ",				"",				"```",				"SmallDictionary withAll: #(7 3 1 3)   \t\t",				"\">>>  a SmallDictionaryDictionary(1->7 2->3 3->1 4->3 \"",				"```",				"To use Objects as key (here symbols): ",				"",				"```",				"\tcolors := SmallDictionary new ",				"\t\t\t\tat: #yellow put: Color yellow; ",				"\t\t\t\tat: #blue put: Color blue;",				"\t\t\t\tat: #red put: Color red;",				"\t\t\t\tyourself.",				"\t\t\t\t",				"\tcolors at: #yellow. \t\"returns:  Color yellow\"",				"\tcolors keys          \t\t\"returns: a Set(#blue #yellow #red)\"",				"\tcolors values     \t\t\"returns:  {Color blue. Color yellow. Color red}\"",				"",				"\tcolors empty \t\"a SmallDictionary()\"",				"```",				"",				"### Internal Representation and Key Implementation Points.",				"Instance Variables",				"- keys:\t\t<Array>\t\tArray of keys (we don't use Associations for our key value pairs)",				"- size:\t\t\t<Integer>\tSize of the dictionary",				"- values:\t\t<Array>\t\tArray of our values",				"",				"",				"    Implementation Points"			],			"category" : "Collections-Unordered-Dictionaries"		},		"FLSimpleStack" : {			"hash" : 745472,			"definition" : "Object subclass: #FLSimpleStack\r\tinstanceVariableNames: 'array slotIndex'\r\tclassVariableNames: ''\r\tpackage: 'Fuel-Core-Collections'",			"comment" : [				"FLSimpleStack is a simple stack used in Fuel to avoid a recursion while traversing the graph to serialize. While analizing the content of an object (inst vars) we can encounter simple objects (direct string representation) or complex objects (composite). In the latter case we start analizing those instVars.",				"",				"So... Imagine object X with two instVars Y and Z. Imagine the method of the traverse is called #analye:.  So you do #analize: X.  Then, in such method you check whether X has regular pointers to regular objects, and if true, you analize them. So in this case you would send #analyze: Y and #analize: Z, generating the recursion. Right ?  Notice that the time between analyse: Y and analyse: Z is dependent on the graph that is attached to Y. Y can have objects that have further objects etc. So leaving X aside, Y can be the first object to serialize and Z the last.",				"",				"With this FLSimpleStack, instead of sending #analyze: Y and #analize: Z  what Fuel does is just to do a push on a stack:   #push: Y  and #push: Z. And then we are done with X, so we pop from the stack and we continue with the next object (at some point in the future we will pop Y and Z) When there are no more objects in the stack it means we are done. "			],			"category" : "Fuel-Core-Collections"		},		"CTLinkedStoragePoolStack" : {			"hash" : 2293760,			"definition" : "CTLinkedStoragePool subclass: #CTLinkedStoragePoolStack\r\tinstanceVariableNames: 'top'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LinkedStoragePool'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\ttop:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LinkedStoragePool"		},		"TCopyPartOfSequenceable" : {			"hash" : 4336896,			"definition" : "Trait named: #TCopyPartOfSequenceable\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"ZnDefaultServerDelegate class" : {			"hash" : 1408512,			"definition" : "ZnDefaultServerDelegate class\r\tinstanceVariableNames: ''",			"comment" : [				"I am ZnDefaultServerDelegate.",				"I function as a delegate for ZnServer, implementing #handleRequest:",				"",				"I implement responses to the following prefixes:",				"",				"/echo - an echo text of request information for debugging purposes",				"/dw-bench - a dynamic html page for benchmarking purposes",				"/unicode - a unicode test page",				"/random - a random string (/random/32 for a specific size)",				"/bytes - bytes according to a pattern (/bytes/32 for a specific size)",				"/favicon.ico - a Zn favicon",				"/status - a server status page",				"/error - force server errors",				"/session - a simpler session based counter",				"/help - lists all page prefixes",				"/ - an html welcome page",				"",				"Without any matches, I respond with a page not found.",				"",				"I can be reused without any default handlers mapped using #empty and configured using #map:to: where the second argument can be a block.",				"",				"Part of Zinc HTTP Components."			],			"category" : "Zinc-HTTP-Client-Server"		},		"FloatArrayTest" : {			"hash" : 4422144,			"definition" : "CollectionRootTest subclass: #FloatArrayTest\r\tuses: TCreationWithTest + TSequencedStructuralEqualityTest + TSequencedConcatenationTest + TSetArithmetic + TAsStringCommaAndDelimiterSequenceableTest + TPrintOnSequencedTest + TBeginsEndsWith + TCloneTest + (TConvertTest - {#testAsByteArray. #integerCollectionWithoutEqualElements}) + TConvertAsSortedTest + (TConvertAsSetForMultiplinessIdentityTest - {#testAsIdentitySetWithEqualsElements. #testAsIdentitySetWithIdentityEqualsElements. #testAsIdentitySetWithoutIdentityEqualsElements. #test0FixtureAsSetForIdentityMultiplinessTest}) + TCopyPartOfSequenceable + TCopyPartOfSequenceableForMultipliness + TCopySequenceableSameContents + TCopySequenceableWithOrWithoutSpecificElements + TCopySequenceableWithReplacement + TCopyTest + (TIncludesWithIdentityCheckTest - {#testIdentityIncludesNonSpecificComportement. #testIdentityIncludes. #test0FixtureIncludeWithIdentityTest}) + (TIndexAccess - {#testIdentityIndexOf. #testIdentityIndexOfIAbsent}) + (TIndexAccessForMultipliness - {#testIdentityIndexOfIAbsentDuplicate. #testIdentityIndexOfDuplicate}) + TIterateSequencedReadableTest + TPutTest + TPutBasicTest + TReplacementSequencedTest + TSequencedElementAccessTest + TSortTest + TSubCollectionAccess\r\tinstanceVariableNames: 'nonEmpty5ElementsNoDuplicate empty elementNotIn elementTwiceIn collectionWithEqualElements nonEmpty1Element collectionWithSameAtEndAndBegining collectionWith1TimeSubcollection collectionWith2TimeSubcollection collectionNotIncluded nonEmptySubcollection elementInNonEmpty replacementCollectionSameSize sortedCollection'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Tests-Arrayed'",			"comment" : [				"These tests are used to assert that FloatArrayPlugin has same results as Float asIEEE32BitWord"			],			"category" : "Collections-Tests-Arrayed"		},		"TIterateTest" : {			"hash" : 4347136,			"definition" : "Trait named: #TIterateTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"I'm testing that high-order iterators are working.",				"Note however that I do not pay attention to the order of the elements.",				"Hence, my doTest is designed to not checking that. ",				"TIterateSequenceableTest is about this distinction and as such will not be applicable to test",				"Set, Bag, Dictionary. ",				"",				""			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinomialHeap class" : {			"hash" : 2302464,			"definition" : "CTBinomialHeap class\r\tinstanceVariableNames: ''",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinomialHeap"		},		"ZnRequest class" : {			"hash" : 1417728,			"definition" : "ZnRequest class\r\tinstanceVariableNames: ''",			"comment" : [				"I am ZnRequest, representing an HTTP Request, ",				"consisting of a request line, headers and an optional entity (body).",				"I am a ZnMessage.",				"I can be used for generating and parsing.",				"",				"Part of Zinc HTTP Components."			],			"category" : "Zinc-HTTP-Core"		},		"MethodDictionaryTest" : {			"hash" : 4389376,			"definition" : "TestCase subclass: #MethodDictionaryTest\r\tuses: TIncludesTest + TDictionaryKeysValuesAssociationsAccess + TDictionaryRemovingTest\r\tinstanceVariableNames: 'nonEmptyDict'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Dictionaries'",			"comment" : [				"SUnit tests for MethodDictionary"			],			"category" : "Collections-Unordered-Tests-Dictionaries"		},		"TIterateSequencedReadableTest" : {			"hash" : 4346624,			"definition" : "Trait named: #TIterateSequencedReadableTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"MorphTreeMorphSelection" : {			"hash" : 2019328,			"definition" : "Object subclass: #MorphTreeMorphSelection\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Morphic-Widgets-Tree'",			"comment" : [				"Superclass for selections in a morphic based tree"			],			"category" : "Morphic-Widgets-Tree"		},		"SetTest" : {			"hash" : 4394496,			"definition" : "CollectionRootTest subclass: #SetTest\r\tuses: TAddForUniquenessTest + TIncludesWithIdentityCheckTest + TCloneTest + TCopyTest + TRemoveTest + TGrowableTest + TStructuralEqualityTest + TPrintTest + TAsStringCommaAndDelimiterTest + TConvertTest + TConvertAsSortedTest + TConcatenationEqualElementsRemovedTest + TOccurrencesTest + (TCreationWithTest - {#testOfSize. #collectionClass}) + (TSetArithmetic - {#collectionClass})\r\tinstanceVariableNames: 'full empty collectResult emptyButAllocatedWith20 elementNotIn collectionOfFloat collectionIncluded nonEmpty1element withoutEqualElements collection5Elements collectionWith3Elements collectionOfNonIdentical'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Sets'",			"comment" : [				"This is the unit test for the class Set. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: ",				"\t- http://www.c2.com/cgi/wiki?UnitTest",				"\t- there is a chapter in the PharoByExample book (http://pharobyexample.org/)",				"\t- the sunit class category"			],			"category" : "Collections-Unordered-Tests-Sets"		},		"TCopyTest" : {			"hash" : 4340480,			"definition" : "Trait named: #TCopyTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"Tests whether a copied object contains the same elements than its source.",				"Note that the order is not garanteed -- see TEqualityTest for that. ",				""			],			"category" : "Collections-Abstract-Tests-Traits"		},		"ClyDataSource class" : {			"hash" : 6218240,			"definition" : "ClyDataSource class\r\tinstanceVariableNames: ''",			"comment" : [				"I am a root of fast table data source classes which adopt Calypso query result to FastTable interface.",				"",				"My subclasses represent concrete kind of underlying tree structure: all items can be initialy expanded or initialy collapsed.",				"To create my instances use following expression:",				"\tdataSource := ClyCollapsedDataSource on: aQuery.",				"It just creates instance of data source without executing given query.",				"Query is opened by ClyQueryView when you pass data source to it: ",				"\tqueryView dataSource: aDataSource ",				"It ask data source to open for itself:",				"\tdataSource openOn: queryView",				"It executes the query and retrieves cursor to access result items in optimized way.",				"Also it subscribes on result changes. So the query view is updated when result is changed.",				"When data source is not needed anymore it should be closed:",				"\tdataSource close",				"",				"I represent actual elements of fast table by ClyDataSourceItem.",				"\tdataSource elementAt: 1 \"=>aDataSourceItem\"  ",				"Management of children is implemented by my subclasses. According to type of tree structure they implement following methods: ",				"- numberOfRows",				"- elementAt: rowIndex",				"- globalPositionOf: childDataSourceItem",				"- countChildrenOf: aDataSourceItem",				"- isItemHasChildren: aDataSourceItem",				"- definesChildren",				"- collapse: aDataSourceItem",				"- expand: aDataSourceItem",				"- isExpanded: aDataSourceItem",				"- updateExpandingItems",				"Children are represented by data sources too. My parentItem and depth variables point to the position in full tree.",				"You can ask global position in the tree using: ",				"\tdataSource globalPositionOf: childDataSourceItem",				"It should return global row index in the table of given children item.",				"",				"I implement query interface to find items",				"- findItemsWhere: conditionBlock ",				"- findItemsWith: actualObjects ",				"- findItemsSimilarTo: dataSourceItems",				"",				"My instances are subscribed on ClyEnvironmentChanged event which happen when underlying query result is changed.",				"In case of the event I update my children structure and refresh table:",				"- itemsChanged",				"Update is performed in special logic to prevent multiple updates during complex system changes.",				"First I check if I am already dirty. In that case I do nothing.",				"Otherwise I mark myself as dirty and defer actual update using UpdateScheduler which performs update in low priority process when there is a time. So if complex system change is initiated from UI operation (which is common scenario) I will be updated only when full operation will be finished. And it will be always single update independently how many changes operation produces with the system. ",				"For details look at ClyDataSourceUpdateScheduler comments.",				"",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tquery:\t\t<ClyQuery>",				"\tqueryView:\t\t<ClyQueryView>",				"\titemCursor:\t\t<ClyBrowserQueryCursor>",				"\tparentItem:\t\t<ClyDataSourceItem>",				"\tdepth:\t\t<Integer>",				"\tdirty: <Boolean>",				"\tlastFilteredDataSource: <ClyDataSource>"			],			"category" : "Calypso-Browser-DataSource"		},		"RBCondition class" : {			"hash" : 3689472,			"definition" : "RBCondition class\r\tinstanceVariableNames: ''",			"comment" : [				"I am a refactoring condition for doing a precondition check for refactoring operations.",				"",				"A precondition check returns true or false and is used by refactoring operations to check whether the operation is applicable to the target entity (class or method refactoring).",				"",				"You can set the block code used for testing the condition (#withBlock:).",				"And I define some factory methods on my class side for creating instances of me, for some typically usage. ",				"",				"For example: ",				"This creates a condition checking if the class named #Morph implements a selector named #drawOn:",				"(RBCondition definesSelector:#drawOn: in: (RBClass existingNamed:#Morph)).",				"",				"Most users of me are refactoring operations and use my methods on the class side for creating instances."			],			"category" : "Refactoring-Core-Conditions"		},		"MetacelloAbstractVersionConstructor" : {			"hash" : 1470208,			"definition" : "MetacelloAbstractConstructor subclass: #MetacelloAbstractVersionConstructor\r\tinstanceVariableNames: 'root configuration project attributeMap attributeOrder symbolicVersion currentContext'\r\tclassVariableNames: ''\r\tpackage: 'Metacello-Core-Constructors'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tattributeMap:\t\t<Object>",				"\tattributeOrder:\t\t<Object>",				"\tconfiguration:\t\t<Object>",				"\tcurrentContext:\t\t<Object>",				"\tproject:\t\t<Object>",				"\troot:\t\t<Object>",				"\tsymbolicVersion:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Metacello-Core-Constructors"		},		"RSTextExtents" : {			"hash" : 6999808,			"definition" : "RSObject subclass: #RSTextExtents\r\tinstanceVariableNames: 'width height x_advance y_advance x_bearing y_bearing'\r\tclassVariableNames: 'empty'\r\tpackage: 'Roassal3-Shapes-Text'",			"comment" : [				"Extents for RSLabel"			],			"category" : "Roassal3-Shapes-Text"		},		"FileLocator class" : {			"hash" : 1267456,			"definition" : "FileLocator class\r\tinstanceVariableNames: ''",			"comment" : [				"I am a late-bound reference. I refer to a file or directory in relation to a well-known location on the filesystem, called an origin. When asked to perform a concrete operation, I look up the current location of my origin, and resolve my path against it. To add your own origin(s), see FileSystemResolver.",				"",				"Usage",				"----------",				"FileLocator vmDirectory parent pathString",				"\t> '/Applications'",				"",				"",				"FileLocator desktop.",				"FileLocator desktop basename.",				"",				"FileLocator home basename.",				"FileLocator image.",				"FileLocator vmBinary asAbsolute pathString ",				"\t>  '/Applications/CogVM.app/Contents/MacOS/CogVM'",				"FileLocator vmBinary pathString ",				"\t> '/Applications/CogVM.app/Contents/MacOS/CogVM'",				"\t\t",				"",				"",				"",				"",				"Implementation",				"------------------------",				"origin ",				"\tA symbolic name for base reference I use to resolve myself.",				"",				"path",				"\tA relative path that is resolved against my origin\"",				"\t",				"\t"			],			"category" : "FileSystem-Core-Public"		},		"TEmptyTest" : {			"hash" : 4342016,			"definition" : "Trait named: #TEmptyTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"I group a set of tests testing whether a collection is empty.",				"I do not do any assymption on the elements being added since it would",				"bind me to know how to access it. "			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinomialHeap" : {			"hash" : 2302720,			"definition" : "Object subclass: #CTBinomialHeap\r\tinstanceVariableNames: 'representation'\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinomialHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\trepresentation:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinomialHeap"		},		"HeapTest" : {			"hash" : 4363520,			"definition" : "CollectionRootTest subclass: #HeapTest\r\tuses: TAddTest + TGrowableTest + TConvertTest + TConvertAsSortedTest + TConvertAsSetForMultiplinessIdentityTest + TCopyTest + TSetArithmetic + TRemoveForMultiplenessTest + TOccurrencesForMultiplinessTest + (TCreationWithTest - {#testOfSize}) + TIncludesWithIdentityCheckTest\r\tinstanceVariableNames: 'collectionWithElement otherCollection nonEmpty empty elementNotIn collectResult expectedElementByDetect speciesClass elementTwiceIn doWithoutNumber element expectedSizeAfterReject collectionNotIncluded nonEmpty5ElementsWithoutDuplicate sameAtEndAndBegining nonEmpty1Element indexArray subCollection duplicateElement collectionWithDuplicateElement collectionWith4Elements stringCollection'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Base'",			"comment" : [				"SUnit tests for heap collections"			],			"category" : "Collections-Sequenceable-Tests-Base"		},		"TDictionaryCopyingTest" : {			"hash" : 4390400,			"definition" : "Trait named: #TDictionaryCopyingTest\r\tuses: TCloneTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Unordered-Tests-Traits"		},		"CTBinomialTree" : {			"hash" : 2304768,			"definition" : "Object subclass: #CTBinomialTree\r\tinstanceVariableNames: 'content children'\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinomialHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tchildren:\t\t<Object>",				"\tcontent:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinomialHeap"		},		"MailMessage class" : {			"hash" : 3680768,			"definition" : "MailMessage class\r\tinstanceVariableNames: ''",			"comment" : [				"I represent an Internet mail or news message.",				"",				"\ttext - the raw text of my message",				"\tbody - the body of my message, as a MIMEDocument",				"\tfields - a dictionary mapping lowercased field names into collections of MIMEHeaderValue's",				"\tparts - if I am a multipart message, then this is a cache of my parts"			],			"category" : "Network-Mail"		},		"OrderedCollectionTest" : {			"hash" : 4364544,			"definition" : "CollectionRootTest subclass: #OrderedCollectionTest\r\tuses: TSortTest + TEmptySequenceableTest + TAddTest + TSequencedElementAccessTest + TIncludesWithIdentityCheckTest + TCloneTest + TSetArithmetic + TRemoveForMultiplenessTest + TCreationWithTest + TCopyTest + TPutBasicTest + TIterateSequencedReadableTest + TSubCollectionAccess + TIndexAccess + TCopySequenceableWithReplacement + TCopyPartOfSequenceable + TCopySequenceableSameContents + (TCopySequenceableWithOrWithoutSpecificElements - {#testForceToPaddingWith. #testForceToPaddingStartWith}) + TPrintOnSequencedTest + TAsStringCommaAndDelimiterSequenceableTest + TConvertTest + TConvertAsSetForMultiplinessIdentityTest + TSequencedConcatenationTest + TBeginsEndsWith + TReplacementSequencedTest + TIndexAccessForMultipliness + TCopyPartOfSequenceableForMultipliness + TConvertAsSortedTest + TPutTest + TSequencedStructuralEqualityTest + TOccurrencesForMultiplinessTest + TEnumeratingTest\r\tinstanceVariableNames: 'empty nonEmpty collectResult emptyButAllocatedWith20 otherCollection indexCollection collectionWithElement collectionOfFloat elementNotIn indexArray withoutEqualElements duplicateElement collectionWithDuplicateElement collection5Elements collectionWith4Elements collectionOfCollectionsOfInts collectionOfCollectionsOfStrings withCharacters simpleCollection collectionOfString collectionWithSameBeginingEnd'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Ordered'",			"comment" : [				"These test cases demonstrate addition of items into an OrderedCollection as well as item removal.",				"",				"Some of the assertions are quite complicated and use a lot of collection protocol. Such methods do not test one single method, but protocol in general."			],			"category" : "Collections-Sequenceable-Tests-Ordered"		},		"CTBinaryTreeAbstract" : {			"hash" : 2300416,			"definition" : "Object subclass: #CTBinaryTreeAbstract\r\tinstanceVariableNames: 'representation'\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinaryTreeAbstract'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\trepresentation:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinaryTreeAbstract"		},		"CTBinaryTreeEmpty" : {			"hash" : 2299392,			"definition" : "CTBinaryTreeElement subclass: #CTBinaryTreeEmpty\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinaryTreeAbstract'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinaryTreeAbstract"		},		"CoFilter class" : {			"hash" : 6478848,			"definition" : "CoFilter class\r\tinstanceVariableNames: ''",			"comment" : [				"The filters are first class objects that knows what is the filter operation and also can compare with each other to see if they are narrowing or not the search. ",				"This information is used to know if the fetcher should be reset or not, if we are just narrowing the same query, we don't need to renarrow the fetcher."			],			"category" : "HeuristicCompletion-Model-Core"		},		"RBMethodNameTest" : {			"hash" : 4995328,			"definition" : "TestCase subclass: #RBMethodNameTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Refactoring-Tests-Core-Base'",			"comment" : [				"This class contains tests"			],			"category" : "Refactoring-Tests-Core-Base"		},		"Context" : {			"hash" : 9216,			"definition" : "Object variableSubclass: #Context\r\tinstanceVariableNames: 'sender pc stackp method closureOrNil receiver'\r\tclassVariableNames: 'PrimitiveFailToken SpecialPrimitiveSimulators TryNamedPrimitiveTemplateMethod'\r\tpackage: 'Kernel-Methods'",			"comment" : [				"Instance variables:",				"\treceiver: <Object> (self)",				"\tclosureOrNil: <BlockClosure|nil> ",				"\t\tnil if I'm a method context",				"\t\tthe blockClosure being executed if I'm a block context",				"\tmethod <CompiledMethod> ",				"\t\tmethod being executed if I'm a method context",				"\t\tmethod holding the block if I'm a block context",				"\tvariable fields: <Object> temporary variables (including arguments)",				"",				"My instances hold all the dynamic state associated with the execution of either a method activation resulting from a message send or a block activation resulting from a block evaluation.",				"\t",				"MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.",				"",				"MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal."			],			"category" : "Kernel-Methods"		},		"StackTest" : {			"hash" : 4368640,			"definition" : "TestCase subclass: #StackTest\r\tuses: TEmptyTest - {#testIfNotEmptyifEmpty. #testIfEmpty. #testNotEmpty} + (TCloneTest - {#testCopyNonEmpty})\r\tinstanceVariableNames: 'empty nonEmpty'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Stack-Tests-Base'",			"comment" : [				"SUnit tests for stacks"			],			"category" : "Collections-Stack-Tests-Base"		},		"BagTest" : {			"hash" : 4390912,			"definition" : "CollectionRootTest subclass: #BagTest\r\tuses: TAddTest + TIncludesWithIdentityCheckTest + TCloneTest + TCopyTest + TSetArithmetic + TConvertTest + TAsStringCommaAndDelimiterTest + TRemoveForMultiplenessTest + TPrintTest + TConvertAsSortedTest + TConvertAsSetForMultiplinessTest + TConcatenationTest + TStructuralEqualityTest + (TCreationWithTest - {#testOfSize}) + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'empty nonEmpty collectResult emptyButAllocatedWith20 collectionWithElement collectionIn collectionNotIn collectionOfString elementNotIn collectionWithCharacters otherCollectionWithoutEqualElements collectionWithoutNilMoreThan5'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Bags'",			"comment" : [				"SUnit tests for bags"			],			"category" : "Collections-Unordered-Tests-Bags"		},		"TAsStringCommaAndDelimiterSequenceableTest" : {			"hash" : 4332288,			"definition" : "Trait named: #TAsStringCommaAndDelimiterSequenceableTest\r\tuses: TAsStringCommaAndDelimiterTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"FLIndexStreamTest" : {			"hash" : 5126912,			"definition" : "TestCase subclass: #FLIndexStreamTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Fuel-Tests-Core-Streams'",			"comment" : [				"SUnit tests for index streams"			],			"category" : "Fuel-Tests-Core-Streams"		},		"TAsStringCommaAndDelimiterTest" : {			"hash" : 4331776,			"definition" : "Trait named: #TAsStringCommaAndDelimiterTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinaryTreeEmptySplayHeap" : {			"hash" : 2313216,			"definition" : "CTBinaryTreeEmpty subclass: #CTBinaryTreeEmptySplayHeap\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-SplayHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-SplayHeap"		},		"FLSerialization" : {			"hash" : 744448,			"definition" : "Object subclass: #FLSerialization\r\tinstanceVariableNames: 'encoder root clusters analyzer'\r\tclassVariableNames: ''\r\tpackage: 'Fuel-Core-Base'",			"comment" : [				"I implement the algorithm for serializing an object graph on a stream. FLSerializer known how to build instances of me."			],			"category" : "Fuel-Core-Base"		},		"CTBinaryTreeNodeBalanced" : {			"hash" : 2307072,			"definition" : "CTBinaryTreeNodeUnbalanced subclass: #CTBinaryTreeNodeBalanced\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-RedBlackSet"		},		"GVector class" : {			"hash" : 6912768,			"definition" : "GVector class\r\tuses: TGWithCoordinates classTrait\r\tinstanceVariableNames: ''",			"comment" : [				"Description",				"--------------------",				"",				"I represent a geometric vector. I have a state close to the state of a GPoint but a vector only represent a direction and a length.",				"",				"My direction will go from the origin of the plan ( (0, 0) in a 2D plan) to my coordinates. My length will be defined by my coordinates.",				"",				"Examples",				"--------------------",				"",				"\t\"Instance creation\"",				"\tGVector withCollection: #(1 2).\t \"a GVector(1,2)\"",				"\t",				"\tGVector coordinates: (GCoordinates withCollection: #(1 3)). \t\"a GVector(1,3)\"",				"\t",				"\t(GCoordinates withCollection: #(1 3)) asGVector.\t\"a GVector(1,3)\"",				"\t",				"\t#(1 2) asGVector.\t\"a GVector(1,2)\"\t",				"\t\t\t",				"\t\"Arithmetic\"\t",				"\t#(3 5) asGVector length.\t\"5.830951894845301\"",				" ",				"Internal Representation and Key Implementation Points.",				"--------------------",				"",				"    Instance Variables",				"\tcoordinates:\t\t<GCoordinates> \tCoordinates defining my direction and length."			],			"category" : "Geometry-Core"		},		"TSequencedStructuralEqualityTest" : {			"hash" : 4356352,			"definition" : "Trait named: #TSequencedStructuralEqualityTest\r\tuses: TStructuralEqualityTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"String class" : {			"hash" : 806400,			"definition" : "String class\r\tinstanceVariableNames: ''",			"comment" : [				"A String is an indexed collection of Characters. Class String provides the abstract super class for ByteString (that represents an array of 8-bit Characters) and WideString (that represents an array of  32-bit characters).  In the similar manner of LargeInteger and SmallInteger, those subclasses are chosen accordingly for a string; namely as long as the system can figure out so, the String is used to represent the given string.",				"",				"Strings support a vast array of useful methods, which can best be learned by browsing and trying out examples as you find them in the code.",				"",				"## Substrings and slicing",				"",				"A number of selectors can be used to get substrings. `String>>#lines` will return a colection containing substrings separated by `\\\\n`, `\\\\r`, or `\\\\r\\\\n`; `String>>#trim` will return a substring with whitespace removed from the beginning and end. ",				"",				"Obtaining parts of a string can also be achieved using numbered indices, also known as slicing. There are shortcut methods for some common operations that are often inherited from `SequenceableCollection` inclusing `allButFirst`, `allButLast`, `first`, or `last`.",				"",				"```",				"s := 'abcdefg'.",				"",				"s first. \"$a\"",				"s allButFirst.  \"bcdefg\"",				"",				"s last.  \"$g\"",				"s allButLast.  \"abcdef\"",				"",				"\"pass a number argument to change the number of characters removed/kept\"",				"",				"s first: 2.  \"ab\"  ",				"s allButFirst: 2.  \"cdefg\"",				"",				"s last: 2.  \"fg\"",				"s allButLast: 2.  \"abcde\"",				"```",				"",				"To get the middle of a string use `SequenceableCollection>>#copyFrom:to:`",				"",				"```",				"s := 'abcdefg'.",				"s copyFrom: 2 to: 6. \"bcdef\"",				"```",				"",				"To count back from the end of the string use the `size` selector",				"```",				"s := 'abcdefg'",				"s copyFrom: 2 to: s size - 1 ",				"```",				"",				"## Formatting",				"",				"Strings have a `String>>#format:` selector that can be used for interpolating other objects.",				"The \"string template\" can either have numbers between curly bracket characters (`{` and `}`)",				"where the argument to format is a collection where values are indexed by number. Or pass in",				"a `HashedCollection` where the placeholders are the keys of the collection",				"```",				"'ab {1} ef {2}' format: {'cd'. 'gh'}.  \"ab cd ef gh\"",				"",				"'ab {one} ef {two}' format: ",				"    (Dictionary with: #one -> 'cd' with: #two -> 'gh').",				"```",				"",				"`String>>#contractTo:` is also useful for shortening strings to a particular length by replacing ",				"middle characters.",				"",				"## Copying and Streaming",				"As well as the `format:` selector it is possible to build up a string using contatenation with",				"`SequenceableCollection>>#,` ",				"",				"```",				"a := 'abc'.",				"b := ' easy as '.",				"c := '123'.",				"a , b , c.  \"abc easy as 123\"",				"```",				"Or alternatively, construct a string from a stream using `SequenceableCollection class>>#streamContents:`.",				"",				"```",				"s := String streamContents: [ :stream |",				"\t  stream nextPutAll: 'abcdefg';",				"\t  space;",				"\t  nextPutAll: '123456';",				"\t  space.",				"\t  '7890' putOn: stream. ].  \"abcdefg 123456 7890\"",				"```",				"",				"## Finding/Searching",				"",				"Simple reqular expression type searching can be performed using `String>>#match:`, which has similar",				"symantics as \"globbing\" in a shell. The reciever is a template string where the `#` character matches any single character and the `*` character matches any number of characters. A `Boolean` object is returned. ",				"```",				"'#abb*cdch' match: '4abbadskfakjdfadiadfnvcdch'  \"true\"",				"```",				"",				"For more complex matching use `String>>#matchesRegex:` which is an extension method implmented by `RxMatcher`. See the help documentation on regular expressions `HelpBrowser openOn: RegexHelp.`"			],			"category" : "Collections-Strings-Base"		},		"CTUnbalancedSet" : {			"hash" : 2309632,			"definition" : "CTBinaryTreeAbstract subclass: #CTUnbalancedSet\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-RedBlackSet"		},		"CTOrderPreservingTreeTest" : {			"hash" : 2270720,			"definition" : "TestCase subclass: #CTOrderPreservingTreeTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-OrderPreservingTree-Tests'",			"comment" : [				"A CTOrderPreservingTreeTest is a test class for testing the behavior of CTOrderPreservingTree"			],			"category" : "Containers-OrderPreservingTree-Tests"		},		"CTBinaryTreeElement" : {			"hash" : 2298880,			"definition" : "CTDoubleValueLink subclass: #CTBinaryTreeElement\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinaryTreeAbstract'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinaryTreeAbstract"		},		"CTRedBlackSet" : {			"hash" : 2310144,			"definition" : "CTUnbalancedSet subclass: #CTRedBlackSet\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-RedBlackSet"		},		"CTBinaryTreeNodeLeftistHeap" : {			"hash" : 2316288,			"definition" : "CTBinaryTreeNode subclass: #CTBinaryTreeNodeLeftistHeap\r\tinstanceVariableNames: 'rank'\r\tclassVariableNames: ''\r\tpackage: 'Containers-LeftistHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\trank:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Containers-LeftistHeap"		},		"CTSplayHeap" : {			"hash" : 2312704,			"definition" : "CTBinaryTreeAbstract subclass: #CTSplayHeap\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-SplayHeap'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-SplayHeap"		},		"ArrayTest" : {			"hash" : 4363008,			"definition" : "CollectionRootTest subclass: #ArrayTest\r\tuses: TEmptySequenceableTest + TSequencedElementAccessTest + TCloneTest + TIncludesWithIdentityCheckTest + TCopyTest + TCreationWithTest + TPutBasicTest + TConvertTest + TOccurrencesForMultiplinessTest + TIterateSequencedReadableTest + TSequencedConcatenationTest + TReplacementSequencedTest + TAsStringCommaAndDelimiterSequenceableTest + TBeginsEndsWith + TPrintOnSequencedTest + TIndexAccess + TSubCollectionAccess + TConvertAsSetForMultiplinessIdentityTest + TCopyPartOfSequenceable + TCopySequenceableSameContents + TCopySequenceableWithOrWithoutSpecificElements + TCopySequenceableWithReplacement + TIndexAccessForMultipliness + TCopyPartOfSequenceableForMultipliness + TConvertAsSortedTest + TPutTest + TSequencedStructuralEqualityTest + TSortTest + TSetArithmetic + TEnumeratingTest\r\tinstanceVariableNames: 'example1 literalArray selfEvaluatingArray nonSEArray1 nonSEarray2 example2 empty collectResult withoutEqualElements withEqualElements withCharacters unsortedCollection sortedInAscendingOrderCollection collectionNotIncluded removedCollection elementInForCopy elementNotInForCopy firstIndex secondIndex replacementCollection indexArray valueArray nonEmptyMoreThan1Element subCollectionNotIn replacementCollectionSameSize oldSubCollection nonEmpty1Element collectionOfCollection collectionOfFloatWithEqualElements collectionWithoutNil duplicateElement collection5Elements collectionWith4Elements collectionOfCollectionsOfStrings collectionOfCollectionsOfInts simpleCollection stringCollectionWithSameBeginingAnEnd collectionOfFloat'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Base'",			"comment" : [				"This is the unit test for the class Array. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: ",				"\t- http://www.c2.com/cgi/wiki?UnitTest",				"\t- there is a chapter in the PharoByExample book (http://pharobyexample.org/)\t",				"\t- the sunit class category"			],			"category" : "Collections-Sequenceable-Tests-Base"		},		"TEmptySequenceableTest" : {			"hash" : 4341504,			"definition" : "Trait named: #TEmptySequenceableTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TRemoveTest" : {			"hash" : 4351744,			"definition" : "Trait named: #TRemoveTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"IRStackCount" : {			"hash" : 1235456,			"definition" : "Object subclass: #IRStackCount\r\tinstanceVariableNames: 'start position length'\r\tclassVariableNames: ''\r\tpackage: 'OpalCompiler-Core-Bytecode'",			"comment" : [				"This keeps track of the stack count for the BytecodeGenerator."			],			"category" : "OpalCompiler-Core-Bytecode"		},		"DictionaryTest" : {			"hash" : 4391936,			"definition" : "CollectionRootTest subclass: #DictionaryTest\r\tuses: TIncludesTest + TDictionaryAddingTest + TDictionaryComparingTest + TDictionaryCopyingTest + TDictionaryEnumeratingTest + (TDictionaryPrintingTest - {#testPrintElementsOn. #testStoreOn}) + TDictionaryRemovingTest + (TPutBasicTest - {#testAtPutOutOfBounds}) + TAsStringCommaAndDelimiterTest + TPrintTest + TConvertTest + TConvertAsSortedTest + (TCopyTest - {#testCopyEmptyWithout. #testCopyNonEmptyWithout. #testCopyNonEmptyWithoutNotIncluded}) + TSetArithmetic + TDictionaryIncludesWithIdentityCheckTest + TDictionaryValueAccessTest + TDictionaryKeysValuesAssociationsAccess + TDictionaryKeyAccessTest + TDictionaryAssociationAccessTest + TStructuralEqualityTest + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'emptyDict nonEmptyDict nonEmpty5ElementsNoDuplicates indexArray valueArray nonEmpty1Element collectionNotIncluded collectionIncluded associationNotIn valueNotIn keyNotIn dictionaryNotIncluded dictionaryWithDuplicateValues duplicateValue nonEmptyWithString'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Unordered-Tests-Dictionaries'",			"comment" : [				"SUnit tests for dictionaries"			],			"category" : "Collections-Unordered-Tests-Dictionaries"		},		"CollectionRootTest" : {			"hash" : 4357888,			"definition" : "ClassTestCase subclass: #CollectionRootTest\r\tuses: TIterateTest + TEmptyTest + TSizeTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Base'",			"comment" : [				"I'm the root of the hierarchy of the collection tests."			],			"category" : "Collections-Abstract-Tests-Base"		},		"GPoint class" : {			"hash" : 6907648,			"definition" : "GPoint class\r\tuses: TGWithCoordinates classTrait\r\tinstanceVariableNames: ''",			"comment" : [				"Description",				"--------------------",				"",				"I represent a geometric point. In the contrary of default Pharo point, I implement only the point logic and cannot be used as a vector. ",				"",				"Vectors can be used with GVector.",				"",				"I am based on a set of coordinates and my API should be independent from the number of dimensions of the current space. The computations will rely on coordinates.",				"",				"Examples",				"--------------------",				"",				"\t\"Instance creation\"",				"\t",				"\tGPoint withCollection: #(1 2).\t \"a GPoint(1,2)\"",				"\t",				"\tGPoint withCollection: #(1 4 2). \"a GPoint(1,4,2)\"",				"\t",				"\tGPoint coordinates: (GCoordinates withCollection: #(1 3)). \t\"a GPoint(1,3)\"",				"\t",				"\t(GCoordinates withCollection: #(1 3)) asGPoint.\t\"a GPoint(1,3)\"",				"\t",				"\t#(1 2) asGPoint.\t\"a GPoint(1,2)\"",				"\t\t",				"\t1 , 2.\t\t\"a GPoint(1,2)\"\t\t",				"\t\t",				"\t\"Arithmetic\"",				"\t(1 , 2) + (2 , 3). \"a GPoint(3,5) <= This will be a new instance.\"",				"\t",				"\t(1, 2) translateBy: (2 , 3).\t\"a GPoint(3,5) <= This will be the same instance than the receiver\" ",				"\t\t",				"\t(4, 2) - (1, 1).\t\"a GVector(3,1)\"",				"\t\t",				"\t(3, 5) middlePointTo: (9, 15).\t\"a GPoint(6,10)\"",				"\t",				"\t(3, 5) distanceTo: (9, 15).\t\"11.661903789690601\"",				"\t",				" ",				"Internal Representation and Key Implementation Points.",				"--------------------",				"",				"    Instance Variables",				"\tcoordinates:\t\t<aGCoordinates> \tI represent the coordinates of the point."			],			"category" : "Geometry-Core"		},		"ClyTypedScope class" : {			"hash" : 5990656,			"definition" : "ClyTypedScope class\r\tinstanceVariableNames: ''",			"comment" : [				"My subclasses represent the scope of concrete typed objects.",				"I do not require them to implement any specific methods. They just define logically what objects they represent. And they should provide methods to assess information from them.",				"",				"For example there is ClyClassScope which is based on set of classes. And there is ClyPackageScope which is based on set of packages.",				"And they provide methods which queries are using to retrieve required objects: ",				"\taClassScope classesDo: aBlock",				"\taClassScope methodsDo: aBlock ",				"\taPackageScope packagesDo: aBlock ",				"\taPackageScope classesDo: aBlock ",				"\taPackageScope methodsDo: aBlock",				"",				"I provide several methods to instantiate typed scopes:",				"",				"\tClyClassScope of: String.",				"\tClyClassScope of: String in: ClyNavigationEnvironment currentImage.",				"\tClyClassScope of: String in: ClyNavigationEnvironment currentImage named: 'String scope'.",				"",				"They create class scopes based on single basis object String.",				"",				"\tClyClassScope ofAll: {String. Point}.",				"\tClyClassScope of: {String. Point} in: ClyNavigationEnvironment currentImage.",				"\tClyClassScope of: {String. Point} in: ClyNavigationEnvironment currentImage named: 'String and Point'.",				"",				"They create scopes of two classes String and Point.",				"",				"Also users can ask for empty scope: ",				"",				"\tClyClassScope empty.",				"\tClyClassScope emptyIn: ClyNavigationEnvironment.",				"\t",				"I implement several methods convert existing scopes to new one with modified basis:",				"",				"- withNewBasisObjects: newBasisObjects",				"It returns new scope similar to receiver but with basis.",				"",				"- withExtraBasisObject: extraBasisObject ",				"It returnes new scope similar to receiver but with basis extended by given extraBasisObject.",				"",				"- withExtraBasisObjects: extraBasisObjects ",				"It returnes new scope similar to receiver but with basis extended by all extraBasisObjects.",				"",				"- withoutBasisObject: existingBasisObject ",				"It returnes new scope similar to receiver but with basis which excludes existingBasisObject. It ignores the case when given object is not in the basis of receiver scope.",				"",				"- withoutBasisObjects: existingBasisObjects ",				"It returnes new scope similar to receiver but with basis which excludes all existingBasisObjects. It ignores the case when some of given objects are not in the basis of receiver scope.",				"",				"- restrictedBy: anotherScope",				"It returnes new scope similar to receiver but with basis of given anotherScope",				"",				"Also I provide scope composition method which merges two scopes: ",				"\t",				"\t(ClyClassScope of: String) , (ClyClassScope of: Array)",				"\t",				"It returns ClyCompositeScope instance. ",				"",				"To support composite scope and query I introduce method #asUnifiedInstance which supposed to return similar scope with same kind of scope class and internal parameters but with empty basis.",				"So any possible instance of my subclass should produce equal unified instance with this method. It is used to merge subqueries and their scopes when ClyUnionQuery is built. ",				"\t",				"Also I implement my superclass abstract methods like: ",				"- supportsQuery: aQuery. It returns true for any kind of ClyTypedQuery.",				"- representsScope: aScopeClass. It just checks if receiver is kind of given scope class.",				"- adoptQuery: aQuery. It just assigns receiver to the aQuery to be it scope."			],			"category" : "Calypso-NavigationModel-Model"		},		"CTCategoryTest" : {			"hash" : 2398976,			"definition" : "TestCase subclass: #CTCategoryTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-Category-Tests'",			"comment" : [				"A CTCategoryTest is a test class for testing the behavior of CTCategory"			],			"category" : "Containers-Category-Tests"		},		"StringTest" : {			"hash" : 4375296,			"definition" : "CollectionRootTest subclass: #StringTest\r\tuses: TIncludesTest + TCloneTest + TCopyTest + TSetArithmetic + TIterateSequencedReadableTest + TPrintOnSequencedTest + TAsStringCommaAndDelimiterSequenceableTest + TIndexAccess + TSequencedElementAccessTest + TSubCollectionAccess + TPutBasicTest + TCopySequenceableSameContents + TCopyPartOfSequenceable + TCopyPartOfSequenceableForMultipliness + TCopySequenceableWithOrWithoutSpecificElements + TCopySequenceableWithReplacement + TReplacementSequencedTest + (TConvertTest - {#testAsByteArray}) + TConvertAsSortedTest + TBeginsEndsWith + (TIndexAccessForMultipliness - {#testIdentityIndexOfIAbsentDuplicate. #testIdentityIndexOfDuplicate. #collectionWithNonIdentitySameAtEndAndBegining}) + TSequencedConcatenationTest + TPutTest + TConvertAsSetForMultiplinessTest + TSortTest + TSequencedStructuralEqualityTest + TOccurrencesForMultiplinessTest + TCreationWithTest\r\tinstanceVariableNames: 'string emptyString elementInNonEmpty notIn nonEmpty1element withoutEqualElements collectionNotIncluded indexInNonEmptyArray sameAtEndAndBegining nonEmpty5ElementsSorted unsortedCollection subcollection3ElementsSorted arrayWithCharacters'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Strings-Tests-Base'",			"comment" : [				"This is the unit test for the class String. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: ",				"\t- http://www.c2.com/cgi/wiki?UnitTest",				"\t- there is a chapter in the PharoByExample book (http://pharobyexample.org/)",				"\t- the sunit class category"			],			"category" : "Collections-Strings-Tests-Base"		},		"ZnRequestLine class" : {			"hash" : 1420288,			"definition" : "ZnRequestLine class\r\tinstanceVariableNames: ''",			"comment" : [				"I am an HTTP Request Line.",				"I consist of an HTTP method, an URI and an HTTP protocol version.",				"I can be used for generating and parsing.",				"",				"Part of Zinc HTTP Components."			],			"category" : "Zinc-HTTP-Core"		},		"LGitCommitBuilder" : {			"hash" : 7346688,			"definition" : "LGitRepositoryObject subclass: #LGitCommitBuilder\r\tinstanceVariableNames: 'author committer tree parents message updateReference messageEncoding commitId'\r\tclassVariableNames: ''\r\tpackage: 'LibGit-Core-HelperObjects'",			"comment" : [				"A commit builder for git"			],			"category" : "LibGit-Core-HelperObjects"		},		"HashedCollection class" : {			"hash" : 849920,			"definition" : "HashedCollection class\r\tinstanceVariableNames: ''",			"comment" : [				"I am an abstract collection of objects that implement hash and equality in a consistent way. This means that whenever two objects are equal, their hashes have to be equal too. If two objects are equal then I can only store one of them. Hashes are expected to be integers (preferably SmallIntegers). I also expect that the objects contained by me do not change their hashes. If that happens, hash invariants have to be re-established, which can be done by #rehash.",				"",				"Since I'm abstract, no instances of me should exist. My subclasses should implement #scanFor:, #fixCollisionsFrom: and #noCheckNoGrowFillFrom:.",				"",				"Instance Variables",				"\tarray:\t\t<ArrayedCollection> (typically Array or WeakArray)",				"\ttally:\t\t<Integer> (non-negative)",				"",				"array",				"\t- An array whose size is a prime number, it's non-nil elements are the elements of the collection, and whose nil elements are empty slots. There is always at least one nil. In fact I try to keep my \"load\" at 75% or less so that hashing will work well.",				"",				"tally",				"\t- The number of elements in the collection. The array size is always greater than this.",				"",				"Implementation details:",				"I implement a hash table which uses open addressing with linear probing as the method of collision resolution. Searching for an element or a free slot for an element is done by #scanFor: which should return the index of the slot in array corresponding to it's argument. When an element is removed #fixCollisionsFrom: should rehash all elements in array between the original index of the removed element, wrapping around after the last slot until reaching an empty slot. My maximum load factor (75%) is hardcoded in #atNewIndex:put:, so it can only be changed by overriding that method. When my load factor reaches this limit I replace my array with a larger one (see #grow) ensuring that my load factor will be less than or equal to 50%. The new array is filled by #noCheckNoGrowFillFrom: which should use #scanForEmptySlotFor: instead of #scanFor: for better performance. I do not shrink."			],			"category" : "Collections-Abstract-Base"		},		"DATarjanAlgorithm" : {			"hash" : 4739584,			"definition" : "Object subclass: #DATarjanAlgorithm\r\tinstanceVariableNames: 'runningIndex stack stronglyConnectedComponents'\r\tclassVariableNames: ''\r\tpackage: 'Tool-DependencyAnalyser-Core'",			"comment" : [				"A class to do Tarjan Algorithm on a PDPackageRelation, in order to detect strongly connected components.",				"Give a package dependency graph (PDPackageRelationGraph)  in entry of the message run to run the Tarjan algorithm and retrieve all the strongly connected components graph."			],			"category" : "Tool-DependencyAnalyser-Core"		},		"TSizeTest" : {			"hash" : 4354816,			"definition" : "Trait named: #TSizeTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinaryTreeNode" : {			"hash" : 2299904,			"definition" : "CTBinaryTreeElement subclass: #CTBinaryTreeNode\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinaryTreeAbstract'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-BinaryTreeAbstract"		},		"TStructuralEqualityTest" : {			"hash" : 4355840,			"definition" : "Trait named: #TStructuralEqualityTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"Tests whether two objects are equals: they contain the same objects in the same order."			],			"category" : "Collections-Abstract-Tests-Traits"		},		"Path class" : {			"hash" : 833024,			"definition" : "Path class\r\tinstanceVariableNames: ''",			"comment" : [				"I'm a private and abstract filesystem path, independent of the string representation used to describe paths on a specific filesystem. I provide methods for navigating the filesystem hierarchy and working with absolute and relative paths. I only refer to a concrete file or directory with regard to a specific filesystem. Normally users should not use me directly. ",				"",				"API instance creation:",				"",				"- #from: parses the supplied string using the default delimeter",				"- #from:delimiter: parses the supplied string using the supplied delimiter.",				"- #/ creates an absolute path from the supplied string",				"- #* creates a relative path from the supplied string",				"",				"API path manipulation:",				"",				"- #/ adds the supplied string to the receiver"			],			"category" : "FileSystem-Path-Base"		},		"TPutBasicTest" : {			"hash" : 4350208,			"definition" : "Trait named: #TPutBasicTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"SortedCollectionTest" : {			"hash" : 4365056,			"definition" : "CollectionRootTest subclass: #SortedCollectionTest\r\tuses: TIterateSequencedReadableTest + TPrintOnSequencedTest + TAsStringCommaAndDelimiterSequenceableTest + TIncludesWithIdentityCheckTest + (TSequencedElementAccessTest - {#testAtAll}) + TSubCollectionAccess + TIndexAccessForMultipliness + TRemoveTest + TConvertTest + TConvertAsSetForMultiplinessIdentityTest + TAddTest + TBeginsEndsWith + (TCopySequenceableSameContents - {#testShuffled}) + TSetArithmetic + TRemoveByIndexTest + TCopyPartOfSequenceable + TCopyPartOfSequenceableForMultipliness + (TCopySequenceableWithOrWithoutSpecificElements - {#testForceToPaddingStartWith. #testForceToPaddingWith. #testCopyWithFirst. #testCopyWithoutIndex}) + TCopySequenceableWithReplacementForSorted + TCopyTest + TConvertAsSortedTest + TSequencedStructuralEqualityTest + TCreationWithTest + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'nonEmpty elementExistsTwice empty collectResult nonEmpty1Element collectionOfFloat accessCollection elementNoteIn oldSubcollection withoutEqualElements collectionOfFloatWithDuplicate collectionIncluded collectionNotIncluded collectionWithoutNil duplicateFloat nonEmpty5Elements collectionWith4Elements collectionOfString stringCollectionSameEndAndBegining'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Sequenceable-Tests-Ordered'",			"comment" : [				"SUnit tests for sorted collections"			],			"category" : "Collections-Sequenceable-Tests-Ordered"		},		"CTRedBlackSetTest" : {			"hash" : 2310656,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTRedBlackSetTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet-Tests'",			"comment" : [				"A CTRedBlackSetTest is a test class for testing the behavior of CTRedBlackSet"			],			"category" : "Containers-RedBlackSet-Tests"		},		"ZnOptions class" : {			"hash" : 1419776,			"definition" : "ZnOptions class\r\tinstanceVariableNames: ''",			"comment" : [				"I am ZnOptions, a object that holds key/value options for configuration, parameterization and settings.",				"",				"Option objects contain key/value pairs and inherit from a parent.",				"They can be writeable or readonly.",				"",				"Clients typically refer to option using the ZnCurrentOptions dynamic variable.",				"",				"\tZnCurrentOptions at: #myOption",				"\t",				"The top level, global default is typically on my class side marked by the <znOption> pragma.",				"",				"I hold the #globalDefault options.",				"",				"Options can be cloned to make them writeable.",				"",				"Options can changed and activated using #during:",				"",				"ZnOptions globalDefault clone",				"\tat: #myOption put: 'newValue';",				"\tduring: [ ZnCurrentOptions at: #myOption ].",				"",				"ZnClient and ZnServer instances hold and apply their own local options.",				"They use or #conditionallyDuring: to allow an enclosing #during: to take precedence."			],			"category" : "Zinc-HTTP-Support"		},		"FileSystem class" : {			"hash" : 1264640,			"definition" : "FileSystem class\r\tinstanceVariableNames: ''",			"comment" : [				"I present a low-level protocol for interacting with filesystems. I hold a reference to",				"a store (a subinstance of FileSystemStore) which takes care of the details of performing ",				"file and directory operations on the filesystem I represent. ",				"",				"I am responsible for resolving all paths that",				"I pass into my store. My store acts as a factory and offers platform specific actions.",				"",				"",				"FileSystem instances know two methods that return a Reference object: workingDirectory and root.",				"",				"FileSystem disk workingDirectory",				"FileSystem disk root",				""			],			"category" : "FileSystem-Core-Public"		},		"KMShortcutTest" : {			"hash" : 5309184,			"definition" : "AbstractKeymappingTest subclass: #KMShortcutTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Keymapping-Tests'",			"comment" : [				"SUnit tests for key mapping shortcuts"			],			"category" : "Keymapping-Tests"		},		"TBeginsEndsWith" : {			"hash" : 4332800,			"definition" : "Trait named: #TBeginsEndsWith\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTDfsSCCsWalker" : {			"hash" : 2321408,			"definition" : "CTDfsWalker subclass: #CTDfsSCCsWalker\r\tinstanceVariableNames: 'sccShapeStack sccs'\r\tclassVariableNames: ''\r\tpackage: 'Containers-Essentials-Outliner-Walkers'",			"comment" : [				"I also take care of Strongly Connected Components (also see ",				"Tarjan, R. E. (1972), \"Depth-first search and linear graph algorithms\", ",				"SIAM Journal on Computing, 1 (2): 146–160)."			],			"category" : "Containers-Essentials-Outliner-Walkers"		},		"TConcatenationEqualElementsRemovedTest" : {			"hash" : 4334336,			"definition" : "Trait named: #TConcatenationEqualElementsRemovedTest\r\tuses: TConcatenationTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TConcatenationTest" : {			"hash" : 4333824,			"definition" : "Trait named: #TConcatenationTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TOccurrencesTest" : {			"hash" : 4348160,			"definition" : "Trait named: #TOccurrencesTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"TGrowableTest" : {			"hash" : 4343040,			"definition" : "Trait named: #TGrowableTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CompiledMethodTrailer class" : {			"hash" : 914688,			"definition" : "CompiledMethodTrailer class\r\tinstanceVariableNames: ''",			"comment" : [				"I am responsible for encoding and decoding various kinds of compiled method trailer data.",				"I should not expose any binary data outside of myself, so all tools which working with compiled methods",				"should ask me to encode the meta-data, they want to be added to the compiled method trailer, as well as retrieve it.",				"",				"To add a new kind of trailer, you should give it a proper name and define it in the #trailerKinds method at my class side.",				"Then you need to implement a corresponding #encode<your name> and #decode<your name> methods at instance side. Then add any public accessor methods, which will use a newly introduced trailer kind for communicating with outer layer(s).",				"",				"An encodeXXX methods should store result (byte array) into encodedData instance variable.",				"",				"A decodeXXX methods should read the data from compiled method instance, held by 'method' ivar,",				"and always set 'size' ivar (denoting a total length of trailer in compiled method) and optionally 'data' ivar which should keep a decoded data, ready to be used by outer layer(s) using accessor method(s) you providing.",				"",				"The kind of compiled method trailer is determined by the last byte of compiled method.",				"",				"The byte format used is following: ",				"\t\"2rkkkkkkdd\"",				"",				"where 'k' bits stands for 'kind' , allowing totally 64 different kinds of method trailer",				"and 'd' bits is data.",				"",				"Following is the list of currently defined trailer kinds:",				"",				"NoTrailer , k = 000000, dd unused",				"method has no trailer, and total trailer size bytes is always 1",				"",				"ClearedTrailer, k = 000001, ",				"method has cleared trailer (it was set to something else, but then cleared) ",				"dd+1  determines the number of bytes for size field, and size is a total length of trailer bytes",				"So a total length of trailer is: 1 + (dd + 1) + size",				"",				"TempsNamesQCompress, k = 000010",				"the trailer contains a list of method temp names,  compressed using qCompress: method. ",				"dd+1  determines the number of bytes for size field, and size is a number of bytes of compressed buffer.",				"So a total length of trailer is:  1 + (dd + 1) + size",				"",				"TempsNamesZip, k = 000011",				"the trailer contains a list of method temp names,  compressed using GZIP compression method. ",				"dd+1  determines the number of bytes for size field, and size is a number of bytes of compressed buffer",				"So a total length of trailer is: 1 + (dd + 1) + size",				"",				"SourceBySelector, k = 000100",				"the trailer indicates , that method source is determined by a class + selector where it is installed to. ",				"Trailer size = 1.",				"",				"SourceByStringIdentifier, k = 000101",				"the trailer indicates , that method source is determined by a class + some ByteString identifier. ",				"dd+1  determines the number of bytes for size of ByteString identifier, and size is number of bytes of string.",				"A total length of trailer is:  1 + (dd + 1) + size",				"",				"EmbeddedSourceQCompress, k = 000110",				"the trailer contains an utf-8 encoded method source code, compressed using qCompress method",				"dd+1  determines the number of bytes for size field, and size is a number of bytes of compressed source code",				"A total length of trailer is:  1 + (dd + 1) + size",				"",				"EmbeddedSourceZip, k = 000111",				"the trailer contains an utf-8 encoded method source code, comressed using GZIP ",				"dd+1  determines the number of bytes for size field, and size is a number of bytes of compressed buffer",				"A total length of trailer is:  1 + (dd + 1) + size",				"",				"VarLengthSourcePointer, k = 001000",				"the trailer is variable-length encoded source pointer. ",				"dd bits is unused.",				"",				"ExtendedKind, k = 001001",				"the next byte of trailer (one that prepends the last byte of compiled method)",				"denotes an extended kind of trailer, allowing to use additional 256 kinds of encoding method's trailer in future. ",				"",				"SourcePointer, k = 111111 ",				"the trailer is encoded source pointer. Total trailer size is 4-bytes ",				"(this kind of encoding is backwards compatible with most of existing compiled methods)",				""			],			"category" : "Kernel-Methods"		},		"WideCharacterSetTest" : {			"hash" : 4380672,			"definition" : "TestCase subclass: #WideCharacterSetTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Collections-Support-Tests-CharacterSets'",			"comment" : [				"WideCharacterSetTest holds tests for WideCharacterSet"			],			"category" : "Collections-Support-Tests-CharacterSets"		},		"SymbolTest" : {			"hash" : 4375808,			"definition" : "CollectionRootTest subclass: #SymbolTest\r\tuses: TSortTest - {#testSort. #testSortUsingSortBlock} + TIncludesTest + (TCloneTest - {#testCopyCreatesNewObject}) + TCopyPreservingIdentityTest + TCopyTest + (TSetArithmetic - {#testDifferenceWithNonNullIntersection}) + TIterateSequencedReadableTest + TSequencedConcatenationTest + TPrintOnSequencedTest + TAsStringCommaAndDelimiterSequenceableTest + TIndexAccess + (TIndexAccessForMultipliness - {#testIdentityIndexOfIAbsentDuplicate. #testIdentityIndexOfDuplicate. #collectionWithNonIdentitySameAtEndAndBegining}) + TSequencedElementAccessTest + TSubCollectionAccess + (TCopySequenceableSameContents - {#testShuffled}) + (TCopyPartOfSequenceable - {#testCopyEmptyMethod. #integerCollectionWithoutEqualElements}) + TCopyPartOfSequenceableForMultipliness + TCopySequenceableWithReplacement + TBeginsEndsWith + TConvertAsSortedTest + (TConvertTest - {#testAsByteArray. #integerCollectionWithoutEqualElements}) + TCopySequenceableWithOrWithoutSpecificElements + TConvertAsSetForMultiplinessTest + TSequencedStructuralEqualityTest + TOccurrencesForMultiplinessTest\r\tinstanceVariableNames: 'emptySymbol nonEmptySymbol5ElementsNoDuplicates notIn collectionNotIncluded collectionSize4 collection1Element sameAtEndAndBegining with2timeSubcollection subcollection3ElementsSorted'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Strings-Tests-Base'",			"comment" : [				"This is the unit test for the class Symbol. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: ",				"\t- http://www.c2.com/cgi/wiki?UnitTest",				"\t- there is a chapter in the PharoByExample book (http://pharobyexample.org/)",				"\t- the sunit class category"			],			"category" : "Collections-Strings-Tests-Base"		},		"MemoryStore" : {			"hash" : 1429248,			"definition" : "FileSystemStore subclass: #MemoryStore\r\tinstanceVariableNames: 'root'\r\tclassVariableNames: 'CurrentFS'\r\tpackage: 'FileSystem-Memory-Store'",			"comment" : [				"I'm a specific store for memory file system"			],			"category" : "FileSystem-Memory-Store"		},		"FileSystemGuide" : {			"hash" : 1274624,			"definition" : "Object subclass: #FileSystemGuide\r\tinstanceVariableNames: 'visitor work selectChildren'\r\tclassVariableNames: ''\r\tpackage: 'FileSystem-Core-Base-Guide'",			"comment" : [				"I am an abstract superclass for objects that fulfill the Guide role in the Guide/Visitor pattern. My subclasses know how to traverse a filesystem in a specific order, \"showing\" the files and directories they encounter to a visitor.",				"",				"visitor",				"\tAn object that fulfills the Visitor role and implements the visitor protocol.",				"\t",				"work",				"\tAn OrderedCollection, used to keep track of filesystem nodes that have not yet been visited"			],			"category" : "FileSystem-Core-Base-Guide"		},		"FileSystem" : {			"hash" : 1274112,			"definition" : "Object subclass: #FileSystem\r\tinstanceVariableNames: 'store'\r\tclassVariableNames: ''\r\tpackage: 'FileSystem-Core-Public'",			"comment" : [				"I present a low-level protocol for interacting with filesystems. I hold a reference to",				"a store (a subinstance of FileSystemStore) which takes care of the details of performing ",				"file and directory operations on the filesystem I represent. ",				"",				"I am responsible for resolving all paths that",				"I pass into my store. My store acts as a factory and offers platform specific actions.",				"",				"",				"FileSystem instances know two methods that return a Reference object: workingDirectory and root.",				"",				"FileSystem disk workingDirectory",				"FileSystem disk root",				""			],			"category" : "FileSystem-Core-Public"		},		"TCopySequenceableSameContents" : {			"hash" : 4338432,			"definition" : "Trait named: #TCopySequenceableSameContents\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		},		"CTBinaryTreeAbstractTest" : {			"hash" : 2300928,			"definition" : "TestCase subclass: #CTBinaryTreeAbstractTest\r\tuses: TIceImagesExporting\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-BinaryTreeAbstract-Tests'",			"comment" : [				"A CTBinaryTreeAbstractTest is a test class for testing the behavior of CTBinaryTreeAbstract"			],			"category" : "Containers-BinaryTreeAbstract-Tests"		},		"RSTextExtents class" : {			"hash" : 6999552,			"definition" : "RSTextExtents class\r\tinstanceVariableNames: ''",			"comment" : [				"Extents for RSLabel"			],			"category" : "Roassal3-Shapes-Text"		},		"Array class" : {			"hash" : 791552,			"definition" : "Array class\r\tinstanceVariableNames: ''",			"comment" : [				"Array is a fixed-sized collection of elements accessed by integer indices. Contrary to the C convention, the first element of a Pharo array is at position 1 and not 0. The main protocol to access array elements is the method `at:` and `at:put:`. ",				"",				"- `at: anInteger` returns the element at index anInteger. ",				"- `at: anInteger put: anObject` puts `anObject` at index `anInteger`. ",				"",				"Arrays are fixed-size collections therefore we cannot add or remove elements at the end of an array. ",				"",				"The following code creates an array of size 5, puts values in the first 3 locations and returns the first element.",				"",				"``` ",				"| anArray |",				"anArray := Array new: 5. ",				"anArray at: 1 put: 4. ",				"anArray at: 2 put: 3/2. ",				"anArray at: 3 put: 'ssss'. ",				"anArray at: 1\t\t\t",				">>> 4",				"```",				"",				"`#()` creates literal arrays with static (or “literal”) elements that have to be known when the expression is compiled, and not when it is executed. ",				"",				"The following code creates an array of size 2 where the first element is the (literal) number 1 and the second the (literal) string 'here'.",				"",				"``` ",				"#(1 'here') size ",				"> 2",				"```",				"",				"`{ }` is a way to create arrays in a more dynamic manner.",				"",				"``` ",				"| array |",				"array := (Array new: 2). ",				"array",				"\tat: 1 put: (Point x: 10 y: 20);",				"\tat: 2 put: (Point x: 10 y: 20). ",				"\tarray\t\t\t",				"```",				"",				"is equivalent to ",				"",				"```",				"{(10@20) . (10@20)}",				"{Point x: 10 y: 20 . Point x: 10 y: 20}",				"```"			],			"category" : "Collections-Sequenceable-Base"		},		"FLMaterialization" : {			"hash" : 742912,			"definition" : "Object subclass: #FLMaterialization\r\tinstanceVariableNames: 'clusterCount clusters root decoder header'\r\tclassVariableNames: ''\r\tpackage: 'Fuel-Core-Base'",			"comment" : [				"I implement the algorithm for materializing an object graph on a stream. FLMaterializer known how to build instances of me."			],			"category" : "Fuel-Core-Base"		},		"GAngleTest" : {			"hash" : 6916864,			"definition" : "GTestCase subclass: #GAngleTest\r\tinstanceVariableNames: 'angle'\r\tclassVariableNames: ''\r\tpackage: 'Geometry-Tests'",			"comment" : [				"This class contains tests"			],			"category" : "Geometry-Tests"		},		"CTSBRALTest" : {			"hash" : 2297856,			"definition" : "CTBinaryTreeAbstractTest subclass: #CTSBRALTest\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-SBRAL-Tests'",			"comment" : [				"A SBRALTest is a test class for testing the behavior of SBRAL"			],			"category" : "Containers-SBRAL-Tests"		},		"GCoordinates class" : {			"hash" : 6904064,			"definition" : "GCoordinates class\r\tinstanceVariableNames: ''",			"comment" : [				"Description",				"--------------------",				"",				"I represent a set of coordinates that will be used by other geometric elements.",				"",				"My subclass will represent sets of a certain amount of coordinates. In the long terme we would like to remove all the subclasses and that everything manage myself as a n-dimensions coordinates set, but for now we prefer to begin with simple sets like 2D or 3D.",				"",				"I implement basic arithmetic that can be done with coordinates.",				"",				"Examples",				"--------------------",				"\t",				"\t\"Instance creation\"",				"\tGCoordinates withCollection: #(1 3). \t\"(1,3)\"",				"\t",				"\t#(1 3) asGCoordinates.\t\"(1,3)\"",				"\t",				"\t\"Arithmetic\"\t\t",				"\t(GCoordinates withCollection: #(1 3)) + (GCoordinates withCollection: #(5 1)). \t\"(6,4)\"",				"\t\t",				"\t(GCoordinates withCollection: #(1 3)) - (GCoordinates withCollection: #(5 1)). \t\"(-4,2)\"",				"\t\t",				"\t(GCoordinates withCollection: #(1 3)) * 2. \t\"(2,6)\"",				"\t\t",				"\t(GCoordinates withCollection: #(1 3)) / 2. \t\"((1/2),(3/2))\"",				" ",				"Internal Representation and Key Implementation Points.",				"--------------------",				"",				"    Instance Variables",				"\tcoordinates:\t\t<aCollection> \tA collection of all the coordinates I contains."			],			"category" : "Geometry-Core"		},		"CTBinaryTreeNodeUnbalanced" : {			"hash" : 2306560,			"definition" : "CTBinaryTreeNode subclass: #CTBinaryTreeNodeUnbalanced\r\tinstanceVariableNames: ''\r\tclassVariableNames: ''\r\tpackage: 'Containers-RedBlackSet'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"",				"    Implementation Points"			],			"category" : "Containers-RedBlackSet"		},		"TwoInARowStar" : {			"hash" : 4430336,			"definition" : "Object subclass: #TwoInARowStar\r\tinstanceVariableNames: 'leave fill'\r\tclassVariableNames: ''\r\tpackage: 'Kernel-Tests-Methods'",			"comment" : [				"Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:",				"",				"For the Class part:  State a one line summary. For example, \"I represent a paragraph of text\".",				"",				"For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.",				"",				"For the Collaborators Part: State my main collaborators and one line about how I interact with them. ",				"",				"Public API and Key Messages",				"",				"- message one   ",				"- message two ",				"- (for bonus points) how to create instances.",				"",				"   One simple example is simply gorgeous.",				" ",				"Internal Representation and Key Implementation Points.",				"",				"    Instance Variables",				"\tfill:\t\t<Object>",				"\tleave:\t\t<Object>",				"",				"",				"    Implementation Points"			],			"category" : "Kernel-Tests-Methods"		},		"LIFOQueue" : {			"hash" : 1093632,			"definition" : "AtomicCollection subclass: #LIFOQueue\r\tinstanceVariableNames: 'head'\r\tclassVariableNames: ''\r\tpackage: 'Collections-Atomic-Base'",			"comment" : [				"This is a thread-safe LIFO (last-in-first-out) queue (also known as stack) implementation,",				"based on atomic operations."			],			"category" : "Collections-Atomic-Base"		},		"TRemoveForMultiplenessTest" : {			"hash" : 4352256,			"definition" : "Trait named: #TRemoveForMultiplenessTest\r\tuses: TRemoveTest\r\tinstanceVariableNames: ''\r\tpackage: 'Collections-Abstract-Tests-Traits'",			"comment" : [				"A trait for test purposes"			],			"category" : "Collections-Abstract-Tests-Traits"		}	},	"messages" : {		"testPushOrderedInterval" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"testPushOrderedInterval",						"",						"\t^ self exportSlotsGraphOf: (self tree: (1 to: 20) asArray)"					],					"body" : [						"^ self exportSlotsGraphOf: (self tree: (1 to: 20) asArray)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3095856,					"argumentNames" : [ ]				}			}		},		"push:witness:continuation:inSet:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeNodeBalanced>>#push:witness:continuation:inSet:",				"CTBinaryTreeNodeUnbalanced>>#push:witness:continuation:inSet:",				"CTUnbalancedSet>>#push:"			],			"implementors" : {				"CTBinaryTreeEmptyUnbalanced" : {					"sourceCode" : [						"push: anObject witness: aWitness continuation: aContinuation inSet: aSet",						"",						"\t^ (aSet is: anObject equalTo: aWitness)",						"\t\t  ifTrue: [ ",						"\t\t  aSet pushingAlreadyIncluded: anObject continuation: aContinuation ]",						"\t\t  ifFalse: [ aSet binaryTreeElementLeaf: anObject ]"					],					"body" : [						"^ (aSet is: anObject equalTo: aWitness)",						"\t  ifTrue: [ ",						"\t  aSet pushingAlreadyIncluded: anObject continuation: aContinuation ]",						"\t  ifFalse: [ aSet binaryTreeElementLeaf: anObject ]"					],					"isTestMethod" : false,					"category" : "as yet unclassified",					"comment" : [ ],					"hash" : 71261494,					"argumentNames" : [						"anObject",						"aWitness",						"aContinuation",						"aSet"					]				},				"CTBinaryTreeNodeUnbalanced" : {					"sourceCode" : [						"push: anObject witness: aWitness continuation: aContinuation inSet: aBinaryTree",						"",						"\t^ (aBinaryTree is: anObject lessThan: value)",						"\t\t  ifTrue: [ ",						"\t\t\t  | link |",						"\t\t\t  link := previousLink",						"\t\t\t\t          push: anObject",						"\t\t\t\t          witness: aWitness",						"\t\t\t\t          continuation: aContinuation",						"\t\t\t\t          inSet: aBinaryTree.",						"",						"\t\t\t  self class new",						"\t\t\t\t  previousLink: link;",						"\t\t\t\t  value: value;",						"\t\t\t\t  nextLink: nextLink;",						"\t\t\t\t  yourself ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | link |",						"\t\t\t  link := nextLink",						"\t\t\t\t          push: anObject",						"\t\t\t\t          witness: value",						"\t\t\t\t          continuation: aContinuation",						"\t\t\t\t          inSet: aBinaryTree.",						"",						"\t\t\t  self class new",						"\t\t\t\t  previousLink: previousLink;",						"\t\t\t\t  value: value;",						"\t\t\t\t  nextLink: link;",						"\t\t\t\t  yourself ]"					],					"body" : [						"^ (aBinaryTree is: anObject lessThan: value)",						"\t  ifTrue: [ ",						"\t\t  | link |",						"\t\t  link := previousLink",						"\t\t\t          push: anObject",						"\t\t\t          witness: aWitness",						"\t\t\t          continuation: aContinuation",						"\t\t\t          inSet: aBinaryTree.",						"",						"\t\t  self class new",						"\t\t\t  previousLink: link;",						"\t\t\t  value: value;",						"\t\t\t  nextLink: nextLink;",						"\t\t\t  yourself ]",						"\t  ifFalse: [ ",						"\t\t  | link |",						"\t\t  link := nextLink",						"\t\t\t          push: anObject",						"\t\t\t          witness: value",						"\t\t\t          continuation: aContinuation",						"\t\t\t          inSet: aBinaryTree.",						"",						"\t\t  self class new",						"\t\t\t  previousLink: previousLink;",						"\t\t\t  value: value;",						"\t\t\t  nextLink: link;",						"\t\t\t  yourself ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 71522925,					"argumentNames" : [						"anObject",						"aWitness",						"aContinuation",						"aBinaryTree"					]				},				"CTBinaryTreeNodeBalanced" : {					"sourceCode" : [						"push: anObject witness: aWitness continuation: aContinuation inSet: aBinaryTree",						"",						"\t| repr |",						"\trepr := super",						"\t\t        push: anObject",						"\t\t        witness: aWitness",						"\t\t        continuation: aContinuation",						"\t\t        inSet: aBinaryTree.",						"\t^ self balance: repr inSet: aBinaryTree"					],					"body" : [						"| repr |",						"repr := super",						"\t        push: anObject",						"\t        witness: aWitness",						"\t        continuation: aContinuation",						"\t        inSet: aBinaryTree.",						"^ self balance: repr inSet: aBinaryTree"					],					"isTestMethod" : false,					"category" : "as yet unclassified",					"comment" : [ ],					"hash" : 71521863,					"argumentNames" : [						"anObject",						"aWitness",						"aContinuation",						"aBinaryTree"					]				}			}		},		"withArrayedCollection:" : {			"senders" : [				"ArrayedCollection>>#asBinaryTree:",				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTBinaryTreeAbstract class" : {					"sourceCode" : [						"withArrayedCollection: aCollection",						"",						"\t^ aCollection ifEmpty: [ self empty ] ifNotEmpty: [ ",						"\t\t  self new yourself: [ :tree | ",						"\t\t\t  tree representation: (aCollection",						"\t\t\t\t\t   bisect: [ :l :r | ",						"\t\t\t\t\t   l mergeBinaryTreeElement: r inBinaryTree: tree ]",						"\t\t\t\t\t   baseBlock: [ :each | tree binaryTreeElementLeaf: each ]) ] ]"					],					"body" : [						"^ aCollection ifEmpty: [ self empty ] ifNotEmpty: [ ",						"\t  self new yourself: [ :tree | ",						"\t\t  tree representation: (aCollection",						"\t\t\t\t   bisect: [ :l :r | ",						"\t\t\t\t   l mergeBinaryTreeElement: r inBinaryTree: tree ]",						"\t\t\t\t   baseBlock: [ :each | tree binaryTreeElementLeaf: each ]) ] ]"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 20134370,					"argumentNames" : [						"aCollection"					]				},				"CTBinomialHeap class" : {					"sourceCode" : [						"withArrayedCollection: aCollection",						"",						"\t^ aCollection ifEmpty: [ self empty ] ifNotEmpty: [ ",						"\t\t  self new yourself: [ :tree | ",						"\t\t\t  tree representation: (aCollection",						"\t\t\t\t\t   bisect: [ :l :r | tree merge: l with: r ]",						"\t\t\t\t\t   baseBlock: [ :each | 0 -> (CTBinomialTree leaf: each) ~~> nil ]) ] ]"					],					"body" : [						"^ aCollection ifEmpty: [ self empty ] ifNotEmpty: [ ",						"\t  self new yourself: [ :tree | ",						"\t\t  tree representation: (aCollection",						"\t\t\t\t   bisect: [ :l :r | tree merge: l with: r ]",						"\t\t\t\t   baseBlock: [ :each | 0 -> (CTBinomialTree leaf: each) ~~> nil ]) ] ]"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 20136674,					"argumentNames" : [						"aCollection"					]				}			}		},		"binaryTreeElementNode" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract>>#leftBinaryTreeElement:value:rightBinaryTreeElement:"			],			"implementors" : {				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"binaryTreeElementNode",						"",						"\t^ CTBinaryTreeNode new"					],					"body" : [						"^ CTBinaryTreeNode new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3094575,					"argumentNames" : [ ]				},				"CTUnbalancedSet" : {					"sourceCode" : [						"binaryTreeElementNode",						"",						"\t^ CTBinaryTreeNodeUnbalanced new"					],					"body" : [						"^ CTBinaryTreeNodeUnbalanced new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3103791,					"argumentNames" : [ ]				},				"CTSplayHeap" : {					"sourceCode" : [						"binaryTreeElementNode",						"",						"\t^ CTBinaryTreeNodeSplayHeap new"					],					"body" : [						"^ CTBinaryTreeNodeSplayHeap new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3106863,					"argumentNames" : [ ]				},				"CTRedBlackSet" : {					"sourceCode" : [						"binaryTreeElementNode",						"",						"\t^ CTBinaryTreeNodeBalancedRed new"					],					"body" : [						"^ CTBinaryTreeNodeBalancedRed new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3104303,					"argumentNames" : [ ]				},				"CTLeftistHeap" : {					"sourceCode" : [						"binaryTreeElementNode",						"",						"\t^ CTBinaryTreeNodeLeftistHeap new"					],					"body" : [						"^ CTBinaryTreeNodeLeftistHeap new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3109423,					"argumentNames" : [ ]				}			}		},		"asLeftistHeap" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTLeftistHeapTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asLeftistHeap",						"",						"\t^ self asBinaryTree: CTLeftistHeap"					],					"body" : [						"^ self asBinaryTree: CTLeftistHeap"					],					"isTestMethod" : false,					"category" : "*Containers-LeftistHeap",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"pop" : {			"senders" : [				"AITarjan>>#addNewSccForNode:",				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"CTBinaryTreeNodeSplayHeap>>#popInBinaryTree:",				"CTCategoryTest>>#stackStuffMonad",				"CTCategoryTest>>#stackManipMonad",				"CTCategoryTest>>#testMonadLiftMState",				"CTHeapQTest>>#testPushPop",				"CTLinkedStoragePoolTest>>#testPopFromEmptyStack",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnStack",				"CTLinkedStoragePoolTest>>#testPopFromEmptyQueue",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnCircular",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnQueue",				"CTLinkedStoragePoolTest>>#testPolynomialAdditionFromKnuthTextbook",				"CTLinkedStoragePoolTest>>#testRemoveAllFromQueue",				"CTLinkedStoragePoolTest>>#testRemoveAllFromStack",				"CTLinkedStoragePoolTest>>#testPopFromEmptyCircular",				"CTLinkedStoragePoolTest>>#testPolynomialAdditionIsCommutativeFromKnuthTextbook",				"ConfigurableHistoryIterator>>#redoIfEmpty:",				"ConfigurableHistoryIterator>>#undoIfEmpty:",				"Context>>#jump",				"Context>>#methodReturnTop",				"Context>>#popIntoRemoteTemp:inVectorAt:",				"Context>>#popIntoReceiverVariable:",				"Context>>#blockReturnTop",				"Context>>#pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:",				"Context>>#doPop",				"Context>>#send:super:numArgs:",				"Context>>#popIntoTemporaryVariable:",				"Context>>#pushConsArrayWithElements:",				"Context>>#jump:if:withInterpreter:",				"Context>>#popIntoLiteralVariable:",				"Context>>#runSimulated:contextAtEachStep:",				"Context>>#directedSuperSend:numArgs:",				"DATarjanAlgorithm>>#popStackAndUpdateCurrentSCC:until:",				"FFIFunctionResolutionTest>>#testResolveConstantNilShouldSetConstantNullLoader",				"FFIFunctionResolutionTest>>#testResolveConstantFalseShouldSetConstantZeroLoader",				"FFIFunctionResolutionTest>>#testResolveConstantSelfStringShouldSetConstantLoader",				"FFIFunctionResolutionTest>>#testResolveInstanceVariableShouldSetInstanceVariableLoader",				"FFIFunctionResolutionTest>>#testResolveClassVariableShouldSetClassVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantSelfOfExternalObjectShouldSetConstantFirstInstanceVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantIntegerShouldSetConstantLoader",				"FFIFunctionResolutionTest>>#testResolveArgumentVariableShouldSetArgumentVariableLoader",				"FFIFunctionResolutionTest>>#testResolveConstantTrueShouldSetConstantOneLoader",				"FFIFunctionResolutionTest>>#testResolveConstantNULLShouldSetConstantNullLoader",				"FLAnalysis>>#run",				"FLSimpleStackTest>>#testPop",				"HiRulerBuilder>>#buildLinksStartingAt:",				"IRBuilder>>#popScope",				"IRBytecodeDecompiler>>#popScope",				"IRBytecodeGenerator>>#pushFullBlockClosure:",				"IRBytecodeGenerator>>#popTop",				"IRBytecodeGenerator>>#storePopIntoLiteralVariable:",				"IRBytecodeGenerator>>#storePopTemp:",				"IRBytecodeGenerator>>#returnTop",				"IRBytecodeGenerator>>#storePopRemoteTemp:inVectorAt:",				"IRBytecodeGenerator>>#storePopInstVar:",				"IRBytecodeGenerator>>#if:goto:otherwise:",				"IRTranslator>>#popScope",				"MCScanner>>#next",				"MicInlineParser>>#popFrom:to:",				"MicrodownStyleHelpBuilder>>#helpTopicFromFormattedString:title:",				"OupsDebuggerSelector>>#nextDebugger",				"POP3Client class>>#logFlag",				"PostorderGuide>>#show:",				"PreorderGuide>>#show:",				"RBRefactoryChangeManager>>#undoChange",				"RBRefactoryChangeManager>>#lastUndoPointer",				"SindarinDebugger>>#skipAssignmentNodeWith:",				"SindarinDebugger>>#skipMessageNodeWith:",				"SpMenuPresenterBuilder>>#visitCommandGroup:",				"StackTest>>#testSize",				"StackTest>>#testPop",				"StackTest>>#testEmptyError",				"TFRunner>>#returnCallback:",				"TypingVisitor>>#visitBlockNode:",				"WikiStyleHelpBuilder>>#helpTopicFromFormattedString:title:"			],			"implementors" : {				"CTBinomialHeap" : {					"sourceCode" : [						"pop",						"",						"\t^ self ifEmpty: [ CollectionIsEmpty signal ] ifNotEmpty: [ :trees | ",						"\t\t  | tuple tree min |",						"\t\t  tuple := self min: trees.",						"\t\t  tree := tuple first.",						"\t\t  min := tree value content.",						"\t\t  representation := self",						"\t\t\t                    merge:",						"\t\t\t\t                    ((tree key - 1 to: 0 by: -1) asValueLink",						"\t\t\t\t\t                     with: tree value children",						"\t\t\t\t\t                     collect: #->) reversed",						"\t\t\t                    with: tuple second.",						"\t\t  min ]"					],					"body" : [						"^ self ifEmpty: [ CollectionIsEmpty signal ] ifNotEmpty: [ :trees | ",						"\t  | tuple tree min |",						"\t  tuple := self min: trees.",						"\t  tree := tuple first.",						"\t  min := tree value content.",						"\t  representation := self",						"\t\t                    merge: ((tree key - 1 to: 0 by: -1) asValueLink",						"\t\t\t\t                     with: tree value children",						"\t\t\t\t                     collect: #->) reversed",						"\t\t                    with: tuple second.",						"\t  min ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 3097516,					"argumentNames" : [ ]				},				"CTCategoryTest" : {					"sourceCode" : [						"pop",						"",						"\t^ [ :link | link value -> link nextLink ] asState asCategory"					],					"body" : [						"^ [ :link | link value -> link nextLink ] asState asCategory"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 3193540,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolCircular" : {					"sourceCode" : [						"pop",						"",						"\t^ self isEmpty",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | removingLink |",						"\t\t\t  removingLink := head nextLink.",						"\t\t\t  head",						"\t\t\t\t  value: head value - 1;",						"\t\t\t\t  nextLink: removingLink nextLink.",						"\t\t\t  removingLink value yourself: [ self releaseLink: removingLink ] ]"					],					"body" : [						"^ self isEmpty",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | removingLink |",						"\t\t  removingLink := head nextLink.",						"\t\t  head",						"\t\t\t  value: head value - 1;",						"\t\t\t  nextLink: removingLink nextLink.",						"\t\t  removingLink value yourself: [ self releaseLink: removingLink ] ]"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 3345469,					"argumentNames" : [ ]				},				"CTHeapQ" : {					"sourceCode" : [						"pop",						"",						"\t^ self isEmpty",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | lastelt |",						"\t\t\t  lastelt := heap at: tally.",						"",						"\t\t\t  tally := tally - 1.",						"",						"\t\t\t  self isEmpty",						"\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t  indexes removeKey: lastelt.",						"",						"\t\t\t\t\t  lastelt ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  | returnElt |",						"\t\t\t\t\t  returnElt := heap first.",						"\t\t\t\t\t  indexes removeKey: returnElt.",						"",						"\t\t\t\t\t  self",						"\t\t\t\t\t\t  at: 1 put: lastelt;",						"\t\t\t\t\t\t  siftUp: 1.",						"",						"\t\t\t\t\t  returnElt ] ]"					],					"body" : [						"^ self isEmpty",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | lastelt |",						"\t\t  lastelt := heap at: tally.",						"",						"\t\t  tally := tally - 1.",						"",						"\t\t  self isEmpty",						"\t\t\t  ifTrue: [ ",						"\t\t\t\t  indexes removeKey: lastelt.",						"",						"\t\t\t\t  lastelt ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  | returnElt |",						"\t\t\t\t  returnElt := heap first.",						"\t\t\t\t  indexes removeKey: returnElt.",						"",						"\t\t\t\t  self",						"\t\t\t\t\t  at: 1 put: lastelt;",						"\t\t\t\t\t  siftUp: 1.",						"",						"\t\t\t\t  returnElt ] ]"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 3622022,					"argumentNames" : [ ]				},				"IRStackCount" : {					"sourceCode" : [						"pop",						"",						"\t^ self pop: 1"					],					"body" : [						"^ self pop: 1"					],					"isTestMethod" : false,					"category" : "affecting",					"comment" : [ ],					"hash" : 2029777,					"argumentNames" : [ ]				},				"Context" : {					"sourceCode" : [						"pop",						"",						"\t\"Answer the top of the receiver's stack and remove the top of the stack.\"",						"",						"\t| value |",						"\tvalue := self at: stackp.",						"\tself stackp: stackp - 1.",						"\t^ value"					],					"body" : [						"| value |",						"value := self at: stackp.",						"self stackp: stackp - 1.",						"^ value"					],					"isTestMethod" : false,					"category" : "controlling",					"comment" : [						"Answer the top of the receiver's stack and remove the top of the stack."					],					"hash" : 1066920,					"argumentNames" : [ ]				},				"FLSimpleStack" : {					"sourceCode" : [						"pop",						"",						"\t\"Returns the first element and remove it from the stack.\"",						"",						"\tslotIndex := slotIndex - 1.",						"\t^ array at: slotIndex"					],					"body" : [						"slotIndex := slotIndex - 1.",						"^ array at: slotIndex"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Returns the first element and remove it from the stack."					],					"hash" : 1539972,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolStack" : {					"sourceCode" : [						"pop",						"",						"\t^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t\t  | p |",						"\t\t  p := top.",						"\t\t  top := top nextLink.",						"\t\t  p value yourself: [ self releaseLink: p ] ]"					],					"body" : [						"^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t  | p |",						"\t  p := top.",						"\t  top := top nextLink.",						"\t  p value yourself: [ self releaseLink: p ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 3352004,					"argumentNames" : [ ]				},				"FileSystemGuide" : {					"sourceCode" : [						"pop",						"",						"\t^ work removeLast"					],					"body" : [						"^ work removeLast"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [ ],					"hash" : 2068772,					"argumentNames" : [ ]				},				"Stack" : {					"sourceCode" : [						"pop",						"",						"\t\"Returns the first element and remove it from the stack.\"",						"",						"\t^ self removeFirst"					],					"body" : [						"^ self removeFirst"					],					"isTestMethod" : false,					"category" : "removing",					"comment" : [						"Returns the first element and remove it from the stack."					],					"hash" : 1938287,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolQueue" : {					"sourceCode" : [						"pop",						"",						"\t^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t\t  | p |",						"\t\t  p := top.",						"\t\t  top := top nextLink.",						"\t\t  p value yourself: [ ",						"\t\t\t  self releaseLink: p.",						"\t\t\t  top ifNil: [ bottom := top ] ] ]"					],					"body" : [						"^ top ifNil: [ CollectionIsEmpty signal ] ifNotNil: [ ",						"\t  | p |",						"\t  p := top.",						"\t  top := top nextLink.",						"\t  p value yourself: [ ",						"\t\t  self releaseLink: p.",						"\t\t  top ifNil: [ bottom := top ] ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 3352516,					"argumentNames" : [ ]				},				"CTLinkedStoragePoolCircularDoubly" : {					"sourceCode" : [						"pop",						"",						"\t^ head nextLink == head",						"\t\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | removingLink |",						"\t\t\t  removingLink := head nextLink.",						"\t\t\t  removingLink previousLink nextLink: removingLink nextLink.",						"\t\t\t  removingLink nextLink previousLink: removingLink previousLink.",						"\t\t\t  removingLink value yourself: [ ",						"\t\t\t\t  head value: head value - 1.",						"\t\t\t\t  self releaseLink: removingLink ] ]"					],					"body" : [						"^ head nextLink == head",						"\t  ifTrue: [ CollectionIsEmpty signal ]",						"\t  ifFalse: [ ",						"\t\t  | removingLink |",						"\t\t  removingLink := head nextLink.",						"\t\t  removingLink previousLink nextLink: removingLink nextLink.",						"\t\t  removingLink nextLink previousLink: removingLink previousLink.",						"\t\t  removingLink value yourself: [ ",						"\t\t\t  head value: head value - 1.",						"\t\t\t  self releaseLink: removingLink ] ]"					],					"isTestMethod" : false,					"category" : "API-remotes",					"comment" : [ ],					"hash" : 3346265,					"argumentNames" : [ ]				},				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"pop",						"",						"\t^ self root yourself: [ ",						"\t\t  representation := representation popInBinaryTree: self ]"					],					"body" : [						"^ self root yourself: [ ",						"\t  representation := representation popInBinaryTree: self ]"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3095073,					"argumentNames" : [ ]				},				"LIFOQueue" : {					"sourceCode" : [						"pop",						"",						"\t^ self nextIfNone: [ self errorEmptyStack ]"					],					"body" : [						"^ self nextIfNone: [ self errorEmptyStack ]"					],					"isTestMethod" : false,					"category" : "stack-compliant protocol",					"comment" : [ ],					"hash" : 1888141,					"argumentNames" : [ ]				}			}		},		"mergeBinaryTreeElement:inBinaryTree:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract>>#push:",				"CTBinaryTreeAbstract class>>#withArrayedCollection:",				"CTBinaryTreeNode>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNode>>#popInBinaryTree:",				"CTBinaryTreeNodeBalanced>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeLeftistHeap>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeSplayHeap>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeUnbalanced>>#mergeBinaryTreeElement:inBinaryTree:"			],			"implementors" : {				"CTBinaryTreeElement" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\tself subclassResponsibility"					],					"body" : [						"self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37172036,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeNodeSplayHeap" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t^ aBTElement",						"\t\t  partition: value",						"\t\t  inSplayHeap: aBinaryTree",						"\t\t  do: [ :l :r | ",						"\t\t\t  | lMerged rMerged |",						"\t\t\t  lMerged := l",						"\t\t\t\t             mergeBinaryTreeElement: previousLink",						"\t\t\t\t             inBinaryTree: aBinaryTree.",						"\t\t\t  rMerged := r",						"\t\t\t\t             mergeBinaryTreeElement: nextLink",						"\t\t\t\t             inBinaryTree: aBinaryTree.",						"\t\t\t  aBinaryTree",						"\t\t\t\t  leftBinaryTreeElement: lMerged",						"\t\t\t\t  value: value",						"\t\t\t\t  rightBinaryTreeElement: rMerged ]"					],					"body" : [						"^ aBTElement partition: value inSplayHeap: aBinaryTree do: [ :l :r | ",						"\t  | lMerged rMerged |",						"\t  lMerged := l",						"\t\t             mergeBinaryTreeElement: previousLink",						"\t\t             inBinaryTree: aBinaryTree.",						"\t  rMerged := r",						"\t\t             mergeBinaryTreeElement: nextLink",						"\t\t             inBinaryTree: aBinaryTree.",						"\t  aBinaryTree",						"\t\t  leftBinaryTreeElement: lMerged",						"\t\t  value: value",						"\t\t  rightBinaryTreeElement: rMerged ]"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37187181,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeNodeUnbalanced" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t| lesserTree greaterTree tree |",						"\tself value < aBTElement value",						"\t\tifTrue: [ ",						"\t\t\tlesserTree := self.",						"\t\t\tgreaterTree := aBTElement ]",						"\t\tifFalse: [ ",						"\t\t\tlesserTree := aBTElement.",						"\t\t\tgreaterTree := self ].",						"",						"\ttree := lesserTree nextLink",						"\t\t        mergeBinaryTreeElement: greaterTree",						"\t\t        inBinaryTree: aBinaryTree.",						"",						"\t^ aBinaryTree",						"\t\t  leftBinaryTreeElement: lesserTree previousLink",						"\t\t  value: lesserTree value",						"\t\t  rightBinaryTreeElement: tree"					],					"body" : [						"| lesserTree greaterTree tree |",						"self value < aBTElement value",						"\tifTrue: [ ",						"\t\tlesserTree := self.",						"\t\tgreaterTree := aBTElement ]",						"\tifFalse: [ ",						"\t\tlesserTree := aBTElement.",						"\t\tgreaterTree := self ].",						"",						"tree := lesserTree nextLink",						"\t        mergeBinaryTreeElement: greaterTree",						"\t        inBinaryTree: aBinaryTree.",						"",						"^ aBinaryTree",						"\t  leftBinaryTreeElement: lesserTree previousLink",						"\t  value: lesserTree value",						"\t  rightBinaryTreeElement: tree"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37969279,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeNodeBalanced" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t| repr |",						"\trepr := super",						"\t\t        mergeBinaryTreeElement: aBTElement",						"\t\t        inBinaryTree: aBinaryTree.",						"\t^ self balance: repr inSet: aBinaryTree"					],					"body" : [						"| repr |",						"repr := super",						"\t        mergeBinaryTreeElement: aBTElement",						"\t        inBinaryTree: aBinaryTree.",						"^ self balance: repr inSet: aBinaryTree"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37443000,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeNodeLeftistHeap" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t^ aBTElement ifEmpty: [ self ] ifNotEmpty: [ ",						"\t\t  | y |",						"\t\t  y := aBTElement value.",						"\t\t  ((aBinaryTree is: value lessThan: y) or: [ ",						"\t\t\t   aBinaryTree is: value equalTo: y ])",						"\t\t\t  ifTrue: [ ",						"\t\t\t\t  | r |",						"\t\t\t\t  r := nextLink",						"\t\t\t\t\t       mergeBinaryTreeElement: aBTElement",						"\t\t\t\t\t       inBinaryTree: aBinaryTree.",						"\t\t\t\t  self",						"\t\t\t\t\t  insert: value",						"\t\t\t\t\t  left: previousLink",						"\t\t\t\t\t  right: r",						"\t\t\t\t\t  inBinaryTree: aBinaryTree ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  | r |",						"\t\t\t\t  r := self",						"\t\t\t\t\t       mergeBinaryTreeElement: aBTElement nextLink",						"\t\t\t\t\t       inBinaryTree: aBinaryTree.",						"\t\t\t\t  self",						"\t\t\t\t\t  insert: y",						"\t\t\t\t\t  left: aBTElement previousLink",						"\t\t\t\t\t  right: r",						"\t\t\t\t\t  inBinaryTree: aBinaryTree ] ]"					],					"body" : [						"^ aBTElement ifEmpty: [ self ] ifNotEmpty: [ ",						"\t  | y |",						"\t  y := aBTElement value.",						"\t  ((aBinaryTree is: value lessThan: y) or: [ ",						"\t\t   aBinaryTree is: value equalTo: y ])",						"\t\t  ifTrue: [ ",						"\t\t\t  | r |",						"\t\t\t  r := nextLink",						"\t\t\t\t       mergeBinaryTreeElement: aBTElement",						"\t\t\t\t       inBinaryTree: aBinaryTree.",						"\t\t\t  self",						"\t\t\t\t  insert: value",						"\t\t\t\t  left: previousLink",						"\t\t\t\t  right: r",						"\t\t\t\t  inBinaryTree: aBinaryTree ]",						"\t\t  ifFalse: [ ",						"\t\t\t  | r |",						"\t\t\t  r := self",						"\t\t\t\t       mergeBinaryTreeElement: aBTElement nextLink",						"\t\t\t\t       inBinaryTree: aBinaryTree.",						"\t\t\t  self",						"\t\t\t\t  insert: y",						"\t\t\t\t  left: aBTElement previousLink",						"\t\t\t\t  right: r",						"\t\t\t\t  inBinaryTree: aBinaryTree ] ]"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37189925,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeNode" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t^ (Random seed: 13) fairCoin",						"\t\t  ifHead: [ ",						"\t\t\t  | link |",						"\t\t\t  link := previousLink",						"\t\t\t\t          mergeBinaryTreeElement: aBTElement",						"\t\t\t\t          inBinaryTree: aBinaryTree.",						"",						"\t\t\t  aBinaryTree",						"\t\t\t\t  leftBinaryTreeElement: link",						"\t\t\t\t  value: value",						"\t\t\t\t  rightBinaryTreeElement: nextLink ]",						"\t\t  ifTail: [ ",						"\t\t\t  | link |",						"\t\t\t  link := nextLink",						"\t\t\t\t          mergeBinaryTreeElement: aBTElement",						"\t\t\t\t          inBinaryTree: aBinaryTree.",						"",						"\t\t\t  aBinaryTree",						"\t\t\t\t  leftBinaryTreeElement: previousLink",						"\t\t\t\t  value: value",						"\t\t\t\t  rightBinaryTreeElement: link ]"					],					"body" : [						"^ (Random seed: 13) fairCoin",						"\t  ifHead: [ ",						"\t\t  | link |",						"\t\t  link := previousLink",						"\t\t\t          mergeBinaryTreeElement: aBTElement",						"\t\t\t          inBinaryTree: aBinaryTree.",						"",						"\t\t  aBinaryTree",						"\t\t\t  leftBinaryTreeElement: link",						"\t\t\t  value: value",						"\t\t\t  rightBinaryTreeElement: nextLink ]",						"\t  ifTail: [ ",						"\t\t  | link |",						"\t\t  link := nextLink",						"\t\t\t          mergeBinaryTreeElement: aBTElement",						"\t\t\t          inBinaryTree: aBinaryTree.",						"",						"\t\t  aBinaryTree",						"\t\t\t  leftBinaryTreeElement: previousLink",						"\t\t\t  value: value",						"\t\t\t  rightBinaryTreeElement: link ]"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37174019,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				},				"CTBinaryTreeEmpty" : {					"sourceCode" : [						"mergeBinaryTreeElement: aBTElement inBinaryTree: aBinaryTree",						"",						"\t^ aBTElement"					],					"body" : [						"^ aBTElement"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 37172177,					"argumentNames" : [						"aBTElement",						"aBinaryTree"					]				}			}		},		"root" : {			"senders" : [				"AbsolutePath>>#withParents",				"AbsolutePath class>>#from:delimiter:",				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract>>#pop",				"CTBinaryTreeAbstract>>#root",				"CTBinaryTreeNodeSplayHeap>>#root",				"CTSlotDescriptorsVisitor>>#visitCTBinaryTreeAbstract:",				"CollectVisitorTest>>#testBreadthFirst",				"CollectVisitorTest>>#testPostorder",				"CollectVisitorTest>>#testPreorder",				"DirectoryEntryTest>>#testRootEntry",				"DiskStore>>#rootEntry",				"FLDebuggerStackSerializer>>#serializeStackFromContext:toFileNamed:",				"FLMaterializer>>#decodeHeaderWith:",				"FLMaterializer class>>#materializeFromFileNamed:",				"FLMaterializer class>>#materializeFromByteArray:",				"FLSerializationTest>>#materialized",				"FLUserGuidesTest>>#testGZip",				"FLUserGuidesTest>>#testConsiderGlobal",				"FLUserGuidesTest>>#testFileStream",				"FLUserGuidesTest>>#testPluggableSubstitution",				"FileDialogWindow>>#initialDirectories",				"FileList>>#initialDirectoryList",				"FileList>>#volumeListIndex:",				"FileLocator class>>#root",				"FileReferenceTest>>#testBasename",				"FileReferenceTest>>#testLastFilesForExtensionBrokenPattern",				"FileReferenceTest>>#testGlob",				"FileReferenceTest>>#testNextNameForExtensionNegativeTesting",				"FileReferenceTest>>#testChildDirectories",				"FileReferenceTest>>#testBasenameWithoutExtension",				"FileReferenceTest>>#testRootReference",				"FileReferenceTest>>#testLastFilesForExtensionNegativeTesting",				"FileReferenceTest>>#testIsRoot",				"FileReferenceTest>>#testNextNameForExtensionBrokenPattern",				"FileReferenceTest>>#testChildFiles",				"FileReferenceTest>>#testLastFilesForExtension",				"FileReferenceTest>>#testRootParent",				"FileSystem>>#/",				"FileSystem>>#root",				"FileSystem class>>#root",				"FileSystemStore>>#defaultWorkingDirectory",				"FileSystemTest>>#testRootExists",				"FileSystemTest>>#testRootIsDirectory",				"FileSystemTest>>#testRootIsNotAFile",				"FileSystemTest>>#testRoot",				"IceGitCommit>>#fileSystem",				"IceNoCommit>>#fileSystem",				"IceUnknownCommit>>#fileSystem",				"IceWorkingCopy>>#fileSystem",				"MCFileTreeRepository class>>#urlAsFileReference:",				"MacOSResolver>>#systemLibrary",				"MemoryFileSystemTest>>#testCopyFromto",				"MemoryFileSystemTest>>#testEnsureCreateFileDoesNotOverwriteExistingContent",				"MemoryStore>>#nodeAt:",				"MemoryStore>>#nodeAt:ifPresent:ifAbsent:",				"MetacelloAbstractVersionConstructor>>#baseline:with:",				"MetacelloAbstractVersionConstructor>>#packageForVersion:overrides:",				"MetacelloAbstractVersionConstructor>>#repositoryForSpec:",				"MetacelloAbstractVersionConstructor>>#value:",				"MetacelloAbstractVersionConstructor>>#package:with:",				"MetacelloAbstractVersionConstructor>>#version:",				"MetacelloAbstractVersionConstructor>>#preLoadDoIt:",				"MetacelloAbstractVersionConstructor>>#configuration:with:",				"MetacelloAbstractVersionConstructor>>#setAuthorWithBlock:",				"MetacelloAbstractVersionConstructor>>#groupForVersion:with:",				"MetacelloAbstractVersionConstructor>>#project:with:",				"MetacelloAbstractVersionConstructor>>#preLoadDoItForSpec:",				"MetacelloAbstractVersionConstructor>>#removeGroupForVersion:",				"MetacelloAbstractVersionConstructor>>#className:",				"MetacelloAbstractVersionConstructor>>#setProject:withString:",				"MetacelloAbstractVersionConstructor>>#project:overrides:",				"MetacelloAbstractVersionConstructor>>#setConfiguration:withBlock:",				"MetacelloAbstractVersionConstructor>>#setBaseline:",				"MetacelloAbstractVersionConstructor>>#with:during:",				"MetacelloAbstractVersionConstructor>>#projectForVersion:overrides:",				"MetacelloAbstractVersionConstructor>>#setTimestampWithString:",				"MetacelloAbstractVersionConstructor>>#setProject:withBlock:",				"MetacelloAbstractVersionConstructor>>#setDescriptionWithString:",				"MetacelloAbstractVersionConstructor>>#setBlessingWithBlock:",				"MetacelloAbstractVersionConstructor>>#includes:",				"MetacelloAbstractVersionConstructor>>#supplyingAnswersForPackage:",				"MetacelloAbstractVersionConstructor>>#classNameForProject:",				"MetacelloAbstractVersionConstructor>>#versionString:",				"MetacelloAbstractVersionConstructor>>#package:",				"MetacelloAbstractVersionConstructor>>#import:",				"MetacelloAbstractVersionConstructor>>#projectPackage:",				"MetacelloAbstractVersionConstructor>>#project:copyFrom:with:",				"MetacelloAbstractVersionConstructor>>#setBlessingWithString:",				"MetacelloAbstractVersionConstructor>>#groupForVersion:overrides:",				"MetacelloAbstractVersionConstructor>>#group:with:",				"MetacelloAbstractVersionConstructor>>#fileForProject:",				"MetacelloAbstractVersionConstructor>>#projectForVersion:copyFrom:with:",				"MetacelloAbstractVersionConstructor>>#baseline:",				"MetacelloAbstractVersionConstructor>>#loads:",				"MetacelloAbstractVersionConstructor>>#packageForVersion:",				"MetacelloAbstractVersionConstructor>>#setPackage:withBlock:",				"MetacelloAbstractVersionConstructor>>#setAuthorWithString:",				"MetacelloAbstractVersionConstructor>>#setPackage:withString:",				"MetacelloAbstractVersionConstructor>>#name:",				"MetacelloAbstractVersionConstructor>>#importForVersion:",				"MetacelloAbstractVersionConstructor>>#removeProjectForVersion:",				"MetacelloAbstractVersionConstructor>>#repositories:",				"MetacelloAbstractVersionConstructor>>#removeGroup:",				"MetacelloAbstractVersionConstructor>>#timestamp:",				"MetacelloAbstractVersionConstructor>>#author:",				"MetacelloAbstractVersionConstructor>>#importForVersion:provides:",				"MetacelloAbstractVersionConstructor>>#import:provides:",				"MetacelloAbstractVersionConstructor>>#removeProject:",				"MetacelloAbstractVersionConstructor>>#operatorForProject:",				"MetacelloAbstractVersionConstructor>>#removePackageForVersion:",				"MetacelloAbstractVersionConstructor>>#requiresForPackage:",				"MetacelloAbstractVersionConstructor>>#file:",				"MetacelloAbstractVersionConstructor>>#versionStringForProject:",				"MetacelloAbstractVersionConstructor>>#project:",				"MetacelloAbstractVersionConstructor>>#loadsForProject:",				"MetacelloAbstractVersionConstructor>>#description:",				"MetacelloAbstractVersionConstructor>>#projectPackageForProject:",				"MetacelloAbstractVersionConstructor>>#repository:username:password:",				"MetacelloAbstractVersionConstructor>>#group:overrides:",				"MetacelloAbstractVersionConstructor>>#repositoriesForSpec:",				"MetacelloAbstractVersionConstructor>>#operator:",				"MetacelloAbstractVersionConstructor>>#setTimestampWithBlock:",				"MetacelloAbstractVersionConstructor>>#includesForPackage:",				"MetacelloAbstractVersionConstructor>>#requires:",				"MetacelloAbstractVersionConstructor>>#package:overrides:",				"MetacelloAbstractVersionConstructor>>#supplyingAnswers:",				"MetacelloAbstractVersionConstructor>>#fileForPackage:",				"MetacelloAbstractVersionConstructor>>#setDescriptionWithBlock:",				"MetacelloAbstractVersionConstructor>>#removePackage:",				"MetacelloAbstractVersionConstructor>>#repository:",				"MetacelloAbstractVersionConstructor>>#postLoadDoItForSpec:",				"MetacelloAbstractVersionConstructor>>#repositoryForSpec:username:password:",				"MetacelloAbstractVersionConstructor>>#nameForProject:",				"MetacelloAbstractVersionConstructor>>#blessing:",				"MetacelloAbstractVersionConstructor>>#postLoadDoIt:",				"MetacelloAbstractVersionConstructor>>#valueForValueHolder:",				"MetacelloScriptExecutor>>#execute:",				"MicFileResourceReference class>>#populateHosts",				"MicUrlResolver>>#initialize",				"Morph>>#root",				"OmFuelEntryReader>>#nextEntry",				"Path>>#parentUpTo:",				"Path class>>#from:delimiter:",				"PathTest>>#testParentUpTo",				"PathTest>>#testIsRoot",				"PathTest>>#testAbsolutePath",				"PathTest>>#testRootParent",				"PathTest>>#testWithParentsOnRootReturnRoot",				"PathTest>>#testRootPrintString",				"RSInspectableInteraction>>#inspectShape:",				"STONWriteReadTest>>#testMemoryFileReferences",				"SelectVisitorTest>>#testBreadthFirst",				"SelectVisitorTest>>#testPreorderSelect",				"SelectVisitorTest>>#testBreadthFirstSelect",				"SelectVisitorTest>>#testPostorder",				"SelectVisitorTest>>#testPreorder",				"SelectVisitorTest>>#testPostorderSelect",				"SettingsStonWriterTest>>#setUp",				"SourceFileArrayTest>>#testWriteSourceWritesInGivenSourceFileArray",				"SourceFileArrayTest>>#testRemoteStringWritesInGivenSourceFileArray",				"SourceFileArrayTest>>#testWriteToChangesFileInGivenSourceFileArray",				"SourceFileArrayTest>>#testWriteSourceWritesInGivenSourceFileArrayWithFlushDefering",				"SourceFileArrayTest>>#testRemoteStringReadsInGivenSourceFileArray",				"SpAbstractPresenter>>#window",				"SpAbstractPresenter>>#withWindowDo:",				"SpAbstractPresenter>>#hasWindow",				"SpAbstractPresenter>>#root",				"SpPresenter>>#isDisplayed",				"SystemSettingsPersistenceTest>>#setUp",				"TonelReaderTest>>#newMemoryFileSystemSnapshot:",				"TonelReaderTraitCompositionTest>>#readDefinitionOfClass:fromPackage:whitContent:",				"TonelRepositoryTest>>#newMemoryFileSystem",				"TonelWriterTest>>#testWriteSnapshot",				"TonelWriterTest>>#testWriteSnapshotWithoutOrganization",				"ZipArchiveTest>>#testCanUnzipFromFileName",				"ZipArchiveTest>>#testAddTreeWithContentInFileShouldSucceed",				"ZipArchiveTest>>#testAddTreeWhenNoContentInFileShouldSucceed",				"ZipArchiveTest>>#testAddTreeWithSubDirectoriesShouldSucceed",				"ZipArchiveTest>>#setUp",				"ZipStore>>#close",				"ZnFileUrlTest>>#testRoot",				"ZnFileUrlTest>>#testAsZnUrl",				"ZnFileUrlTest>>#testSpaces",				"ZnOptions class>>#globalDefault",				"ZnStaticFileDecoratorDelegateTest>>#testServeStaticFile",				"ZnUrl>>#asFileReference",				"ZnUrl>>#asFileReferenceWithRelativePath"			],			"implementors" : {				"CTBinaryTreeEmpty" : {					"sourceCode" : [						"root",						"",						"\tCollectionIsEmpty signal"					],					"body" : [						"CollectionIsEmpty signal"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3093786,					"argumentNames" : [ ]				},				"AbstractEnumerationVisitorTest" : {					"sourceCode" : [						"root",						"",						"\t^ filesystem / 'alpha'"					],					"body" : [						"^ filesystem / 'alpha'"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 5298735,					"argumentNames" : [ ]				},				"FLMaterialization" : {					"sourceCode" : [						"root",						"",						"\t^ root"					],					"body" : [						"^ root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 1602713,					"argumentNames" : [ ]				},				"MetacelloScriptEngine" : {					"sourceCode" : [						"root",						"",						"\t^ root"					],					"body" : [						"^ root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2341269,					"argumentNames" : [ ]				},				"FileSystem class" : {					"sourceCode" : [						"root",						"",						"\t^ self disk root"					],					"body" : [						"^ self disk root"					],					"isTestMethod" : false,					"category" : "*Filesystem-Disk",					"comment" : [ ],					"hash" : 2059010,					"argumentNames" : [ ]				},				"FileLocator class" : {					"sourceCode" : [						"root",						"",						"\t^ FileSystem disk root"					],					"body" : [						"^ FileSystem disk root"					],					"isTestMethod" : false,					"category" : "origins",					"comment" : [ ],					"hash" : 2061785,					"argumentNames" : [ ]				},				"Path class" : {					"sourceCode" : [						"root",						"",						"\t\"Answer the root path - ie, / on unix\"",						"",						"\t^ AbsolutePath new"					],					"body" : [						"^ AbsolutePath new"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"Answer the root path - ie, / on unix"					],					"hash" : 1627183,					"argumentNames" : [ ]				},				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"root",						"",						"\t^ representation root"					],					"body" : [						"^ representation root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 3094563,					"argumentNames" : [ ]				},				"CTBinaryTreeElement" : {					"sourceCode" : [						"root",						"",						"\tself subclassResponsibility"					],					"body" : [						"self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "evaluating",					"comment" : [ ],					"hash" : 3093316,					"argumentNames" : [ ]				},				"MetacelloAbstractVersionConstructor" : {					"sourceCode" : [						"root",						"",						"\t^ root"					],					"body" : [						"^ root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2330005,					"argumentNames" : [ ]				},				"FLSerialization" : {					"sourceCode" : [						"root",						"",						"\t^ root"					],					"body" : [						"^ root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 1604247,					"argumentNames" : [ ]				},				"CTBinaryTreeNode" : {					"sourceCode" : [						"root",						"",						"\t^ self value"					],					"body" : [						"^ self value"					],					"isTestMethod" : false,					"category" : "evaluating",					"comment" : [ ],					"hash" : 3094103,					"argumentNames" : [ ]				},				"MemoryStore" : {					"sourceCode" : [						"root",						"",						"\t^ root"					],					"body" : [						"^ root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2289045,					"argumentNames" : [ ]				},				"FileSystem" : {					"sourceCode" : [						"root",						"",						"\t\"Returns the root of the receiver filesystem, i.e. / on unix\"",						"",						"\t^ self referenceTo: Path root"					],					"body" : [						"^ self referenceTo: Path root"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [						"Returns the root of the receiver filesystem, i.e. / on unix"					],					"hash" : 2068534,					"argumentNames" : [ ]				},				"Morph" : {					"sourceCode" : [						"root",						"",						"\t\"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph.\"",						"",						"\t(owner isNil or: [ owner isWorldOrHandMorph ]) ifTrue: [ ^ self ].",						"\t^ owner root"					],					"body" : [						"(owner isNil or: [ owner isWorldOrHandMorph ]) ifTrue: [ ^ self ].",						"^ owner root"					],					"isTestMethod" : false,					"category" : "structure",					"comment" : [						"Return the root of the composite morph containing the receiver. The owner of the root is either nil, a WorldMorph, or a HandMorph. If the receiver's owner is nil, the root is the receiver itself. This method always returns a morph."					],					"hash" : 2468173,					"argumentNames" : [ ]				},				"SpAbstractPresenter" : {					"sourceCode" : [						"root",						"",						"\t\"Answer root presenter of this composition.\"",						"",						"\t^ self owner",						"\t\t  ifNotNil: [ :presenter | presenter root ]",						"\t\t  ifNil: [ self ]"					],					"body" : [						"^ self owner ifNotNil: [ :presenter | presenter root ] ifNil: [ self ]"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [						"Answer root presenter of this composition."					],					"hash" : 1670347,					"argumentNames" : [ ]				},				"ZnOptions class" : {					"sourceCode" : [						"root",						"",						"\t^ self onClass: self"					],					"body" : [						"^ self onClass: self"					],					"isTestMethod" : false,					"category" : "private",					"comment" : [ ],					"hash" : 2214092,					"argumentNames" : [ ]				},				"CTBinaryTreeNodeSplayHeap" : {					"sourceCode" : [						"root",						"",						"\t^ previousLink ifEmpty: [ value ] ifNotEmpty: [ previousLink root ]"					],					"body" : [						"^ previousLink ifEmpty: [ value ] ifNotEmpty: [ previousLink root ]"					],					"isTestMethod" : false,					"category" : "evaluating",					"comment" : [ ],					"hash" : 3108450,					"argumentNames" : [ ]				}			}		},		"partition:inSplayHeap:do:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeNodeSplayHeap>>#partitionLessThan:inSplayHeap:do:",				"CTBinaryTreeNodeSplayHeap>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeSplayHeap>>#partitionGreaterThanOrEqualTo:inSplayHeap:do:",				"CTSplayHeap>>#push:"			],			"implementors" : {				"CTBinaryTreeEmptySplayHeap" : {					"sourceCode" : [						"partition: pivot inSplayHeap: aHeap do: aBlock",						"",						"\t^ aBlock",						"\t\t  value: aHeap binaryTreeElementEmpty",						"\t\t  value: aHeap binaryTreeElementEmpty"					],					"body" : [						"^ aBlock",						"\t  value: aHeap binaryTreeElementEmpty",						"\t  value: aHeap binaryTreeElementEmpty"					],					"isTestMethod" : false,					"category" : "partitioning",					"comment" : [ ],					"hash" : 54225949,					"argumentNames" : [						"pivot",						"aHeap",						"aBlock"					]				},				"CTBinaryTreeNodeSplayHeap" : {					"sourceCode" : [						"partition: pivot inSplayHeap: aHeap do: aBlock",						"",						"\t^ (aHeap is: value lessThan: pivot)",						"\t\t  ifTrue: [ ",						"\t\t  self partitionLessThan: pivot inSplayHeap: aHeap do: aBlock ]",						"\t\t  ifFalse: [ ",						"\t\t\t  self",						"\t\t\t\t  partitionGreaterThanOrEqualTo: pivot",						"\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t  do: aBlock ]"					],					"body" : [						"^ (aHeap is: value lessThan: pivot)",						"\t  ifTrue: [ ",						"\t  self partitionLessThan: pivot inSplayHeap: aHeap do: aBlock ]",						"\t  ifFalse: [ ",						"\t\t  self",						"\t\t\t  partitionGreaterThanOrEqualTo: pivot",						"\t\t\t  inSplayHeap: aHeap",						"\t\t\t  do: aBlock ]"					],					"isTestMethod" : false,					"category" : "partitioning",					"comment" : [ ],					"hash" : 54227603,					"argumentNames" : [						"pivot",						"aHeap",						"aBlock"					]				}			}		},		"leftBinaryTreeElement:value:rightBinaryTreeElement:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract>>#binaryTreeElementLeaf:",				"CTBinaryTreeNode>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeBalanced>>#balance:inSet:",				"CTBinaryTreeNodeLeftistHeap>>#insert:left:right:inBinaryTree:",				"CTBinaryTreeNodeSplayHeap>>#partitionLessThan:inSplayHeap:do:",				"CTBinaryTreeNodeSplayHeap>>#mergeBinaryTreeElement:inBinaryTree:",				"CTBinaryTreeNodeSplayHeap>>#popInBinaryTree:",				"CTBinaryTreeNodeSplayHeap>>#partitionGreaterThanOrEqualTo:inSplayHeap:do:",				"CTBinaryTreeNodeUnbalanced>>#mergeBinaryTreeElement:inBinaryTree:",				"CTSplayHeap>>#push:"			],			"implementors" : {				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"leftBinaryTreeElement: l value: v rightBinaryTreeElement: r",						"",						"\t^ self binaryTreeElementNode",						"\t\t  previousLink: l;",						"\t\t  value: v;",						"\t\t  nextLink: r;",						"\t\t  yourself"					],					"body" : [						"^ self binaryTreeElementNode",						"\t  previousLink: l;",						"\t  value: v;",						"\t  nextLink: r;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 54214419,					"argumentNames" : [						"l",						"v",						"r"					]				}			}		},		"withCollection:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"Collection>>#asGCoordinates",				"Collection>>#asBinaryTree:",				"Collection>>#asGPoint",				"Collection>>#asGVector",				"GCoordinatesTest>>#testCoordinates",				"GCoordinatesTest>>#newInstance",				"GPoint class>>#withCollection:",				"GPointTest>>#testWithCollection",				"GVector class>>#withCollection:"			],			"implementors" : {				"GVector class" : {					"sourceCode" : [						"withCollection: aCollection",						"",						"\t^ self coordinates: (GCoordinates withCollection: aCollection)"					],					"body" : [						"^ self coordinates: (GCoordinates withCollection: aCollection)"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 24746631,					"argumentNames" : [						"aCollection"					]				},				"CTBinomialHeap class" : {					"sourceCode" : [						"withCollection: aCollection",						"",						"\t^ aCollection",						"\t\t  inject: self empty",						"\t\t  into: [ :aBinaryTree :each | aBinaryTree push: each ]"					],					"body" : [						"^ aCollection",						"\t  inject: self empty",						"\t  into: [ :aBinaryTree :each | aBinaryTree push: each ]"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 20136562,					"argumentNames" : [						"aCollection"					]				},				"CTBinaryTreeAbstract class" : {					"sourceCode" : [						"withCollection: aCollection",						"",						"\t^ aCollection",						"\t\t  inject: self empty",						"\t\t  into: [ :aBinaryTree :each | aBinaryTree push: each ]"					],					"body" : [						"^ aCollection",						"\t  inject: self empty",						"\t  into: [ :aBinaryTree :each | aBinaryTree push: each ]"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 20134258,					"argumentNames" : [						"aCollection"					]				},				"GPoint class" : {					"sourceCode" : [						"withCollection: aCollection",						"",						"\t^ self coordinates: (GCoordinates withCollection: aCollection)"					],					"body" : [						"^ self coordinates: (GCoordinates withCollection: aCollection)"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 24741511,					"argumentNames" : [						"aCollection"					]				},				"GCoordinates class" : {					"sourceCode" : [						"withCollection: aCollection",						"",						"\t^ self allSubclasses",						"\t\t  detect: [ :e | e numberOfDimensions = aCollection size ]",						"\t\t  ifFound: [ :class | ",						"\t\t\t  class basicNew",						"\t\t\t\t  initializeWith: aCollection asArray;",						"\t\t\t\t  yourself ]",						"\t\t  ifNone: [ ",						"\t\t  self error: 'This amount of coordinated is not yet managed.' ]"					],					"body" : [						"^ self allSubclasses",						"\t  detect: [ :e | e numberOfDimensions = aCollection size ]",						"\t  ifFound: [ :class | ",						"\t\t  class basicNew",						"\t\t\t  initializeWith: aCollection asArray;",						"\t\t\t  yourself ]",						"\t  ifNone: [ ",						"\t  self error: 'This amount of coordinated is not yet managed.' ]"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 24738880,					"argumentNames" : [						"aCollection"					]				}			}		},		"partitionLessThan:inSplayHeap:do:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeNodeSplayHeap>>#partition:inSplayHeap:do:"			],			"implementors" : {				"CTBinaryTreeNodeSplayHeap" : {					"sourceCode" : [						"partitionLessThan: pivot inSplayHeap: aHeap do: aBlock",						"",						"\t^ nextLink",						"\t\t  ifEmpty: [ aBlock value: self value: aHeap binaryTreeElementEmpty ]",						"\t\t  ifNotEmpty: [ ",						"\t\t\t  | y |",						"\t\t\t  y := nextLink value.",						"\t\t\t  (aHeap is: y lessThan: pivot)",						"\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t  nextLink nextLink",						"\t\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t\t  | ll l |",						"\t\t\t\t\t\t\t  ll := aHeap",						"\t\t\t\t\t\t\t\t        leftBinaryTreeElement: previousLink",						"\t\t\t\t\t\t\t\t        value: value",						"\t\t\t\t\t\t\t\t        rightBinaryTreeElement: nextLink previousLink.",						"\t\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: ll",						"\t\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t\t  aBlock value: l value: b ] ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  nextLink previousLink",						"\t\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t\t  | r l |",						"\t\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: previousLink",						"\t\t\t\t\t\t\t\t       value: value",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: nextLink nextLink.",						"\t\t\t\t\t\t\t  aBlock value: l value: r ] ] ]"					],					"body" : [						"^ nextLink",						"\t  ifEmpty: [ aBlock value: self value: aHeap binaryTreeElementEmpty ]",						"\t  ifNotEmpty: [ ",						"\t\t  | y |",						"\t\t  y := nextLink value.",						"\t\t  (aHeap is: y lessThan: pivot)",						"\t\t\t  ifTrue: [ ",						"\t\t\t\t  nextLink nextLink",						"\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t  | ll l |",						"\t\t\t\t\t\t  ll := aHeap",						"\t\t\t\t\t\t\t        leftBinaryTreeElement: previousLink",						"\t\t\t\t\t\t\t        value: value",						"\t\t\t\t\t\t\t        rightBinaryTreeElement: nextLink previousLink.",						"\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: ll",						"\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t  aBlock value: l value: b ] ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  nextLink previousLink",						"\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t  | r l |",						"\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: previousLink",						"\t\t\t\t\t\t\t       value: value",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: nextLink nextLink.",						"\t\t\t\t\t\t  aBlock value: l value: r ] ] ]"					],					"isTestMethod" : false,					"category" : "partitioning",					"comment" : [ ],					"hash" : 54226864,					"argumentNames" : [						"pivot",						"aHeap",						"aBlock"					]				}			}		},		"merge:with:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinomialHeap>>#merge:with:",				"CTBinomialHeap>>#pop",				"CTBinomialHeap class>>#withArrayedCollection:"			],			"implementors" : {				"CTBinomialHeap" : {					"sourceCode" : [						"merge: trees with: otherTrees",						"",						"\t^ trees ifNil: [ otherTrees ] ifNotNil: [ ",						"\t\t  otherTrees ifNil: [ trees ] ifNotNil: [ ",						"\t\t\t  | aTree anotherTree allButFirstTrees allButFirstOtherTrees aRank anotherRank |",						"\t\t\t  \"Getting rests of both collections of trees to merge.\"",						"\t\t\t  allButFirstTrees := trees nextLink.",						"\t\t\t  allButFirstOtherTrees := otherTrees nextLink.",						"",						"\t\t\t  \"Getting current topmost trees.\"",						"\t\t\t  aTree := trees value.",						"\t\t\t  anotherTree := otherTrees value.",						"",						"\t\t\t  \"Getting ranks.\"",						"\t\t\t  aRank := aTree key.",						"\t\t\t  anotherRank := anotherTree key.",						"",						"\t\t\t  \"Rank comparison via `#key`.\"",						"\t\t\t  aRank < anotherRank",						"\t\t\t\t  ifTrue: [ ",						"\t\t\t\t  aTree ~~> (self merge: allButFirstTrees with: otherTrees) ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  anotherRank < aRank",						"\t\t\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t\t  anotherTree",						"\t\t\t\t\t\t  ~~> (self merge: trees with: allButFirstOtherTrees) ]",						"\t\t\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t\t\t  | binomialTree mergedTrees |",						"\t\t\t\t\t\t\t  \"Invariant: both `aTree` and `anotherTree` have the *same* rank.\"",						"\t\t\t\t\t\t\t  binomialTree := aTree value linkBinomialTree:",						"\t\t\t\t\t\t\t\t                  anotherTree value.",						"\t\t\t\t\t\t\t  mergedTrees := self",						"\t\t\t\t\t\t\t\t                 merge: allButFirstTrees",						"\t\t\t\t\t\t\t\t                 with: allButFirstOtherTrees.",						"\t\t\t\t\t\t\t  self pushTree: aRank + 1 -> binomialTree onTrees: mergedTrees ] ] ] ]"					],					"body" : [						"^ trees ifNil: [ otherTrees ] ifNotNil: [ ",						"\t  otherTrees ifNil: [ trees ] ifNotNil: [ ",						"\t\t  | aTree anotherTree allButFirstTrees allButFirstOtherTrees aRank anotherRank |",						"\t\t  \"Getting rests of both collections of trees to merge.\"",						"\t\t  allButFirstTrees := trees nextLink.",						"\t\t  allButFirstOtherTrees := otherTrees nextLink.",						"",						"\t\t  \"Getting current topmost trees.\"",						"\t\t  aTree := trees value.",						"\t\t  anotherTree := otherTrees value.",						"",						"\t\t  \"Getting ranks.\"",						"\t\t  aRank := aTree key.",						"\t\t  anotherRank := anotherTree key.",						"",						"\t\t  \"Rank comparison via `#key`.\"",						"\t\t  aRank < anotherRank",						"\t\t\t  ifTrue: [ ",						"\t\t\t  aTree ~~> (self merge: allButFirstTrees with: otherTrees) ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  anotherRank < aRank",						"\t\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t  anotherTree ~~> (self merge: trees with: allButFirstOtherTrees) ]",						"\t\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t\t  | binomialTree mergedTrees |",						"\t\t\t\t\t\t  \"Invariant: both `aTree` and `anotherTree` have the *same* rank.\"",						"\t\t\t\t\t\t  binomialTree := aTree value linkBinomialTree:",						"\t\t\t\t\t\t\t                  anotherTree value.",						"\t\t\t\t\t\t  mergedTrees := self",						"\t\t\t\t\t\t\t                 merge: allButFirstTrees",						"\t\t\t\t\t\t\t                 with: allButFirstOtherTrees.",						"\t\t\t\t\t\t  self pushTree: aRank + 1 -> binomialTree onTrees: mergedTrees ] ] ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 39275803,					"argumentNames" : [						"trees",						"otherTrees"					]				}			}		},		"testPushOrderedCollection" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"testPushOrderedCollection",						"",						"\t^ self exportSlotsGraphOf:",						"\t\t  (self tree: (1 to: 20) asOrderedCollection)"					],					"body" : [						"^ self exportSlotsGraphOf: (self tree: (1 to: 20) asOrderedCollection)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3095856,					"argumentNames" : [ ]				}			}		},		"testPushDoubledObject" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTUnbalancedSetTest" : {					"sourceCode" : [						"testPushDoubledObject",						"",						"\t| set representation |",						"\tset := (1 to: 10) shuffled asUnbalancedSet.",						"\trepresentation := set representation.",						"",						"\tself exportSlotsGraphOf: set pathSuffix: 'original'.",						"",						"\tset",						"\t\tpush: 1;",						"\t\tpush: 5;",						"\t\tpush: 10.",						"",						"\tself assert: set representation equals: representation.",						"",						"\tset push: 0.",						"",						"\tself deny: set representation equals: representation.",						"",						"\t^ self exportSlotsGraphOf: set pathSuffix: 'augmented'"					],					"body" : [						"| set representation |",						"set := (1 to: 10) shuffled asUnbalancedSet.",						"representation := set representation.",						"",						"self exportSlotsGraphOf: set pathSuffix: 'original'.",						"",						"set",						"\tpush: 1;",						"\tpush: 5;",						"\tpush: 10.",						"",						"self assert: set representation equals: representation.",						"",						"set push: 0.",						"",						"self deny: set representation equals: representation.",						"",						"^ self exportSlotsGraphOf: set pathSuffix: 'augmented'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3632423,					"argumentNames" : [ ]				}			}		},		"asBinaryTree" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstractTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asBinaryTree",						"",						"\t^ self asBinaryTree: CTBinaryTreeAbstract"					],					"body" : [						"^ self asBinaryTree: CTBinaryTreeAbstract"					],					"isTestMethod" : false,					"category" : "*Containers-RedBlackSet",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"insert:left:right:inBinaryTree:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeNodeLeftistHeap>>#mergeBinaryTreeElement:inBinaryTree:"			],			"implementors" : {				"CTBinaryTreeNodeLeftistHeap" : {					"sourceCode" : [						"insert: aValue left: leftHeap right: rightHeap inBinaryTree: aBinaryTree",						"",						"\t| v w t |",						"\tv := leftHeap rank.",						"\tw := rightHeap rank.",						"\t(aBinaryTree is: v lessThan: w)",						"\t\tifTrue: [ ",						"\t\t\tt := aBinaryTree",						"\t\t\t\t     leftBinaryTreeElement: rightHeap",						"\t\t\t\t     value: aValue",						"\t\t\t\t     rightBinaryTreeElement: leftHeap.",						"\t\t\tt rank: v + 1 ]",						"\t\tifFalse: [ ",						"\t\t\tt := aBinaryTree",						"\t\t\t\t     leftBinaryTreeElement: leftHeap",						"\t\t\t\t     value: aValue",						"\t\t\t\t     rightBinaryTreeElement: rightHeap.",						"\t\t\tt rank: w + 1 ].",						"\t^ t"					],					"body" : [						"| v w t |",						"v := leftHeap rank.",						"w := rightHeap rank.",						"(aBinaryTree is: v lessThan: w)",						"\tifTrue: [ ",						"\t\tt := aBinaryTree",						"\t\t\t     leftBinaryTreeElement: rightHeap",						"\t\t\t     value: aValue",						"\t\t\t     rightBinaryTreeElement: leftHeap.",						"\t\tt rank: v + 1 ]",						"\tifFalse: [ ",						"\t\tt := aBinaryTree",						"\t\t\t     leftBinaryTreeElement: leftHeap",						"\t\t\t     value: aValue",						"\t\t\t     rightBinaryTreeElement: rightHeap.",						"\t\tt rank: w + 1 ].",						"^ t"					],					"isTestMethod" : false,					"category" : "actions",					"comment" : [ ],					"hash" : 72056464,					"argumentNames" : [						"aValue",						"leftHeap",						"rightHeap",						"aBinaryTree"					]				}			}		},		"testPushShuffledCollection" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"testPushShuffledCollection",						"",						"\t| shuffled |",						"\tshuffled := (1 to: 20) asOrderedCollection shuffleBy:",						"\t\t            (Random seed: 13).",						"",						"\tself",						"\t\tassert: shuffled",						"\t\tequals: #( 8 16 20 3 6 5 4 19 7 12 2 10 11 9 13 18 17 15 14 1 )",						"\t\t\t\tasOrderedCollection.",						"",						"\t^ self exportSlotsGraphOf: (self tree: shuffled)"					],					"body" : [						"| shuffled |",						"shuffled := (1 to: 20) asOrderedCollection shuffleBy:",						"\t            (Random seed: 13).",						"",						"self",						"\tassert: shuffled",						"\tequals: #( 8 16 20 3 6 5 4 19 7 12 2 10 11 9 13 18 17 15 14 1 )",						"\t\t\tasOrderedCollection.",						"",						"^ self exportSlotsGraphOf: (self tree: shuffled)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3359445,					"argumentNames" : [ ]				}			}		},		"binaryTreeElementEmpty" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract>>#binaryTreeElementLeaf:",				"CTBinaryTreeAbstract class>>#empty",				"CTBinaryTreeEmptySplayHeap>>#partition:inSplayHeap:do:",				"CTBinaryTreeNodeSplayHeap>>#partitionLessThan:inSplayHeap:do:",				"CTBinaryTreeNodeSplayHeap>>#partitionGreaterThanOrEqualTo:inSplayHeap:do:"			],			"implementors" : {				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"binaryTreeElementEmpty",						"",						"\t^ CTBinaryTreeEmpty new"					],					"body" : [						"^ CTBinaryTreeEmpty new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3094575,					"argumentNames" : [ ]				},				"CTUnbalancedSet" : {					"sourceCode" : [						"binaryTreeElementEmpty",						"",						"\t^ CTBinaryTreeEmptyUnbalanced new"					],					"body" : [						"^ CTBinaryTreeEmptyUnbalanced new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3103791,					"argumentNames" : [ ]				},				"CTSplayHeap" : {					"sourceCode" : [						"binaryTreeElementEmpty",						"",						"\t^ CTBinaryTreeEmptySplayHeap new"					],					"body" : [						"^ CTBinaryTreeEmptySplayHeap new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3106863,					"argumentNames" : [ ]				},				"CTRedBlackSet" : {					"sourceCode" : [						"binaryTreeElementEmpty",						"",						"\t^ CTBinaryTreeEmptyBalanced new"					],					"body" : [						"^ CTBinaryTreeEmptyBalanced new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3104303,					"argumentNames" : [ ]				},				"CTLeftistHeap" : {					"sourceCode" : [						"binaryTreeElementEmpty",						"",						"\t^ CTBinaryTreeEmptyLeftistHeap new"					],					"body" : [						"^ CTBinaryTreeEmptyLeftistHeap new"					],					"isTestMethod" : false,					"category" : "creating",					"comment" : [ ],					"hash" : 3109423,					"argumentNames" : [ ]				}			}		},		"asUnbalancedSet" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTUnbalancedSetTest>>#testPushDoubledObject",				"CTUnbalancedSetTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asUnbalancedSet",						"",						"\t^ self asBinaryTree: CTUnbalancedSet"					],					"body" : [						"^ self asBinaryTree: CTUnbalancedSet"					],					"isTestMethod" : false,					"category" : "*Containers-RedBlackSet",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"asBinaryTree:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"Collection>>#asBinaryTree",				"Collection>>#asSplayHeap",				"Collection>>#asUnbalancedSet",				"Collection>>#asBinomialHeap",				"Collection>>#asLeftistHeap",				"Collection>>#asRedBlackSet"			],			"implementors" : {				"ArrayedCollection" : {					"sourceCode" : [						"asBinaryTree: aClass",						"",						"\t^ aClass withArrayedCollection: self"					],					"body" : [						"^ aClass withArrayedCollection: self"					],					"isTestMethod" : false,					"category" : "*Containers-BinaryTreeAbstract",					"comment" : [ ],					"hash" : 18689472,					"argumentNames" : [						"aClass"					]				},				"Collection" : {					"sourceCode" : [						"asBinaryTree: aClass",						"",						"\t^ aClass withCollection: self"					],					"body" : [						"^ aClass withCollection: self"					],					"isTestMethod" : false,					"category" : "*Containers-BinaryTreeAbstract",					"comment" : [ ],					"hash" : 18684352,					"argumentNames" : [						"aClass"					]				}			}		},		"push:" : {			"senders" : [				"AITarjan>>#putOnStack:",				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"BaselineOfBookletDSst>>#scriptStoragePoolsForDoc",				"BreadthFirstGuide>>#show:",				"CTBinaryTreeAbstract class>>#withCollection:",				"CTBinomialHeap class>>#withCollection:",				"CTCategoryTest>>#stackStuffMonad",				"CTCategoryTest>>#stackManipMonad",				"CTCategoryTest>>#testMonadJoinState",				"CTDfsSCCsWalker>>#enteringShape:atLevel:",				"CTHeapQTest>>#testPushPop",				"CTLinkedStoragePoolArray2D>>#at:at:put:",				"CTLinkedStoragePoolCircularDoubly>>#push:",				"CTLinkedStoragePoolPolynomial class>>#termAssociations:",				"CTLinkedStoragePoolTest>>#testPopFromEmptyStack",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnStack",				"CTLinkedStoragePoolTest>>#testPopFromEmptyQueue",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnCircular",				"CTLinkedStoragePoolTest>>#testSomePushesThenPopsOnQueue",				"CTLinkedStoragePoolTest>>#testRemoveAllFromQueue",				"CTLinkedStoragePoolTest>>#testRemoveAllFromStack",				"CTLinkedStoragePoolTest>>#testPopFromEmptyCircular",				"CTRedBlackSet>>#push:",				"CTUnbalancedSetTest>>#testPushDoubledObject",				"CodeSimulationTest>>#testErrorCodeNotFoundIndexed",				"CodeSimulationTest>>#testErrorCodeNotFound",				"ConfigurableHistoryIterator>>#redoIfEmpty:",				"ConfigurableHistoryIterator>>#undoIfEmpty:",				"ConfigurableHistoryIterator>>#register:",				"Context>>#pushLiteralVariable:",				"Context>>#callPrimitive:",				"Context>>#jump",				"Context>>#pushReceiverVariable:",				"Context>>#return:to:",				"Context>>#pushReceiver",				"Context>>#return:from:",				"Context>>#doPrimitive:method:receiver:args:",				"Context>>#pushRemoteTemp:inVectorAt:",				"Context>>#pushActiveProcess",				"Context>>#pushClosureTemps:",				"Context>>#pushConstant:",				"Context>>#pushTemporaryVariable:",				"Context>>#pushFullClosure:numCopied:receiverOnStack:ignoreOuterContext:",				"Context>>#pushNewArrayOfSize:",				"Context>>#pushConsArrayWithElements:",				"Context>>#doDup",				"Context>>#pushActiveContext",				"Context class>>#contextEnsure:",				"Context class>>#contextOn:do:",				"DATarjanAlgorithm>>#push:",				"DATarjanAlgorithm>>#traverse:",				"FFIFunctionResolutionTest>>#pushInstVar:",				"FFIFunctionResolutionTest>>#pushLiteralVariable:",				"FFIFunctionResolutionTest>>#pushLiteral:",				"FFIFunctionResolutionTest>>#pushReceiver",				"FFIFunctionResolutionTest>>#pushTemp:",				"FLAnalysis>>#trace:",				"FLAnalysis>>#privateTrace:",				"FLAnalysis>>#run",				"FLSimpleStackTest>>#testPush",				"FLSimpleStackTest>>#testPop",				"FLSimpleStackTest>>#testGrow",				"FileSystemGuide>>#pushAll:",				"HiRulerBuilder>>#stackLinksFrom:in:",				"IRBuilder>>#pushScope:",				"IRBytecodeDecompiler>>#pushScope:numArgs:",				"IRStackCount>>#push",				"IRTranslator>>#pushOuterVectors:",				"IRTranslator>>#visitTempVector:",				"IRTranslator>>#pushScope:",				"LzwGifDecoder>>#handleCode:withPreviousCode:on:",				"MCScanner>>#next",				"MicInlineParser>>#pushNewOpener",				"MicrodownStyleHelpBuilder>>#helpTopicFromFormattedString:title:",				"PostorderGuide>>#pushTraverse:",				"PostorderGuide>>#pushVisit:",				"PreorderGuide>>#show:",				"Process>>#stepToHome:",				"RBRefactoryChangeManager>>#addUndo:",				"RBRefactoryChangeManager>>#addUndoPointer:",				"SindarinDebugger>>#skipAssignmentNodeWith:",				"SindarinDebugger>>#skipMessageNodeWith:",				"SpMenuPresenterBuilder>>#initialize",				"SpMenuPresenterBuilder>>#visitCommandGroup:",				"StackTest>>#testSize",				"StackTest>>#testPop",				"StackTest>>#testTop",				"StackTest>>#testEmptyError",				"StackTest>>#setUp",				"StackTest>>#testPush",				"TFRunner>>#executeCallback:",				"TypingVisitor>>#visitBlockNode:",				"TypingVisitor>>#initialize",				"WikiStyleHelpBuilder>>#helpTopicFromFormattedString:title:"			],			"implementors" : {				"Context" : {					"sourceCode" : [						"push: value",						"",						"\t\"Push value on the receiver's stack.\"",						"",						"\tself stackp: stackp + 1.",						"\tself at: stackp put: value"					],					"body" : [						"self stackp: stackp + 1.",						"self at: stackp put: value"					],					"isTestMethod" : false,					"category" : "controlling",					"comment" : [						"Push value on the receiver's stack."					],					"hash" : 17844140,					"argumentNames" : [						"value"					]				},				"CTDfsSCCsWalker" : {					"sourceCode" : [						"push: aShape",						"",						"\tsccShapeStack := ValueLink new",						"\t\t                 value: aShape;",						"\t\t                 nextLink: sccShapeStack;",						"\t\t                 yourself"					],					"body" : [						"sccShapeStack := ValueLink new",						"\t                 value: aShape;",						"\t                 nextLink: sccShapeStack;",						"\t                 yourself"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20156295,					"argumentNames" : [						"aShape"					]				},				"CTCategoryTest" : {					"sourceCode" : [						"push: anObject",						"",						"\t^ [ :link | nil -> (anObject ~~> link) ] asState asCategory"					],					"body" : [						"^ [ :link | nil -> (anObject ~~> link) ] asState asCategory"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20232966,					"argumentNames" : [						"anObject"					]				},				"CTSplayHeap" : {					"sourceCode" : [						"push: anObject",						"",						"\trepresentation := representation",						"\t\t                  partition: anObject",						"\t\t                  inSplayHeap: self",						"\t\t                  do: [ :l :r | ",						"\t\t\t                  self",						"\t\t\t\t                  leftBinaryTreeElement: l",						"\t\t\t\t                  value: anObject",						"\t\t\t\t                  rightBinaryTreeElement: r ]"					],					"body" : [						"representation := representation",						"\t                  partition: anObject",						"\t                  inSplayHeap: self",						"\t                  do: [ :l :r | ",						"\t\t                  self",						"\t\t\t                  leftBinaryTreeElement: l",						"\t\t\t                  value: anObject",						"\t\t\t                  rightBinaryTreeElement: r ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20147003,					"argumentNames" : [						"anObject"					]				},				"FileSystemGuide" : {					"sourceCode" : [						"push: anObject",						"",						"\twork add: anObject"					],					"body" : [						"work add: anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 19108426,					"argumentNames" : [						"anObject"					]				},				"CTRedBlackSet" : {					"sourceCode" : [						"push: anObject",						"",						"\tsuper push: anObject.",						"\trepresentation := representation asBlackNode"					],					"body" : [						"super push: anObject.",						"representation := representation asBlackNode"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20144463,					"argumentNames" : [						"anObject"					]				},				"LIFOQueue" : {					"sourceCode" : [						"push: anObject",						"",						"\t^ self nextPut: anObject"					],					"body" : [						"^ self nextPut: anObject"					],					"isTestMethod" : false,					"category" : "stack-compliant protocol",					"comment" : [ ],					"hash" : 18927251,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolCircular" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\tp := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead",						"\t\tvalue: head value + 1;",						"\t\tnextLink: p.",						"\t^ p"					],					"body" : [						"| p |",						"p := self allocateOrReuseLink",						"\t     value: anObject;",						"\t     nextLink: head nextLink;",						"\t     yourself.",						"head",						"\tvalue: head value + 1;",						"\tnextLink: p.",						"^ p"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 20384494,					"argumentNames" : [						"anObject"					]				},				"CTBinaryTreeAbstract" : {					"sourceCode" : [						"push: anObject",						"",						"\t| leaf |",						"\tleaf := self binaryTreeElementLeaf: anObject.",						"",						"\trepresentation := leaf",						"\t\t                  mergeBinaryTreeElement: representation",						"\t\t                  inBinaryTree: self"					],					"body" : [						"| leaf |",						"leaf := self binaryTreeElementLeaf: anObject.",						"",						"representation := leaf",						"\t                  mergeBinaryTreeElement: representation",						"\t                  inBinaryTree: self"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20396954,					"argumentNames" : [						"anObject"					]				},				"Stack" : {					"sourceCode" : [						"push: anObject",						"",						"\t\"Adds a new object of any kind on top of the stack.\"",						"",						"\tself addFirst: anObject.",						"\t^ anObject"					],					"body" : [						"self addFirst: anObject.",						"^ anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [						"Adds a new object of any kind on top of the stack."					],					"hash" : 18978010,					"argumentNames" : [						"anObject"					]				},				"DATarjanAlgorithm" : {					"sourceCode" : [						"push: aPDPackage",						"",						"\tstack push: aPDPackage.",						"\taPDPackage inStack: true \"use a flag to avoid stack access\""					],					"body" : [						"stack push: aPDPackage.",						"aPDPackage inStack: true \"use a flag to avoid stack access\""					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 22573909,					"argumentNames" : [						"aPDPackage"					]				},				"CTHeapQ" : {					"sourceCode" : [						"push: anObject",						"",						"\ttally = heap size ifTrue: [ heap := heap grownBy: tally ].",						"\ttally := tally + 1.",						"",						"\tself",						"\t\tat: tally put: anObject;",						"\t\tsiftDown: 1 to: tally.",						"",						"\t^ anObject"					],					"body" : [						"tally = heap size ifTrue: [ heap := heap grownBy: tally ].",						"tally := tally + 1.",						"",						"self",						"\tat: tally put: anObject;",						"\tsiftDown: 1 to: tally.",						"",						"^ anObject"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 20137093,					"argumentNames" : [						"anObject"					]				},				"CTBinomialHeap" : {					"sourceCode" : [						"push: x",						"",						"\trepresentation := self",						"\t\t                  pushTree: 0 -> (CTBinomialTree leaf: x)",						"\t\t                  onTrees: representation"					],					"body" : [						"representation := self",						"\t                  pushTree: 0 -> (CTBinomialTree leaf: x)",						"\t                  onTrees: representation"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20137043,					"argumentNames" : [						"x"					]				},				"CTLinkedStoragePoolQueue" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\tp := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     nextLink: nil;",						"\t\t     yourself.",						"\ttop ifNil: [ top := p ] ifNotNil: [ bottom nextLink: p ].",						"\tbottom := p"					],					"body" : [						"| p |",						"p := self allocateOrReuseLink",						"\t     value: anObject;",						"\t     nextLink: nil;",						"\t     yourself.",						"top ifNil: [ top := p ] ifNotNil: [ bottom nextLink: p ].",						"bottom := p"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20392948,					"argumentNames" : [						"anObject"					]				},				"CTUnbalancedSet" : {					"sourceCode" : [						"push: anObject",						"",						"\trepresentation := [ :hop | ",						"\t                  representation",						"\t\t                  push: anObject",						"\t\t                  witness: Object new",						"\t\t                  continuation: hop",						"\t\t                  inSet: self ] valueWithArgumentedExit"					],					"body" : [						"representation := [ :hop | ",						"                  representation",						"\t                  push: anObject",						"\t                  witness: Object new",						"\t                  continuation: hop",						"\t                  inSet: self ] valueWithArgumentedExit"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20143671,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolStack" : {					"sourceCode" : [						"push: anObject",						"",						"\ttop := self allocateOrReuseLink",						"\t\t       value: anObject;",						"\t\t       nextLink: top;",						"\t\t       yourself"					],					"body" : [						"top := self allocateOrReuseLink",						"\t       value: anObject;",						"\t       nextLink: top;",						"\t       yourself"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 20128644,					"argumentNames" : [						"anObject"					]				},				"IRStackCount" : {					"sourceCode" : [						"push: n",						"",						"\t(position := position + n) > length ifTrue: [ length := position ]"					],					"body" : [						"(position := position + n) > length ifTrue: [ length := position ]"					],					"isTestMethod" : false,					"category" : "affecting",					"comment" : [ ],					"hash" : 19069741,					"argumentNames" : [						"n"					]				},				"FLSimpleStack" : {					"sourceCode" : [						"push: anObject",						"",						"\t\"Adds a new object of any kind on top of the stack.\"",						"",						"\tarray at: slotIndex put: anObject.",						"\tarray size = slotIndex ifTrue: [ self grow ].",						"\tslotIndex := slotIndex + 1.",						"\t^ anObject"					],					"body" : [						"array at: slotIndex put: anObject.",						"array size = slotIndex ifTrue: [ self grow ].",						"slotIndex := slotIndex + 1.",						"^ anObject"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [						"Adds a new object of any kind on top of the stack."					],					"hash" : 18580552,					"argumentNames" : [						"anObject"					]				},				"CTLinkedStoragePoolCircularDoubly" : {					"sourceCode" : [						"push: anObject",						"",						"\t| p |",						"\t\"p := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     previousLink: head;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead nextLink previousLink: p.",						"\thead nextLink: p.",						"\t^ p\"",						"\tp := (super push: anObject)",						"\t\t     previousLink: head;",						"\t\t     yourself.",						"\thead nextLink nextLink previousLink: p.",						"\t^ p"					],					"body" : [						"| p |",						"\"p := self allocateOrReuseLink",						"\t\t     value: anObject;",						"\t\t     previousLink: head;",						"\t\t     nextLink: head nextLink;",						"\t\t     yourself.",						"\thead nextLink previousLink: p.",						"\thead nextLink: p.",						"\t^ p\"",						"p := (super push: anObject)",						"\t     previousLink: head;",						"\t     yourself.",						"head nextLink nextLink previousLink: p.",						"^ p"					],					"isTestMethod" : false,					"category" : "API-remotes",					"comment" : [ ],					"hash" : 20384095,					"argumentNames" : [						"anObject"					]				}			}		},		"tree:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstractTest>>#testPushOrderedCollection",				"CTBinaryTreeAbstractTest>>#testCreation",				"CTBinaryTreeAbstractTest>>#testPushShuffledCollection",				"CTBinaryTreeAbstractTest>>#testPushOrderedInterval",				"CTBinaryTreeAbstractTest>>#testPushShuffledInterval",				"CTSBRAL>>#incrementLastDigit",				"CTSBRAL>>#incrementDifferentAdjacentBits",				"CTSBRAL>>#incrementZero",				"CTSBRAL>>#incrementBy:onto:two:inARow:",				"CTSBRALBinaryTreeNode>>#decrementSBRAL:",				"CTSkipListTest>>#compiledMethods:wrapping:then:",				"ContinuationTest>>#testTwoInARow",				"IceGitIndex>>#commitWithMessage:andParents:",				"MTHandlerTest>>#exampleOpalCompiler",				"MTHandlerTest>>#compiledMethods:wrapping:then:",				"MTHandlerTest>>#testAddWithinDoObjectCentric",				"MTHandlerTest>>#testProfileSlowFibonacciMemoing",				"MTHandlerTest>>#testSelfSendBeforeRising",				"MTTProfilingCopying>>#compiledMethods:wrapping:then:",				"MTTemperaturePresenter>>#runInstallMethodTemperatureTrackersStCommand:",				"MTVisualizationsTest>>#testInspectProductToPropagating",				"MTVisualizationsTest>>#compiledMethods:wrapping:then:",				"MTVisualizationsTest>>#testSequenceableCollectionMergeSortWithoutCopying",				"MTVisualizationsTest>>#testSequenceableCollectionMergeSortPlugging"			],			"implementors" : {				"CTSplayHeapTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asSplayHeap"					],					"body" : [						"^ aCollection asSplayHeap"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20147811,					"argumentNames" : [						"aCollection"					]				},				"MTHandlerProfiling" : {					"sourceCode" : [						"tree: aTree",						"",						"\ttree := aTree"					],					"body" : [						"tree := aTree"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20112022,					"argumentNames" : [						"aTree"					]				},				"CTSBRALTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asSBRAL"					],					"body" : [						"^ aCollection asSBRAL"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20131427,					"argumentNames" : [						"aCollection"					]				},				"CTUnbalancedSetTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asUnbalancedSet"					],					"body" : [						"^ aCollection asUnbalancedSet"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20144739,					"argumentNames" : [						"aCollection"					]				},				"MTObservedDataset" : {					"sourceCode" : [						"tree: anObject",						"",						"\ttree := anObject"					],					"body" : [						"tree := anObject"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20114070,					"argumentNames" : [						"anObject"					]				},				"LGitCommitBuilder" : {					"sourceCode" : [						"tree: anLGitTree",						"",						"\ttree := anLGitTree"					],					"body" : [						"tree := anLGitTree"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 25180314,					"argumentNames" : [						"anLGitTree"					]				},				"CTRedBlackSetTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asRedBlackSet"					],					"body" : [						"^ aCollection asRedBlackSet"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20144227,					"argumentNames" : [						"aCollection"					]				},				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asBinaryTree"					],					"body" : [						"^ aCollection asBinaryTree"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20134499,					"argumentNames" : [						"aCollection"					]				},				"TwoInARowStar" : {					"sourceCode" : [						"tree: aTree",						"",						"\t| fst |",						"\tfst := Continuation currentDo: [ :here | ",						"\t\t       leave := here.",						"\t\t       self waddle: aTree.",						"\t\t       leave value: nil ].",						"\t^ fst isSymbol",						"\t\t  ifTrue: [ self T: fst ]",						"\t\t  ifFalse: [ false ]"					],					"body" : [						"| fst |",						"fst := Continuation currentDo: [ :here | ",						"\t       leave := here.",						"\t       self waddle: aTree.",						"\t       leave value: nil ].",						"^ fst isSymbol",						"\t  ifTrue: [ self T: fst ]",						"\t  ifFalse: [ false ]"					],					"isTestMethod" : false,					"category" : "API",					"comment" : [ ],					"hash" : 22527577,					"argumentNames" : [						"aTree"					]				},				"CTSBRAL" : {					"sourceCode" : [						"tree: aTree",						"",						"\trepresentation value: representation value -> aTree"					],					"body" : [						"representation value: representation value -> aTree"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 20131391,					"argumentNames" : [						"aTree"					]				},				"CTBinomialHeapTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asBinomialHeap"					],					"body" : [						"^ aCollection asBinomialHeap"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20138851,					"argumentNames" : [						"aCollection"					]				},				"CTLeftistHeapTest" : {					"sourceCode" : [						"tree: aCollection",						"",						"\t^ aCollection asLeftistHeap"					],					"body" : [						"^ aCollection asLeftistHeap"					],					"isTestMethod" : false,					"category" : "tests",					"comment" : [ ],					"hash" : 20150371,					"argumentNames" : [						"aCollection"					]				}			}		},		"testCreation" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"ComplexTest" : {					"sourceCode" : [						"testCreation",						"",						"\t\"self run: #testCreation\"",						"",						"\t| c |",						"\tc := 5 i.",						"\tself assert: c real = 0.",						"\tself assert: c imaginary = 5.",						"",						"\tc := 6 + 7 i.",						"\tself assert: c real = 6.",						"\tself assert: c imaginary = 7.",						"",						"\tc := 5.6 - 8 i.",						"\tself assert: c real = 5.6.",						"\tself assert: c imaginary = -8.",						"",						"\tc := Complex real: 10 imaginary: 5.",						"\tself assert: c real = 10.",						"\tself assert: c imaginary = 5.",						"",						"\tc := Complex abs: 5 arg: Float pi / 2.",						"\tself assert: c real rounded = 0.",						"\tself assert: c imaginary = 5"					],					"body" : [						"| c |",						"c := 5 i.",						"self assert: c real = 0.",						"self assert: c imaginary = 5.",						"",						"c := 6 + 7 i.",						"self assert: c real = 6.",						"self assert: c imaginary = 7.",						"",						"c := 5.6 - 8 i.",						"self assert: c real = 5.6.",						"self assert: c imaginary = -8.",						"",						"c := Complex real: 10 imaginary: 5.",						"self assert: c real = 10.",						"self assert: c imaginary = 5.",						"",						"c := Complex abs: 5 arg: Float pi / 2.",						"self assert: c real rounded = 0.",						"self assert: c imaginary = 5"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"self run: #testCreation"					],					"hash" : 3283137,					"argumentNames" : [ ]				},				"MCSnapshotTest" : {					"sourceCode" : [						"testCreation",						"",						"\t| d |",						"\td := self mockSnapshot definitions.",						"\tself assert: (d anySatisfy: [ :ea | ",						"\t\t\t ea isClassDefinition and: [ ea className = #MCMockClassA ] ]).",						"\tself assert: (d anySatisfy: [ :ea | ",						"\t\t\t ea isMethodDefinition and: [ ea selector = #mockClassExtension ] ]).",						"\tself assert: (d allSatisfy: [ :ea | ",						"\t\t\t ea isClassDefinition not or: [ ea category endsWith: 'Mocks' ] ])"					],					"body" : [						"| d |",						"d := self mockSnapshot definitions.",						"self assert: (d anySatisfy: [ :ea | ",						"\t\t ea isClassDefinition and: [ ea className = #MCMockClassA ] ]).",						"self assert: (d anySatisfy: [ :ea | ",						"\t\t ea isMethodDefinition and: [ ea selector = #mockClassExtension ] ]).",						"self assert: (d allSatisfy: [ :ea | ",						"\t\t ea isClassDefinition not or: [ ea category endsWith: 'Mocks' ] ])"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4860906,					"argumentNames" : [ ]				},				"MCClassDefinitionTest" : {					"sourceCode" : [						"testCreation",						"",						"\t| d |",						"\td := self mockClassA asClassDefinition.",						"\tself assert: d className equals: #MCMockClassA.",						"\tself assert: d superclassName equals: #MCMock.",						"\tself assert: d type equals: #normal.",						"\tself assert: d category equals: self mockCategoryName.",						"\tself assert: d instVarNames asArray equals: #( 'ivar' ).",						"\tself",						"\t\tassert: d classVarNames asArray",						"\t\tequals: #( 'CVar' 'InitializationOrder' ).",						"\tself assert: d classInstVarNames asArray equals: #(  ).",						"\tself assert: d comment isString.",						"\tself assert: d comment equals: self classAComment.",						"\tself",						"\t\tassert: d commentStamp",						"\t\tequals: self mockClassA organization commentStamp"					],					"body" : [						"| d |",						"d := self mockClassA asClassDefinition.",						"self assert: d className equals: #MCMockClassA.",						"self assert: d superclassName equals: #MCMock.",						"self assert: d type equals: #normal.",						"self assert: d category equals: self mockCategoryName.",						"self assert: d instVarNames asArray equals: #( 'ivar' ).",						"self",						"\tassert: d classVarNames asArray",						"\tequals: #( 'CVar' 'InitializationOrder' ).",						"self assert: d classInstVarNames asArray equals: #(  ).",						"self assert: d comment isString.",						"self assert: d comment equals: self classAComment.",						"self",						"\tassert: d commentStamp",						"\tequals: self mockClassA organization commentStamp"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 4852783,					"argumentNames" : [ ]				},				"CTOrderPreservingTreeTest" : {					"sourceCode" : [						"testCreation",						"",						"\tself assertEmpty: CTOrderPreservingTree new"					],					"body" : [						"self assertEmpty: CTOrderPreservingTree new"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3065332,					"argumentNames" : [ ]				},				"RBMethodNameTest" : {					"sourceCode" : [						"testCreation",						"",						"\t\"Yes this is stupid test but it would have save time to understand what should be passed as argument!\"",						"",						"\t| rbmethod |",						"\trbmethod := RBMethodName selector: #foo: arguments: #( 'x' ).",						"\tself assert: rbmethod selector equals: #foo:.",						"\tself assert: rbmethod arguments equals: #( 'x' )"					],					"body" : [						"| rbmethod |",						"rbmethod := RBMethodName selector: #foo: arguments: #( 'x' ).",						"self assert: rbmethod selector equals: #foo:.",						"self assert: rbmethod arguments equals: #( 'x' )"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"Yes this is stupid test but it would have save time to understand what should be passed as argument!"					],					"hash" : 6053433,					"argumentNames" : [ ]				},				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"testCreation",						"",						"\t^ self exportSlotsGraphOf: (self tree: {  })"					],					"body" : [						"^ self exportSlotsGraphOf: (self tree: {  })"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3095768,					"argumentNames" : [ ]				},				"BagTest" : {					"sourceCode" : [						"testCreation",						"",						"\t| bag |",						"\tbag := Bag new.",						"\tself assert: bag size equals: 0.",						"\tself assertEmpty: bag"					],					"body" : [						"| bag |",						"bag := Bag new.",						"self assert: bag size equals: 0.",						"self assertEmpty: bag"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 5448677,					"argumentNames" : [ ]				},				"FLIndexStreamTest" : {					"sourceCode" : [						"testCreation",						"",						"\tself indexStreamOn: #(  ) writeStream digits: 2"					],					"body" : [						"self indexStreamOn: #(  ) writeStream digits: 2"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 5921632,					"argumentNames" : [ ]				},				"UUIDPrimitivesTest" : {					"sourceCode" : [						"testCreation",						"",						"\t| uuid |",						"\tuuid := UUID new.",						"\tself assert: uuid size equals: 16.",						"\tself deny: uuid isNilUUID.",						"\tself assert: uuid asString size equals: 36"					],					"body" : [						"| uuid |",						"uuid := UUID new.",						"self assert: uuid size equals: 16.",						"self deny: uuid isNilUUID.",						"self assert: uuid asString size equals: 36"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 5357227,					"argumentNames" : [ ]				},				"KMShortcutTest" : {					"sourceCode" : [						"testCreation",						"",						"\tself assert: ($e asKeyCombination isKindOf: KMSingleKeyCombination).",						"\tself assert: ($e ctrl isKindOf: KMModifiedKeyCombination).",						"\tself assert:",						"\t\t($e ctrl alt shift command isKindOf: KMModifiedKeyCombination)"					],					"body" : [						"self assert: ($e asKeyCombination isKindOf: KMSingleKeyCombination).",						"self assert: ($e ctrl isKindOf: KMModifiedKeyCombination).",						"self assert:",						"\t($e ctrl alt shift command isKindOf: KMModifiedKeyCombination)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 6106096,					"argumentNames" : [ ]				},				"WideCharacterSetTest" : {					"sourceCode" : [						"testCreation",						"",						"\t\"By now, only creation method is newFrom:\"",						"",						"\t| cs1 wcs1 cs2 wcs2 byteString wideString |",						"\tbyteString := 'aeiouy'.",						"\twideString := 'aeiouy' copyWith: 340 asCharacter.",						"",						"\tcs1 := CharacterSet newFrom: byteString.",						"\twcs1 := WideCharacterSet newFrom: byteString.",						"\tself assert: wcs1 equals: cs1.",						"\tself assert: wcs1 size equals: byteString size.",						"",						"\tcs2 := CharacterSet newFrom: wideString.",						"\twcs2 := WideCharacterSet newFrom: wideString.",						"\tself assert: wcs2 equals: cs2.",						"\tself assert: wcs2 size equals: wideString size.",						"",						"\tself",						"\t\tshould: [ (byteString indexOfAnyOf: wcs1) = 1 ]",						"\t\tdescription: 'This should used optimized byteArrayMap method'.",						"\tself",						"\t\tshould: [ (byteString indexOfAnyOf: wcs2) = 1 ]",						"\t\tdescription: 'This should used optimized byteArrayMap method'.",						"",						"\tself",						"\t\tshould: [ ('bcd' indexOfAnyOf: wcs1) = 0 ]",						"\t\tdescription: 'This should used optimized byteArrayMap method'.",						"\tself",						"\t\tshould: [ ('bcd' indexOfAnyOf: wcs2) = 0 ]",						"\t\tdescription: 'This should used optimized byteArrayMap method'"					],					"body" : [						"| cs1 wcs1 cs2 wcs2 byteString wideString |",						"byteString := 'aeiouy'.",						"wideString := 'aeiouy' copyWith: 340 asCharacter.",						"",						"cs1 := CharacterSet newFrom: byteString.",						"wcs1 := WideCharacterSet newFrom: byteString.",						"self assert: wcs1 equals: cs1.",						"self assert: wcs1 size equals: byteString size.",						"",						"cs2 := CharacterSet newFrom: wideString.",						"wcs2 := WideCharacterSet newFrom: wideString.",						"self assert: wcs2 equals: cs2.",						"self assert: wcs2 size equals: wideString size.",						"",						"self",						"\tshould: [ (byteString indexOfAnyOf: wcs1) = 1 ]",						"\tdescription: 'This should used optimized byteArrayMap method'.",						"self",						"\tshould: [ (byteString indexOfAnyOf: wcs2) = 1 ]",						"\tdescription: 'This should used optimized byteArrayMap method'.",						"",						"self",						"\tshould: [ ('bcd' indexOfAnyOf: wcs1) = 0 ]",						"\tdescription: 'This should used optimized byteArrayMap method'.",						"self",						"\tshould: [ ('bcd' indexOfAnyOf: wcs2) = 0 ]",						"\tdescription: 'This should used optimized byteArrayMap method'"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [						"By now, only creation method is newFrom:"					],					"hash" : 6749541,					"argumentNames" : [ ]				},				"SortedCollectionTest" : {					"sourceCode" : [						"testCreation",						"",						"\t| collection |",						"\tcollection := #( 10 9 3 6 1 8 7 5 4 2 ) asSortedCollection.",						"\tself assert: collection equals: (1 to: 10) asSortedCollection"					],					"body" : [						"| collection |",						"collection := #( 10 9 3 6 1 8 7 5 4 2 ) asSortedCollection.",						"self assert: collection equals: (1 to: 10) asSortedCollection"					],					"isTestMethod" : true,					"category" : "tests - basic",					"comment" : [ ],					"hash" : 5422572,					"argumentNames" : [ ]				},				"GAngleTest" : {					"sourceCode" : [						"testCreation",						"",						"\tangle := 90 degrees.",						"\tself assert: angle equals: (GAngle degrees: 90).",						"",						"\tangle := 1 π radians.",						"\tself assert: angle equals: (GAngle radians: 1 π)"					],					"body" : [						"angle := 90 degrees.",						"self assert: angle equals: (GAngle degrees: 90).",						"",						"angle := 1 π radians.",						"self assert: angle equals: (GAngle radians: 1 π)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 7713427,					"argumentNames" : [ ]				}			}		},		"testPushShuffledInterval" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc"			],			"implementors" : {				"CTBinaryTreeAbstractTest" : {					"sourceCode" : [						"testPushShuffledInterval",						"",						"\t| shuffled |",						"\tshuffled := (1 to: 20) asArray shuffleBy: (Random seed: 13).",						"",						"\tself",						"\t\tassert: shuffled",						"\t\tequals: #( 8 16 20 3 6 5 4 19 7 12 2 10 11 9 13 18 17 15 14 1 ).",						"",						"\t^ self exportSlotsGraphOf: (self tree: shuffled)"					],					"body" : [						"| shuffled |",						"shuffled := (1 to: 20) asArray shuffleBy: (Random seed: 13).",						"",						"self",						"\tassert: shuffled",						"\tequals: #( 8 16 20 3 6 5 4 19 7 12 2 10 11 9 13 18 17 15 14 1 ).",						"",						"^ self exportSlotsGraphOf: (self tree: shuffled)"					],					"isTestMethod" : true,					"category" : "tests",					"comment" : [ ],					"hash" : 3359314,					"argumentNames" : [ ]				}			}		},		"pushingAlreadyIncluded:continuation:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeEmptyUnbalanced>>#push:witness:continuation:inSet:"			],			"implementors" : {				"CTUnbalancedSet" : {					"sourceCode" : [						"pushingAlreadyIncluded: anObject continuation: aContinuation",						"",						"\t^ aContinuation value: representation"					],					"body" : [						"^ aContinuation value: representation"					],					"isTestMethod" : false,					"category" : "as yet unclassified",					"comment" : [ ],					"hash" : 37182542,					"argumentNames" : [						"anObject",						"aContinuation"					]				}			}		},		"empty" : {			"senders" : [				"AIBFS>>#reconstructPath",				"AIBellmanFord>>#reconstructPath",				"AIDijkstra>>#reconstructPath",				"AIGraphReducer>>#replaceReferencesToMergedNode:",				"AIShortestPathInDAG>>#reconstructPath",				"AITarjan>>#addNewSccForNode:",				"ArrayTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"ArrayTest>>#testCopyEmptyWith",				"ArrayTest>>#testCopySameClass",				"ArrayTest>>#test0FixturePutOneOrMoreElementsTest",				"ArrayTest>>#testUnionOfEmpties",				"ArrayTest>>#testUnion",				"ArrayTest>>#testIncludesAllNoneThere",				"ArrayTest>>#testHasEqualElements",				"ArrayTest>>#testFindFirstNotIn",				"ArrayTest>>#testIncludesAnyNoneThere",				"ArrayTest>>#test0FixturePutTest",				"ArrayTest>>#testCopyEmptyWithoutAll",				"ArrayTest>>#testAsStringOnDelimiterEmpty",				"ArrayTest>>#testIncludesAnyAllThere",				"ArrayTest>>#testsBeginsWithEmpty",				"ArrayTest>>#testKeysAndValuesDoEmpty",				"ArrayTest>>#test0FixtureIterateSequencedReadableTest",				"ArrayTest>>#testCopyUpToEmpty",				"ArrayTest>>#testCopyEmptyWithout",				"ArrayTest>>#testCopyAfterLastEmpty",				"ArrayTest>>#testFindLastNotIn",				"ArrayTest>>#testCopyAfterEmpty",				"ArrayTest>>#testCopyEmpty",				"ArrayTest>>#testOccurrencesOfNotIn",				"ArrayTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"ArrayTest>>#testAtPutOutOfBounds",				"ArrayTest>>#testIncludesElementIsNotThere",				"ArrayTest>>#testAsStringOnDelimiterLastEmpty",				"ArrayTest>>#testOccurrencesOfEmpty",				"ArrayTest>>#testGroupsOfAtATimeCollect",				"ArrayTest>>#testConcatenationWithEmpty",				"ArrayTest>>#test0FixtureIncludeTest",				"ArrayTest>>#test0FixtureCopyPartOfSequenceableTest",				"ArrayTest>>#testsEndsWithEmpty",				"ArrayTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"ArrayTest>>#testEqualSignOfIdenticalCollectionObjects",				"ArrayTest>>#testReverseDoEmpty",				"ArrayTest>>#test0TStructuralEqualityTest",				"ArrayTest>>#test0CopyTest",				"ArrayTest>>#testFlatCollectAsWithEmptyCollection",				"ArrayTest>>#testShallowCopyEmpty",				"ArrayTest>>#test0FixtureBeginsEndsWithTest",				"ArrayTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"ArrayTest>>#testCopyUpToLastEmpty",				"ArrayTest>>#testDifference",				"ArrayTest>>#testWithDoError",				"ArrayTest>>#testAsCommaStringEmpty",				"ArrayTest>>#test0FixtureSequencedConcatenationTest",				"ArrayTest>>#test0FixtureCopySameContentsTest",				"ArrayTest>>#test0FixtureCloneTest",				"ArrayTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"ArrayTest>>#test0FixtureOccurrencesTest",				"ArrayTest>>#testEqualSign",				"ArrayTest>>#test0FixtureEmptySequenceableTest",				"ArrayTest>>#testWithCollectError",				"ArrayTest>>#testIntersectionEmpty",				"BagTest>>#testCopyEmptyWith",				"BagTest>>#testCopySameClass",				"BagTest>>#test0FixtureConcatenationTest",				"BagTest>>#testAsStringOnDelimiterLastEmpty",				"BagTest>>#testOccurrencesOfEmpty",				"BagTest>>#test0FixtureTRemoveTest",				"BagTest>>#testUnionOfEmpties",				"BagTest>>#test0FixtureIncludeTest",				"BagTest>>#testConcatenationWithEmpty",				"BagTest>>#testIncludesAllNoneThere",				"BagTest>>#testUnion",				"BagTest>>#testIncludesAnyNoneThere",				"BagTest>>#testCopyEmptyWithoutAll",				"BagTest>>#testAsStringOnDelimiterEmpty",				"BagTest>>#testEqualSignOfIdenticalCollectionObjects",				"BagTest>>#testIncludesAnyAllThere",				"BagTest>>#test0TStructuralEqualityTest",				"BagTest>>#test0CopyTest",				"BagTest>>#testRemoveElementFromEmpty",				"BagTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"BagTest>>#testDifference",				"BagTest>>#testAsCommaStringEmpty",				"BagTest>>#testCopyEmptyWithout",				"BagTest>>#test0FixtureCloneTest",				"BagTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"BagTest>>#test0FixtureOccurrencesTest",				"BagTest>>#testEqualSign",				"BagTest>>#testCopyEmpty",				"BagTest>>#testIntersectionEmpty",				"BagTest>>#testIncludesElementIsNotThere",				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeAbstract class>>#withArrayedCollection:",				"CTBinaryTreeAbstract class>>#withCollection:",				"CTBinomialHeap class>>#withArrayedCollection:",				"CTBinomialHeap class>>#withCollection:",				"CTSccDfsPainter>>#layoutTuples:lineBuilder:",				"CharacterSet class>>#separators",				"CharacterSet class>>#allCharacters",				"ClyBrowserQueryCache>>#initialize",				"ClyCompositeQueryTest>>#testNotExecutedFromMultipleScopeWhenSingleSubqueryIsFromEmptyScope",				"ClyCompositeQueryTest>>#testNotExecutedFromSingleScopeWhenAllSubqueriesAreFromEmptyScope",				"ClyCompositeQueryTest>>#testNotExecutedFromMultipleScopeWhenAllSubqueriesAreFromEmptyScope",				"ClyCompositeQueryTest>>#testIsExecutedFromEmptyScope",				"ClyNavigationEnvironmentTest>>#testCheckEmptyQueryWhenThereIsNoResultButItWouldBeEmpty",				"ClyNavigationEnvironmentTest>>#testCheckEmptyQueryWhenThereIsEmptyResult",				"ClyQueryViewMorph>>#initialize",				"ClyUnionQueryTest>>#testNotEmptyWhenThereIsNotEmptySubquery",				"ClyUnionQueryTest>>#testIsEmptyWhenAllSubqueriesAreEmpty",				"CoFetcher>>#initialize",				"CoResultSet>>#initialize",				"CoResultSet>>#resetFilter",				"Collection class>>#with:",				"CollectionRootTest>>#testSelectThenDoOnEmpty",				"CollectionRootTest>>#testIfNotEmptyifEmpty",				"CollectionRootTest>>#testBasicCollectEmpty",				"CollectionRootTest>>#testSelectThenCollectOnEmpty",				"CollectionRootTest>>#test0TSizeTest",				"CollectionRootTest>>#testIfEmptyifNotEmpty",				"CollectionRootTest>>#testRejectThenCollectEmpty",				"CollectionRootTest>>#testCollectOnEmpty",				"CollectionRootTest>>#testIfEmpty",				"CollectionRootTest>>#test0FixtureEmptyTest",				"CollectionRootTest>>#testCollectThenSelectOnEmpty",				"CollectionRootTest>>#testCollectThenDoOnEmpty",				"CollectionRootTest>>#testAllSatisfyEmpty",				"CollectionRootTest>>#testSelectOnEmpty",				"CollectionRootTest>>#testNotEmpty",				"CollectionRootTest>>#testIsEmpty",				"CollectionRootTest>>#testRejectEmpty",				"CollectionRootTest>>#testSize",				"CollectionRootTest>>#testIsEmptyOrNil",				"CollectionRootTest>>#testNoneSatisfyEmpty",				"CollectionRootTest>>#testIfNotEmpty",				"CollectionRootTest>>#testRejectThenDoOnEmpty",				"CompilationContext>>#compiledMethodTrailer",				"CompiledMethod>>#isEqualRegardlessTrailerTo:",				"CompiledMethod class>>#toReturnSelf",				"DTDefaultPluginPresenter>>#initializeResultsTreeAndLabel",				"DTResultTreeView>>#resultTreeFor:",				"DictionaryTest>>#testCopyEmptyWith",				"DictionaryTest>>#testCopySameClass",				"DictionaryTest>>#testUnionOfEmpties",				"DictionaryTest>>#testUnion",				"DictionaryTest>>#testIncludesAllNoneThere",				"DictionaryTest>>#testIncludesAnyNoneThere",				"DictionaryTest>>#test0FixturePutTest",				"DictionaryTest>>#testCopyEmptyWithoutAll",				"DictionaryTest>>#testAsStringOnDelimiterEmpty",				"DictionaryTest>>#testIncludesAnyAllThere",				"DictionaryTest>>#testCopyEmpty",				"DictionaryTest>>#testIncludesElementIsNotThere",				"DictionaryTest>>#testAsStringOnDelimiterLastEmpty",				"DictionaryTest>>#testOccurrencesOfEmpty",				"DictionaryTest>>#test0FixtureIncludeTest",				"DictionaryTest>>#testEqualSignOfIdenticalCollectionObjects",				"DictionaryTest>>#test0TStructuralEqualityTest",				"DictionaryTest>>#test0CopyTest",				"DictionaryTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"DictionaryTest>>#testDifference",				"DictionaryTest>>#testOtherDictionaryEquality",				"DictionaryTest>>#testAsCommaStringEmpty",				"DictionaryTest>>#test0FixtureCloneTest",				"DictionaryTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"DictionaryTest>>#test0FixtureOccurrencesTest",				"DictionaryTest>>#testEqualSign",				"DictionaryTest>>#testIntersectionEmpty",				"Exception>>#messageText",				"FBDDecompiler>>#recompile:from:",				"FFICalloutMethodBuilderTestContext>>#trailer",				"FFIMockCalloutMethodBuilder>>#methodTrailer",				"FLCompiledMethodCluster class>>#setTrailerWithNoSource",				"FloatArrayTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"FloatArrayTest>>#testCopyEmptyWith",				"FloatArrayTest>>#testCopySameClass",				"FloatArrayTest>>#test0FixturePutOneOrMoreElementsTest",				"FloatArrayTest>>#testUnionOfEmpties",				"FloatArrayTest>>#testUnion",				"FloatArrayTest>>#testIncludesAllNoneThere",				"FloatArrayTest>>#testHasEqualElements",				"FloatArrayTest>>#testFindFirstNotIn",				"FloatArrayTest>>#testIncludesAnyNoneThere",				"FloatArrayTest>>#test0FixturePutTest",				"FloatArrayTest>>#testCopyEmptyWithoutAll",				"FloatArrayTest>>#testAsStringOnDelimiterEmpty",				"FloatArrayTest>>#testIncludesAnyAllThere",				"FloatArrayTest>>#testsBeginsWithEmpty",				"FloatArrayTest>>#testKeysAndValuesDoEmpty",				"FloatArrayTest>>#testCopyUpToEmpty",				"FloatArrayTest>>#test0FixtureIterateSequencedReadableTest",				"FloatArrayTest>>#testCopyEmptyWithout",				"FloatArrayTest>>#testCopyAfterLastEmpty",				"FloatArrayTest>>#testCopyAfterEmpty",				"FloatArrayTest>>#testFindLastNotIn",				"FloatArrayTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"FloatArrayTest>>#testCopyEmpty",				"FloatArrayTest>>#testAtPutOutOfBounds",				"FloatArrayTest>>#testIncludesElementIsNotThere",				"FloatArrayTest>>#testAsStringOnDelimiterLastEmpty",				"FloatArrayTest>>#testGroupsOfAtATimeCollect",				"FloatArrayTest>>#testConcatenationWithEmpty",				"FloatArrayTest>>#test0FixtureIncludeTest",				"FloatArrayTest>>#test0FixtureCopyPartOfSequenceableTest",				"FloatArrayTest>>#testsEndsWithEmpty",				"FloatArrayTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"FloatArrayTest>>#testEqualSignOfIdenticalCollectionObjects",				"FloatArrayTest>>#testReverseDoEmpty",				"FloatArrayTest>>#test0TStructuralEqualityTest",				"FloatArrayTest>>#test0CopyTest",				"FloatArrayTest>>#testShallowCopyEmpty",				"FloatArrayTest>>#test0FixtureBeginsEndsWithTest",				"FloatArrayTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"FloatArrayTest>>#testCopyUpToLastEmpty",				"FloatArrayTest>>#testDifference",				"FloatArrayTest>>#testWithDoError",				"FloatArrayTest>>#testAsCommaStringEmpty",				"FloatArrayTest>>#test0FixtureSequencedConcatenationTest",				"FloatArrayTest>>#test0FixtureCopySameContentsTest",				"FloatArrayTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"FloatArrayTest>>#test0FixtureCloneTest",				"FloatArrayTest>>#testEqualSign",				"FloatArrayTest>>#testWithCollectError",				"FloatArrayTest>>#testIntersectionEmpty",				"GoferOperationTest>>#testCleanup",				"HDChangeReport>>#changesFor:",				"HeapTest>>#testCopyEmptyWith",				"HeapTest>>#testCopySameClass",				"HeapTest>>#testOccurrencesOfEmpty",				"HeapTest>>#test0FixtureTRemoveTest",				"HeapTest>>#testUnionOfEmpties",				"HeapTest>>#test0FixtureIncludeTest",				"HeapTest>>#testUnion",				"HeapTest>>#testIncludesAllNoneThere",				"HeapTest>>#testIncludesAnyNoneThere",				"HeapTest>>#testCopyEmptyWithoutAll",				"HeapTest>>#testAddEmptyGrows",				"HeapTest>>#testIncludesAnyAllThere",				"HeapTest>>#test0CopyTest",				"HeapTest>>#testRemoveElementFromEmpty",				"HeapTest>>#testDifference",				"HeapTest>>#testCopyEmptyWithout",				"HeapTest>>#test0FixtureOccurrencesTest",				"HeapTest>>#test0FixtureRequirementsOfTGrowableTest",				"HeapTest>>#testIntersectionEmpty",				"HeapTest>>#testIncludesElementIsNotThere",				"IRBytecodeGenerator>>#compiledMethod",				"IRMethod>>#generate",				"IRMethod>>#compiledMethod",				"IRMethod>>#compiledBlock:",				"IRTranslator class>>#new",				"IceCommit>>#mcPackageSnapshotsOfPackages:",				"IceCommitish>>#snapshotForPackage:",				"IceGitCommit>>#snapshotFor:",				"IceGitWorkingCopyUpdateVisitor>>#visitPackage:",				"IceNoCommit>>#snapshotFor:",				"IceUnbornBranch>>#snapshotFor:",				"Integer>>#catalanNumbers",				"IntervalTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"IntervalTest>>#testCopyEmptyWith",				"IntervalTest>>#testCopySameClass",				"IntervalTest>>#testIncludesAllNoneThere",				"IntervalTest>>#testHasEqualElements",				"IntervalTest>>#testFindFirstNotIn",				"IntervalTest>>#testIncludesAnyNoneThere",				"IntervalTest>>#testCopyEmptyWithoutAll",				"IntervalTest>>#testAsStringOnDelimiterEmpty",				"IntervalTest>>#testIncludesAnyAllThere",				"IntervalTest>>#testsBeginsWithEmpty",				"IntervalTest>>#testKeysAndValuesDoEmpty",				"IntervalTest>>#test0FixtureIterateSequencedReadableTest",				"IntervalTest>>#testCopyUpToEmpty",				"IntervalTest>>#testCopyEmptyWithout",				"IntervalTest>>#testCopyAfterLastEmpty",				"IntervalTest>>#testCopyAfterEmpty",				"IntervalTest>>#testFindLastNotIn",				"IntervalTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"IntervalTest>>#testCopyEmpty",				"IntervalTest>>#testIncludesElementIsNotThere",				"IntervalTest>>#testAsStringOnDelimiterLastEmpty",				"IntervalTest>>#testOccurrencesOfEmpty",				"IntervalTest>>#testGroupsOfAtATimeCollect",				"IntervalTest>>#testConcatenationWithEmpty",				"IntervalTest>>#test0FixtureIncludeTest",				"IntervalTest>>#test0FixtureCopyPartOfSequenceableTest",				"IntervalTest>>#testsEndsWithEmpty",				"IntervalTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"IntervalTest>>#testEqualSignOfIdenticalCollectionObjects",				"IntervalTest>>#testReverseDoEmpty",				"IntervalTest>>#test0TStructuralEqualityTest",				"IntervalTest>>#test0CopyTest",				"IntervalTest>>#testShallowCopyEmpty",				"IntervalTest>>#test0FixtureBeginsEndsWithTest",				"IntervalTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"IntervalTest>>#testCopyUpToLastEmpty",				"IntervalTest>>#testWithDoError",				"IntervalTest>>#testAsCommaStringEmpty",				"IntervalTest>>#test0FixtureSequencedConcatenationTest",				"IntervalTest>>#test0FixtureCopySameContentsTest",				"IntervalTest>>#test0FixtureCloneTest",				"IntervalTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"IntervalTest>>#test0FixtureOccurrencesTest",				"IntervalTest>>#testEqualSign",				"IntervalTest>>#testWithCollectError",				"LinkedListTest>>#testCopyEmptyWith",				"LinkedListTest>>#testCopySameClass",				"LinkedListTest>>#testBasicCollectEmpty",				"LinkedListTest>>#testIfEmptyifNotEmpty",				"LinkedListTest>>#testIfEmpty",				"LinkedListTest>>#testUnionOfEmpties",				"LinkedListTest>>#testUnion",				"LinkedListTest>>#testIncludesAllNoneThere",				"LinkedListTest>>#testFindFirstNotIn",				"LinkedListTest>>#testIsEmpty",				"LinkedListTest>>#testIncludesAnyNoneThere",				"LinkedListTest>>#testCopyEmptyWithoutAll",				"LinkedListTest>>#testNoneSatisfyEmpty",				"LinkedListTest>>#testAsStringOnDelimiterEmpty",				"LinkedListTest>>#testIncludesAnyAllThere",				"LinkedListTest>>#testsBeginsWithEmpty",				"LinkedListTest>>#testKeysAndValuesDoEmpty",				"LinkedListTest>>#testRemoveElementFromEmpty",				"LinkedListTest>>#test0FixtureIterateSequencedReadableTest",				"LinkedListTest>>#testCopyUpToEmpty",				"LinkedListTest>>#testCollectThenSelectOnEmpty",				"LinkedListTest>>#testCopyEmptyWithout",				"LinkedListTest>>#testCollectThenDoOnEmpty",				"LinkedListTest>>#testSelectOnEmpty",				"LinkedListTest>>#testCopyAfterLastEmpty",				"LinkedListTest>>#testCopyAfterEmpty",				"LinkedListTest>>#testFindLastNotIn",				"LinkedListTest>>#testIsEmptyOrNil",				"LinkedListTest>>#testIncludesElementIsNotThere",				"LinkedListTest>>#testAsStringOnDelimiterLastEmpty",				"LinkedListTest>>#testOccurrencesOfEmpty",				"LinkedListTest>>#testGroupsOfAtATimeCollect",				"LinkedListTest>>#test0FixtureTRemoveTest",				"LinkedListTest>>#testCollectOnEmpty",				"LinkedListTest>>#test0FixtureIncludeTest",				"LinkedListTest>>#test0FixtureCopyPartOfSequenceableTest",				"LinkedListTest>>#testNotEmpty",				"LinkedListTest>>#testsEndsWithEmpty",				"LinkedListTest>>#testEqualSignOfIdenticalCollectionObjects",				"LinkedListTest>>#testIfNotEmpty",				"LinkedListTest>>#testRejectThenDoOnEmpty",				"LinkedListTest>>#testReverseDoEmpty",				"LinkedListTest>>#testSelectThenDoOnEmpty",				"LinkedListTest>>#test0TStructuralEqualityTest",				"LinkedListTest>>#test0CopyTest",				"LinkedListTest>>#testShallowCopyEmpty",				"LinkedListTest>>#testIfNotEmptyifEmpty",				"LinkedListTest>>#testSelectThenCollectOnEmpty",				"LinkedListTest>>#test0FixtureBeginsEndsWithTest",				"LinkedListTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"LinkedListTest>>#testRejectThenCollectEmpty",				"LinkedListTest>>#testCopyUpToLastEmpty",				"LinkedListTest>>#testDifference",				"LinkedListTest>>#test0FixtureEmptyTest",				"LinkedListTest>>#testWithDoError",				"LinkedListTest>>#testAsCommaStringEmpty",				"LinkedListTest>>#testAllSatisfyEmpty",				"LinkedListTest>>#test0FixtureCopySameContentsTest",				"LinkedListTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"LinkedListTest>>#test0FixtureOccurrencesTest",				"LinkedListTest>>#testRejectEmpty",				"LinkedListTest>>#testEqualSign",				"LinkedListTest>>#testWithCollectError",				"LinkedListTest>>#testIntersectionEmpty",				"MCPackageLoader>>#unloadPackage:",				"MCPackageLoader>>#installSnapshot:",				"MCSmalltalkhubRepository class>>#owner:project:",				"MCWorkingCopy>>#findSnapshotWithVersionInfo:",				"MCWorkingCopy>>#merge:",				"MTTemperaturePresenter>>#initializePresenters",				"MailAddressTokenizer class>>#initialize",				"MailMessage>>#addAlternativePart:contentType:",				"MailMessage>>#addAttachmentFrom:withName:",				"MailMessage>>#makeMultipart",				"MailMessage>>#addMixedPart:contentType:",				"MailMessageTest>>#testMultiPartMixed",				"MailMessageTest>>#testMultiPartAlternative",				"MailMessageTest>>#testAttachment",				"MethodDictionaryTest>>#emptyDict",				"MethodDictionaryTest>>#test0FixtureIncludeTest",				"MethodDictionaryTest>>#testIncludesAllNoneThere",				"MethodDictionaryTest>>#testIncludesAnyNoneThere",				"MethodDictionaryTest>>#testIncludesAnyAllThere",				"MethodDictionaryTest>>#testIncludesElementIsNotThere",				"MicAnnotationBlock class>>#tag",				"MicFormatBlock>>#closeMe",				"MicInlineBlockWithUrl class>>#from:to:withKind:withSubstring:withURL:",				"MicInlineElement class>>#from:to:withSubstring:",				"MicInlineParser>>#parse:",				"MicInlineParser>>#newBasicInlineBlockFrom:to:",				"MicInlineParser>>#insertBasicText:withFinalArray:from:to:",				"NECMenuMorph>>#drawLine:on:rectangle:",				"OrderedCollectionTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"OrderedCollectionTest>>#testCopyEmptyWith",				"OrderedCollectionTest>>#testCopySameClass",				"OrderedCollectionTest>>#test0FixturePutOneOrMoreElementsTest",				"OrderedCollectionTest>>#testUnionOfEmpties",				"OrderedCollectionTest>>#testIncludesAllNoneThere",				"OrderedCollectionTest>>#testUnion",				"OrderedCollectionTest>>#testHasEqualElements",				"OrderedCollectionTest>>#testFindFirstNotIn",				"OrderedCollectionTest>>#testIncludesAnyNoneThere",				"OrderedCollectionTest>>#test0FixturePutTest",				"OrderedCollectionTest>>#testCopyEmptyWithoutAll",				"OrderedCollectionTest>>#testAsStringOnDelimiterEmpty",				"OrderedCollectionTest>>#testIncludesAnyAllThere",				"OrderedCollectionTest>>#testsBeginsWithEmpty",				"OrderedCollectionTest>>#testKeysAndValuesDoEmpty",				"OrderedCollectionTest>>#testRemoveElementFromEmpty",				"OrderedCollectionTest>>#test0FixtureIterateSequencedReadableTest",				"OrderedCollectionTest>>#testCopyUpToEmpty",				"OrderedCollectionTest>>#testCopyEmptyWithout",				"OrderedCollectionTest>>#testCopyAfterLastEmpty",				"OrderedCollectionTest>>#testCopyAfterEmpty",				"OrderedCollectionTest>>#testFindLastNotIn",				"OrderedCollectionTest>>#testCopyEmpty",				"OrderedCollectionTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"OrderedCollectionTest>>#testAtPutOutOfBounds",				"OrderedCollectionTest>>#testIncludesElementIsNotThere",				"OrderedCollectionTest>>#testAsStringOnDelimiterLastEmpty",				"OrderedCollectionTest>>#testOccurrencesOfEmpty",				"OrderedCollectionTest>>#testGroupsOfAtATimeCollect",				"OrderedCollectionTest>>#test0FixtureTRemoveTest",				"OrderedCollectionTest>>#testConcatenationWithEmpty",				"OrderedCollectionTest>>#test0FixtureIncludeTest",				"OrderedCollectionTest>>#test0FixtureCopyPartOfSequenceableTest",				"OrderedCollectionTest>>#testsEndsWithEmpty",				"OrderedCollectionTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"OrderedCollectionTest>>#testEqualSignOfIdenticalCollectionObjects",				"OrderedCollectionTest>>#testReverseDoEmpty",				"OrderedCollectionTest>>#test0TStructuralEqualityTest",				"OrderedCollectionTest>>#test0CopyTest",				"OrderedCollectionTest>>#testFlatCollectAsWithEmptyCollection",				"OrderedCollectionTest>>#testShallowCopyEmpty",				"OrderedCollectionTest>>#test0FixtureBeginsEndsWithTest",				"OrderedCollectionTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"OrderedCollectionTest>>#testCopyUpToLastEmpty",				"OrderedCollectionTest>>#testDifference",				"OrderedCollectionTest>>#testWithDoError",				"OrderedCollectionTest>>#testAsCommaStringEmpty",				"OrderedCollectionTest>>#test0FixtureSequencedConcatenationTest",				"OrderedCollectionTest>>#test0FixtureCopySameContentsTest",				"OrderedCollectionTest>>#test0FixtureCloneTest",				"OrderedCollectionTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"OrderedCollectionTest>>#test0FixtureOccurrencesTest",				"OrderedCollectionTest>>#testEqualSign",				"OrderedCollectionTest>>#test0FixtureEmptySequenceableTest",				"OrderedCollectionTest>>#testWithCollectError",				"OrderedCollectionTest>>#testIntersectionEmpty",				"ProtocolOrganizer>>#protocolNamed:",				"RBCondition class>>#empty",				"RBMethodNode>>#generate",				"RBParseTreeRule>>#performOn:",				"RBProgramNode>>#displaySourceCode",				"RBRefactoring>>#emptyCondition",				"RBRefactoryDefinitionChange class>>#definition:for:",				"RBRemoveClassTransformation>>#preconditions",				"RBTRefactoringBuilder>>#emptyCondition",				"RBTransformation>>#emptyCondition",				"RSHorizontalVanDerPloegTreeLayout>>#initialize:associations:ifMultipleRoots:",				"RSLabel>>#computeTextExtents",				"RSTWalkBasedRegularTreeLayout>>#initialize:associations:ifMultipleRoots:",				"RSTextExtents class>>#empty",				"RSVanDerPloegTreeLayout>>#initialize:associations:ifMultipleRoots:",				"SequenceableCollection>>#asSrfi41Stream",				"SetTest>>#testCopyEmptyWith",				"SetTest>>#testCopySameClass",				"SetTest>>#test0FixtureConcatenationTest",				"SetTest>>#testAsStringOnDelimiterLastEmpty",				"SetTest>>#testOccurrencesOfEmpty",				"SetTest>>#test0FixtureTRemoveTest",				"SetTest>>#testConcatenationWithEmpty",				"SetTest>>#testUnionOfEmpties",				"SetTest>>#test0FixtureIncludeTest",				"SetTest>>#testIncludesAllNoneThere",				"SetTest>>#testIncludesAnyNoneThere",				"SetTest>>#testCopyEmptyWithoutAll",				"SetTest>>#testAsStringOnDelimiterEmpty",				"SetTest>>#testAddEmptyGrows",				"SetTest>>#testEqualSignOfIdenticalCollectionObjects",				"SetTest>>#testIncludesAnyAllThere",				"SetTest>>#test0TStructuralEqualityTest",				"SetTest>>#test0CopyTest",				"SetTest>>#testRemoveElementFromEmpty",				"SetTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"SetTest>>#testDifference",				"SetTest>>#testMaxIfNil",				"SetTest>>#testMax",				"SetTest>>#testAsCommaStringEmpty",				"SetTest>>#testCopyEmptyWithout",				"SetTest>>#test0FixtureCloneTest",				"SetTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"SetTest>>#test0FixtureOccurrencesTest",				"SetTest>>#test0FixtureRequirementsOfTGrowableTest",				"SetTest>>#testEqualSign",				"SetTest>>#testCopyEmpty",				"SetTest>>#testIntersectionEmpty",				"SetTest>>#testIncludesElementIsNotThere",				"SortedCollectionTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"SortedCollectionTest>>#testCopyEmptyWith",				"SortedCollectionTest>>#testCopySameClass",				"SortedCollectionTest>>#testCopyReplaceAllWithForSorted",				"SortedCollectionTest>>#testUnionOfEmpties",				"SortedCollectionTest>>#testIncludesAllNoneThere",				"SortedCollectionTest>>#testUnion",				"SortedCollectionTest>>#testHasEqualElements",				"SortedCollectionTest>>#testFindFirstNotIn",				"SortedCollectionTest>>#testIncludesAnyNoneThere",				"SortedCollectionTest>>#test0FixtureCopyWithReplacementForSorted",				"SortedCollectionTest>>#testCopyEmptyWithoutAll",				"SortedCollectionTest>>#testAsStringOnDelimiterEmpty",				"SortedCollectionTest>>#testIncludesAnyAllThere",				"SortedCollectionTest>>#testsBeginsWithEmpty",				"SortedCollectionTest>>#testKeysAndValuesDoEmpty",				"SortedCollectionTest>>#testRemoveElementFromEmpty",				"SortedCollectionTest>>#test0FixtureIterateSequencedReadableTest",				"SortedCollectionTest>>#testCopyUpToEmpty",				"SortedCollectionTest>>#testCopyEmptyWithout",				"SortedCollectionTest>>#testCopyAfterLastEmpty",				"SortedCollectionTest>>#testFindLastNotIn",				"SortedCollectionTest>>#testCopyAfterEmpty",				"SortedCollectionTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"SortedCollectionTest>>#testRemoveFirstNotPresent",				"SortedCollectionTest>>#testIncludesElementIsNotThere",				"SortedCollectionTest>>#testCopyFromToWithForSorted",				"SortedCollectionTest>>#testAsStringOnDelimiterLastEmpty",				"SortedCollectionTest>>#testOccurrencesOfEmpty",				"SortedCollectionTest>>#testGroupsOfAtATimeCollect",				"SortedCollectionTest>>#test0FixtureTRemoveTest",				"SortedCollectionTest>>#testRemoveLastNElementsNElements",				"SortedCollectionTest>>#test0FixtureIncludeTest",				"SortedCollectionTest>>#test0FixtureCopyPartOfSequenceableTest",				"SortedCollectionTest>>#testsEndsWithEmpty",				"SortedCollectionTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"SortedCollectionTest>>#testEqualSignOfIdenticalCollectionObjects",				"SortedCollectionTest>>#testReverseDoEmpty",				"SortedCollectionTest>>#testRemoveFirstNElementsNotPresent",				"SortedCollectionTest>>#test0TStructuralEqualityTest",				"SortedCollectionTest>>#test0CopyTest",				"SortedCollectionTest>>#testShallowCopyEmpty",				"SortedCollectionTest>>#test0FixtureBeginsEndsWithTest",				"SortedCollectionTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"SortedCollectionTest>>#testCopyUpToLastEmpty",				"SortedCollectionTest>>#testDifference",				"SortedCollectionTest>>#testWithDoError",				"SortedCollectionTest>>#testAsCommaStringEmpty",				"SortedCollectionTest>>#testRemoveLastNotPresent",				"SortedCollectionTest>>#test0FixtureCopySameContentsTest",				"SortedCollectionTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"SortedCollectionTest>>#test0FixtureOccurrencesTest",				"SortedCollectionTest>>#testRemoveAtNotPresent",				"SortedCollectionTest>>#testEqualSign",				"SortedCollectionTest>>#testWithCollectError",				"SortedCollectionTest>>#testIntersectionEmpty",				"SpJobPresenter>>#updatePresenter",				"StackTest>>#test0FixtureEmptyTest",				"StackTest>>#testIsEmptyOrNil",				"StackTest>>#testIfEmptyifNotEmpty",				"StackTest>>#testCopyEmpty",				"StackTest>>#test0FixtureCloneTest",				"StackTest>>#testIfNotEmpty",				"StackTest>>#testIsEmpty",				"StringTest>>#testCopyEmptyWith",				"StringTest>>#testCopySameClass",				"StringTest>>#test0FixturePutOneOrMoreElementsTest",				"StringTest>>#testIncludesAllNoneThere",				"StringTest>>#testFindFirstNotIn",				"StringTest>>#testIncludesAnyNoneThere",				"StringTest>>#test0FixturePutTest",				"StringTest>>#testIncludesAnyAllThere",				"StringTest>>#test0FixtureIterateSequencedReadableTest",				"StringTest>>#testCopyAfterEmpty",				"StringTest>>#testCopyEmpty",				"StringTest>>#testAtPutOutOfBounds",				"StringTest>>#testIncludesElementIsNotThere",				"StringTest>>#testAsStringOnDelimiterLastEmpty",				"StringTest>>#testGroupsOfAtATimeCollect",				"StringTest>>#testConcatenationWithEmpty",				"StringTest>>#testsEndsWithEmpty",				"StringTest>>#testEqualSignOfIdenticalCollectionObjects",				"StringTest>>#test0TStructuralEqualityTest",				"StringTest>>#test0CopyTest",				"StringTest>>#testShallowCopyEmpty",				"StringTest>>#test0FixtureCopySameContentsTest",				"StringTest>>#test0FixtureCloneTest",				"StringTest>>#testEqualSign",				"StringTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"StringTest>>#testUnionOfEmpties",				"StringTest>>#testUnion",				"StringTest>>#testHasEqualElements",				"StringTest>>#testCopyEmptyWithoutAll",				"StringTest>>#testAsStringOnDelimiterEmpty",				"StringTest>>#testsBeginsWithEmpty",				"StringTest>>#testKeysAndValuesDoEmpty",				"StringTest>>#testCopyUpToEmpty",				"StringTest>>#testCopyEmptyWithout",				"StringTest>>#testCopyAfterLastEmpty",				"StringTest>>#testFindLastNotIn",				"StringTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"StringTest>>#testOccurrencesOfEmpty",				"StringTest>>#test0FixtureIncludeTest",				"StringTest>>#test0FixtureCopyPartOfSequenceableTest",				"StringTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"StringTest>>#testReverseDoEmpty",				"StringTest>>#test0FixtureBeginsEndsWithTest",				"StringTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"StringTest>>#testCopyUpToLastEmpty",				"StringTest>>#testDifference",				"StringTest>>#testWithDoError",				"StringTest>>#testAsCommaStringEmpty",				"StringTest>>#test0FixtureSequencedConcatenationTest",				"StringTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"StringTest>>#test0FixtureOccurrencesTest",				"StringTest>>#testWithCollectError",				"StringTest>>#testIntersectionEmpty",				"SymbolTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"SymbolTest>>#testCopyEmptyWith",				"SymbolTest>>#testCopySameClass",				"SymbolTest>>#testUnionOfEmpties",				"SymbolTest>>#testUnion",				"SymbolTest>>#testIncludesAllNoneThere",				"SymbolTest>>#testHasEqualElements",				"SymbolTest>>#testFindFirstNotIn",				"SymbolTest>>#testIncludesAnyNoneThere",				"SymbolTest>>#testCopyEmptyWithoutAll",				"SymbolTest>>#testAsStringOnDelimiterEmpty",				"SymbolTest>>#testIncludesAnyAllThere",				"SymbolTest>>#testsBeginsWithEmpty",				"SymbolTest>>#testKeysAndValuesDoEmpty",				"SymbolTest>>#test0FixtureIterateSequencedReadableTest",				"SymbolTest>>#testCopyUpToEmpty",				"SymbolTest>>#testCopyEmptyWithout",				"SymbolTest>>#testCopyAfterLastEmpty",				"SymbolTest>>#testFindLastNotIn",				"SymbolTest>>#testCopyAfterEmpty",				"SymbolTest>>#testCopyEmpty",				"SymbolTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"SymbolTest>>#testIncludesElementIsNotThere",				"SymbolTest>>#testAsStringOnDelimiterLastEmpty",				"SymbolTest>>#testOccurrencesOfEmpty",				"SymbolTest>>#testGroupsOfAtATimeCollect",				"SymbolTest>>#testConcatenationWithEmpty",				"SymbolTest>>#test0FixtureIncludeTest",				"SymbolTest>>#test0FixtureCopyPartOfSequenceableTest",				"SymbolTest>>#testsEndsWithEmpty",				"SymbolTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"SymbolTest>>#testEqualSignOfIdenticalCollectionObjects",				"SymbolTest>>#testReverseDoEmpty",				"SymbolTest>>#test0TStructuralEqualityTest",				"SymbolTest>>#test0CopyTest",				"SymbolTest>>#testShallowCopyEmpty",				"SymbolTest>>#test0FixtureBeginsEndsWithTest",				"SymbolTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"SymbolTest>>#testCopyUpToLastEmpty",				"SymbolTest>>#testDifference",				"SymbolTest>>#testWithDoError",				"SymbolTest>>#testAsCommaStringEmpty",				"SymbolTest>>#test0FixtureSequencedConcatenationTest",				"SymbolTest>>#test0FixtureCopySameContentsTest",				"SymbolTest>>#test0FixtureCloneTest",				"SymbolTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"SymbolTest>>#test0FixtureOccurrencesTest",				"SymbolTest>>#testEqualSign",				"SymbolTest>>#testWithCollectError",				"SymbolTest>>#testIntersectionEmpty",				"TAsStringCommaAndDelimiterSequenceableTest>>#testAsCommaStringEmpty",				"TAsStringCommaAndDelimiterSequenceableTest>>#testAsStringOnDelimiterEmpty",				"TAsStringCommaAndDelimiterSequenceableTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"TAsStringCommaAndDelimiterSequenceableTest>>#testAsStringOnDelimiterLastEmpty",				"TAsStringCommaAndDelimiterTest>>#testAsCommaStringEmpty",				"TAsStringCommaAndDelimiterTest>>#testAsStringOnDelimiterEmpty",				"TAsStringCommaAndDelimiterTest>>#test0FixtureAsStringCommaAndDelimiterTest",				"TAsStringCommaAndDelimiterTest>>#testAsStringOnDelimiterLastEmpty",				"TBeginsEndsWith>>#testsEndsWithEmpty",				"TBeginsEndsWith>>#test0FixtureBeginsEndsWithTest",				"TBeginsEndsWith>>#testsBeginsWithEmpty",				"TCloneTest>>#test0FixtureCloneTest",				"TCloneTest>>#testCopyEmpty",				"TConcatenationEqualElementsRemovedTest>>#testConcatenationWithEmpty",				"TConcatenationEqualElementsRemovedTest>>#test0FixtureConcatenationTest",				"TConcatenationTest>>#testConcatenationWithEmpty",				"TConcatenationTest>>#test0FixtureConcatenationTest",				"TCopyPartOfSequenceable>>#testCopyUpToEmpty",				"TCopyPartOfSequenceable>>#testCopyUpToLastEmpty",				"TCopyPartOfSequenceable>>#testCopyAfterLastEmpty",				"TCopyPartOfSequenceable>>#test0FixtureCopyPartOfSequenceableTest",				"TCopyPartOfSequenceable>>#testCopyAfterEmpty",				"TCopySequenceableSameContents>>#test0FixtureCopySameContentsTest",				"TCopySequenceableSameContents>>#testShallowCopyEmpty",				"TCopySequenceableWithReplacementForSorted>>#testCopyReplaceAllWithForSorted",				"TCopySequenceableWithReplacementForSorted>>#testCopyFromToWithForSorted",				"TCopySequenceableWithReplacementForSorted>>#test0FixtureCopyWithReplacementForSorted",				"TCopyTest>>#testCopyEmptyWith",				"TCopyTest>>#testCopyEmptyWithoutAll",				"TCopyTest>>#testCopySameClass",				"TCopyTest>>#testCopyEmptyWithout",				"TCopyTest>>#test0CopyTest",				"TDictionaryCopyingTest>>#testCopyEmpty",				"TDictionaryCopyingTest>>#test0FixtureCloneTest",				"TEmptySequenceableTest>>#test0FixtureEmptySequenceableTest",				"TEmptyTest>>#test0FixtureEmptyTest",				"TEmptyTest>>#testIfNotEmptyifEmpty",				"TEmptyTest>>#testIsEmptyOrNil",				"TEmptyTest>>#testIfEmpty",				"TEmptyTest>>#testIfEmptyifNotEmpty",				"TEmptyTest>>#testIfNotEmpty",				"TEmptyTest>>#testNotEmpty",				"TEmptyTest>>#testIsEmpty",				"TEnumeratingTest>>#testFlatCollectAsWithEmptyCollection",				"TGrowableTest>>#test0FixtureRequirementsOfTGrowableTest",				"TGrowableTest>>#testAddEmptyGrows",				"TIncludesTest>>#testIncludesAnyNoneThere",				"TIncludesTest>>#test0FixtureIncludeTest",				"TIncludesTest>>#testIncludesAllNoneThere",				"TIncludesTest>>#testIncludesAnyAllThere",				"TIncludesTest>>#testIncludesElementIsNotThere",				"TIncludesWithIdentityCheckTest>>#testIncludesAnyNoneThere",				"TIncludesWithIdentityCheckTest>>#test0FixtureIncludeTest",				"TIncludesWithIdentityCheckTest>>#testIncludesAllNoneThere",				"TIncludesWithIdentityCheckTest>>#testIncludesAnyAllThere",				"TIncludesWithIdentityCheckTest>>#testIncludesElementIsNotThere",				"TIterateSequencedReadableTest>>#testReverseDoEmpty",				"TIterateSequencedReadableTest>>#testWithDoError",				"TIterateSequencedReadableTest>>#testKeysAndValuesDoEmpty",				"TIterateSequencedReadableTest>>#testFindFirstNotIn",				"TIterateSequencedReadableTest>>#testGroupsOfAtATimeCollect",				"TIterateSequencedReadableTest>>#testFindLastNotIn",				"TIterateSequencedReadableTest>>#testWithCollectError",				"TIterateSequencedReadableTest>>#test0FixtureIterateSequencedReadableTest",				"TIterateTest>>#testSelectThenDoOnEmpty",				"TIterateTest>>#testCollectThenSelectOnEmpty",				"TIterateTest>>#testCollectThenDoOnEmpty",				"TIterateTest>>#testAllSatisfyEmpty",				"TIterateTest>>#testSelectOnEmpty",				"TIterateTest>>#testRejectEmpty",				"TIterateTest>>#testBasicCollectEmpty",				"TIterateTest>>#testSelectThenCollectOnEmpty",				"TIterateTest>>#testNoneSatisfyEmpty",				"TIterateTest>>#testRejectThenCollectEmpty",				"TIterateTest>>#testCollectOnEmpty",				"TIterateTest>>#testRejectThenDoOnEmpty",				"TOccurrencesForMultiplinessTest>>#test0FixtureOccurrencesTest",				"TOccurrencesForMultiplinessTest>>#testOccurrencesOfEmpty",				"TOccurrencesTest>>#test0FixtureOccurrencesTest",				"TOccurrencesTest>>#testOccurrencesOfEmpty",				"TPutBasicTest>>#test0FixturePutTest",				"TPutBasicTest>>#testAtPutOutOfBounds",				"TPutTest>>#test0FixturePutOneOrMoreElementsTest",				"TRemoveByIndexTest>>#testRemoveAtNotPresent",				"TRemoveByIndexTest>>#testRemoveLastNElementsNElements",				"TRemoveByIndexTest>>#testRemoveFirstNElementsNotPresent",				"TRemoveByIndexTest>>#testRemoveLastNotPresent",				"TRemoveByIndexTest>>#testRemoveFirstNotPresent",				"TRemoveForMultiplenessTest>>#test0FixtureTRemoveTest",				"TRemoveForMultiplenessTest>>#testRemoveElementFromEmpty",				"TRemoveTest>>#testRemoveElementFromEmpty",				"TRemoveTest>>#test0FixtureTRemoveTest",				"TSequencedConcatenationTest>>#test0FixtureSequencedConcatenationTest",				"TSequencedConcatenationTest>>#testConcatenationWithEmpty",				"TSequencedStructuralEqualityTest>>#testEqualSign",				"TSequencedStructuralEqualityTest>>#testHasEqualElementsOfIdenticalCollectionObjects",				"TSequencedStructuralEqualityTest>>#testEqualSignIsTrueForEmptyButNonIdenticalCollections",				"TSequencedStructuralEqualityTest>>#testEqualSignOfIdenticalCollectionObjects",				"TSequencedStructuralEqualityTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"TSequencedStructuralEqualityTest>>#testHasEqualElementsIsTrueForNonIdenticalButEqualCollections",				"TSequencedStructuralEqualityTest>>#testHasEqualElements",				"TSequencedStructuralEqualityTest>>#test0TStructuralEqualityTest",				"TSetArithmetic>>#testUnionOfEmpties",				"TSetArithmetic>>#testUnion",				"TSetArithmetic>>#testDifference",				"TSetArithmetic>>#testIntersectionEmpty",				"TSizeTest>>#testSize",				"TSizeTest>>#test0TSizeTest",				"TStructuralEqualityTest>>#testEqualSign",				"TStructuralEqualityTest>>#testEqualSignIsTrueForNonIdenticalButEqualCollections",				"TStructuralEqualityTest>>#testEqualSignOfIdenticalCollectionObjects",				"TStructuralEqualityTest>>#test0TStructuralEqualityTest",				"TestResource>>#description",				"UndefinedObject>>#asLinkedList",				"ValueLink>>#asLinkedList",				"ZnClient>>#initialize",				"ZnMimePart>>#fieldValueString",				"ZnPrefixMappingDelegateTest>>#testPathConsumption",				"ZnPrefixMappingDelegateTest>>#testMapping",				"ZnPrefixMappingDelegateTest>>#testNesting",				"ZnRequest class>>#empty",				"ZnServerTest>>#testCustomDefaultDelegate"			],			"implementors" : {				"DictionaryTest" : {					"sourceCode" : [						"empty",						"",						"\t^ emptyDict"					],					"body" : [						"^ emptyDict"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5251739,					"argumentNames" : [ ]				},				"TIterateTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5141572,					"argumentNames" : [ ]				},				"TEmptyTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5136239,					"argumentNames" : [ ]				},				"IntervalTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5223835,					"argumentNames" : [ ]				},				"SpJob class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new",						"\t\t  title: 'Unknown';",						"\t\t  block: [ :job |  ];",						"\t\t  yourself"					],					"body" : [						"^ self new",						"\t  title: 'Unknown';",						"\t  block: [ :job |  ];",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 1387731,					"argumentNames" : [ ]				},				"TStructuralEqualityTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "tests - equality",					"comment" : [ ],					"hash" : 5150063,					"argumentNames" : [ ]				},				"MethodDictionaryTest" : {					"sourceCode" : [						"empty",						"",						"\t^ MethodDictionary new"					],					"body" : [						"^ MethodDictionary new"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5183535,					"argumentNames" : [ ]				},				"TIncludesWithIdentityCheckTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5139311,					"argumentNames" : [ ]				},				"Array class" : {					"sourceCode" : [						"empty",						"",						"\t\"A canonicalized empty Array instance.\"",						"",						"\t^ #(  )"					],					"body" : [						"^ #(  )"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"A canonicalized empty Array instance."					],					"hash" : 1585602,					"argumentNames" : [ ]				},				"TDictionaryCopyingTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "helper",					"comment" : [ ],					"hash" : 5184623,					"argumentNames" : [ ]				},				"Srfi41Stream class" : {					"sourceCode" : [						"empty",						"",						"\t^ self object: nil"					],					"body" : [						"^ self object: nil"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 8926415,					"argumentNames" : [ ]				},				"OrderedCollectionTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "setup",					"comment" : [ ],					"hash" : 5224347,					"argumentNames" : [ ]				},				"TBeginsEndsWith" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5127236,					"argumentNames" : [ ]				},				"TAsStringCommaAndDelimiterSequenceableTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5126511,					"argumentNames" : [ ]				},				"Collection class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new"					],					"body" : [						"^ self new"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 1644634,					"argumentNames" : [ ]				},				"LinkedListTest" : {					"sourceCode" : [						"empty",						"",						"\t^ list"					],					"body" : [						"^ list"					],					"isTestMethod" : false,					"category" : "tests - empty",					"comment" : [ ],					"hash" : 5220765,					"argumentNames" : [ ]				},				"TConcatenationTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5128260,					"argumentNames" : [ ]				},				"ZnRequestLine class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new",						"\t\t  version: ZnConstants defaultHTTPVersion;",						"\t\t  yourself"					],					"body" : [						"^ self new",						"\t  version: ZnConstants defaultHTTPVersion;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 2215285,					"argumentNames" : [ ]				},				"MailMessage class" : {					"sourceCode" : [						"empty",						"",						"\t\"return a message with no text and no header\"",						"",						"\t^ self new"					],					"body" : [						"^ self new"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"return a message with no text and no header"					],					"hash" : 4474970,					"argumentNames" : [ ]				},				"TRemoveByIndexTest" : {					"sourceCode" : [						"empty",						"",						"\t\" return an empty collection\"",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [						" return an empty collection"					],					"hash" : 5145668,					"argumentNames" : [ ]				},				"TRemoveTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5146180,					"argumentNames" : [ ]				},				"StackTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 5228441,					"argumentNames" : [ ]				},				"ArrayTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "initialization",					"comment" : [ ],					"hash" : 5222823,					"argumentNames" : [ ]				},				"CompiledMethodTrailer class" : {					"sourceCode" : [						"empty",						"",						"\t\"answer the empty trailer\"",						"",						"\t^ self new"					],					"body" : [						"^ self new"					],					"isTestMethod" : false,					"category" : "kinds",					"comment" : [						"answer the empty trailer"					],					"hash" : 1708890,					"argumentNames" : [ ]				},				"TConcatenationEqualElementsRemovedTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5128772,					"argumentNames" : [ ]				},				"TSequencedConcatenationTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5147716,					"argumentNames" : [ ]				},				"TIncludesTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5138799,					"argumentNames" : [ ]				},				"TEmptySequenceableTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5135727,					"argumentNames" : [ ]				},				"MCSnapshot class" : {					"sourceCode" : [						"empty",						"",						"\t^ self fromDefinitions: #(  )"					],					"body" : [						"^ self fromDefinitions: #(  )"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 1089202,					"argumentNames" : [ ]				},				"CTBinaryTreeAbstract class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new yourself: [ :aTree | ",						"\t\t  aTree representation: aTree binaryTreeElementEmpty ]"					],					"body" : [						"^ self new yourself: [ :aTree | ",						"\t  aTree representation: aTree binaryTreeElementEmpty ]"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 3094794,					"argumentNames" : [ ]				},				"TOccurrencesTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5142596,					"argumentNames" : [ ]				},				"TCopyTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5134703,					"argumentNames" : [ ]				},				"TCloneTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "helper",					"comment" : [ ],					"hash" : 5127535,					"argumentNames" : [ ]				},				"SortedCollectionTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5224863,					"argumentNames" : [ ]				},				"CoFilter class" : {					"sourceCode" : [						"empty",						"",						"\t^ CoCaseSensitiveBeginsWithFilter filterString: ''"					],					"body" : [						"^ CoCaseSensitiveBeginsWithFilter filterString: ''"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 7273097,					"argumentNames" : [ ]				},				"TPutBasicTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5144431,					"argumentNames" : [ ]				},				"TSequencedStructuralEqualityTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "tests - equality",					"comment" : [ ],					"hash" : 5150575,					"argumentNames" : [ ]				},				"BagTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "setup",					"comment" : [ ],					"hash" : 5250715,					"argumentNames" : [ ]				},				"TRemoveForMultiplenessTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5146692,					"argumentNames" : [ ]				},				"ClyDataSource class" : {					"sourceCode" : [						"empty",						"",						"\t^ ClyCollapsedDataSource on: ClyUnknownQuery instance"					],					"body" : [						"^ ClyCollapsedDataSource on: ClyUnknownQuery instance"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 7012622,					"argumentNames" : [ ]				},				"MorphTreeMorphSingleSelection" : {					"sourceCode" : [						"empty",						"",						"\tself selectedNodePath: nil"					],					"body" : [						"self selectedNodePath: nil"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2814884,					"argumentNames" : [ ]				},				"ZnRequest class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new",						"\t\t  requestLine: ZnRequestLine empty;",						"\t\t  headers: ZnHeaders defaultRequestHeaders;",						"\t\t  yourself"					],					"body" : [						"^ self new",						"\t  requestLine: ZnRequestLine empty;",						"\t  headers: ZnHeaders defaultRequestHeaders;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 2213383,					"argumentNames" : [ ]				},				"RSTextExtents class" : {					"sourceCode" : [						"empty",						"",						"\t^ empty ifNil: [ empty := self new empty ]"					],					"body" : [						"^ empty ifNil: [ empty := self new empty ]"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 7794896,					"argumentNames" : [ ]				},				"StringTest" : {					"sourceCode" : [						"empty",						"",						"\t^ emptyString"					],					"body" : [						"^ emptyString"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5235101,					"argumentNames" : [ ]				},				"TCopyPartOfSequenceable" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5131332,					"argumentNames" : [ ]				},				"HashedCollection class" : {					"sourceCode" : [						"empty",						"",						"\t^ self basicNew",						"\t\t  initialize: 1;",						"\t\t  yourself"					],					"body" : [						"^ self basicNew",						"\t  initialize: 1;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 1644837,					"argumentNames" : [ ]				},				"String class" : {					"sourceCode" : [						"empty",						"",						"\t\"A canonicalized empty String instance.\"",						"",						"\t^ ''"					],					"body" : [						"^ ''"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"A canonicalized empty String instance."					],					"hash" : 1600450,					"argumentNames" : [ ]				},				"TOccurrencesForMultiplinessTest" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5143108,					"argumentNames" : [ ]				},				"RBCondition class" : {					"sourceCode" : [						"empty",						"",						"\t\"Returns an empty condition\"",						"",						"\t^ self new",						"\t\t  type: (Array with: #empty)",						"\t\t  block: [ true ]",						"\t\t  errorString: 'Empty'"					],					"body" : [						"^ self new",						"\t  type: (Array with: #empty)",						"\t  block: [ true ]",						"\t  errorString: 'Empty'"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [						"Returns an empty condition"					],					"hash" : 4484545,					"argumentNames" : [ ]				},				"MorphTreeMorphSelection" : {					"sourceCode" : [						"empty",						"",						"\tself subclassResponsibility"					],					"body" : [						"self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2813764,					"argumentNames" : [ ]				},				"MorphTreeMorphMultipleSelection" : {					"sourceCode" : [						"empty",						"",						"\tself selectedNodePathList: OrderedCollection new"					],					"body" : [						"self selectedNodePathList: OrderedCollection new"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2814452,					"argumentNames" : [ ]				},				"SmallDictionary" : {					"sourceCode" : [						"empty",						"",						"\t1 to: size do: [ :index | ",						"\t\tkeys at: index put: nil.",						"\t\tvalues at: index put: nil ].",						"\tsize := 0"					],					"body" : [						"1 to: size do: [ :index | ",						"\tkeys at: index put: nil.",						"\tvalues at: index put: nil ].",						"size := 0"					],					"isTestMethod" : false,					"category" : "accessing",					"comment" : [ ],					"hash" : 2456794,					"argumentNames" : [ ]				},				"CollectionRootTest" : {					"sourceCode" : [						"empty",						"",						"\tself subclassResponsibility"					],					"body" : [						"self subclassResponsibility"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5152324,					"argumentNames" : [ ]				},				"TSizeTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5149039,					"argumentNames" : [ ]				},				"TIterateSequencedReadableTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5140847,					"argumentNames" : [ ]				},				"CTBinomialHeap class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new",						"\t\t  representation: nil;",						"\t\t  yourself"					],					"body" : [						"^ self new",						"\t  representation: nil;",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 3097356,					"argumentNames" : [ ]				},				"ZnDefaultServerDelegate class" : {					"sourceCode" : [						"empty",						"",						"\t^ self basicNew"					],					"body" : [						"^ self basicNew"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 2202735,					"argumentNames" : [ ]				},				"Protocol class" : {					"sourceCode" : [						"empty",						"",						"\t^ self name: #''"					],					"body" : [						"^ self name: #''"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 1640370,					"argumentNames" : [ ]				},				"FloatArrayTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5281949,					"argumentNames" : [ ]				},				"TAsStringCommaAndDelimiterTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5125999,					"argumentNames" : [ ]				},				"TCopySequenceableWithReplacementForSorted" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5134404,					"argumentNames" : [ ]				},				"ClyTypedScope class" : {					"sourceCode" : [						"empty",						"",						"\t^ self ofAll: #(  )"					],					"body" : [						"^ self ofAll: #(  )"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 6784946,					"argumentNames" : [ ]				},				"RSTextExtents" : {					"sourceCode" : [						"empty",						"",						"\tself",						"\t\twidth: 0;",						"\t\theight: 0;",						"\t\tx_advance: 0;",						"\t\ty_advance: 0;",						"\t\tx_bearing: 0;",						"\t\ty_bearing: 0"					],					"body" : [						"self",						"\twidth: 0;",						"\theight: 0;",						"\tx_advance: 0;",						"\ty_advance: 0;",						"\tx_bearing: 0;",						"\ty_bearing: 0"					],					"isTestMethod" : false,					"category" : "public",					"comment" : [ ],					"hash" : 7797076,					"argumentNames" : [ ]				},				"SetTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "tests - empty",					"comment" : [ ],					"hash" : 5254301,					"argumentNames" : [ ]				},				"SymbolTest" : {					"sourceCode" : [						"empty",						"",						"\t^ emptySymbol"					],					"body" : [						"^ emptySymbol"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5235611,					"argumentNames" : [ ]				},				"DTTreeNode class" : {					"sourceCode" : [						"empty",						"",						"\t^ self new",						"\t\t  subResults: #(  );",						"\t\t  yourself"					],					"body" : [						"^ self new",						"\t  subResults: #(  );",						"\t  yourself"					],					"isTestMethod" : false,					"category" : "instance creation",					"comment" : [ ],					"hash" : 4288240,					"argumentNames" : [ ]				},				"TCopySequenceableSameContents" : {					"sourceCode" : [						"empty",						"",						"\tself explicitRequirement"					],					"body" : [						"self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5132868,					"argumentNames" : [ ]				},				"HeapTest" : {					"sourceCode" : [						"empty",						"",						"\t^ empty"					],					"body" : [						"^ empty"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5223329,					"argumentNames" : [ ]				},				"TGrowableTest" : {					"sourceCode" : [						"empty",						"",						"\t^ self explicitRequirement"					],					"body" : [						"^ self explicitRequirement"					],					"isTestMethod" : false,					"category" : "requirements",					"comment" : [ ],					"hash" : 5137263,					"argumentNames" : [ ]				}			}		},		"linkBinomialTree:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinomialHeap>>#merge:with:",				"CTBinomialHeap>>#pushTree:onTrees:"			],			"implementors" : {				"CTBinomialTree" : {					"sourceCode" : [						"linkBinomialTree: aTree",						"",						"\t| x |",						"\tx := aTree content.",						"\t^ content < x",						"\t\t  ifTrue: [ self class node: content children: aTree ~~> children ]",						"\t\t  ifFalse: [ self class node: x children: self ~~> aTree children ]"					],					"body" : [						"| x |",						"x := aTree content.",						"^ content < x",						"\t  ifTrue: [ self class node: content children: aTree ~~> children ]",						"\t  ifFalse: [ self class node: x children: self ~~> aTree children ]"					],					"isTestMethod" : false,					"category" : "as yet unclassified",					"comment" : [ ],					"hash" : 20402773,					"argumentNames" : [						"aTree"					]				}			}		},		"asBinomialHeap" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinomialHeapTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asBinomialHeap",						"",						"\t^ self asBinaryTree: CTBinomialHeap"					],					"body" : [						"^ self asBinaryTree: CTBinomialHeap"					],					"isTestMethod" : false,					"category" : "*Containers-BinomialHeap",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"asRedBlackSet" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTRedBlackSetTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asRedBlackSet",						"",						"\t^ self asBinaryTree: CTRedBlackSet"					],					"body" : [						"^ self asBinaryTree: CTRedBlackSet"					],					"isTestMethod" : false,					"category" : "*Containers-RedBlackSet",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"pushTree:onTrees:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinomialHeap>>#merge:with:",				"CTBinomialHeap>>#push:",				"CTBinomialHeap>>#pushTree:onTrees:"			],			"implementors" : {				"CTBinomialHeap" : {					"sourceCode" : [						"pushTree: anAssociation onTrees: trees",						"",						"\t^ trees ifNil: [ anAssociation ~~> trees ] ifNotNil: [ ",						"\t\t  | carAssociation rank |",						"\t\t  rank := anAssociation key.",						"\t\t  carAssociation := trees value.",						"\t\t  rank < carAssociation key",						"\t\t\t  ifTrue: [ anAssociation ~~> trees ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  self",						"\t\t\t\t\t  pushTree: rank + 1",						"\t\t\t\t\t\t  ->",						"\t\t\t\t\t\t  (anAssociation value linkBinomialTree: carAssociation value)",						"\t\t\t\t\t  onTrees: trees nextLink ] ]"					],					"body" : [						"^ trees ifNil: [ anAssociation ~~> trees ] ifNotNil: [ ",						"\t  | carAssociation rank |",						"\t  rank := anAssociation key.",						"\t  carAssociation := trees value.",						"\t  rank < carAssociation key",						"\t\t  ifTrue: [ anAssociation ~~> trees ]",						"\t\t  ifFalse: [ ",						"\t\t\t  self",						"\t\t\t\t  pushTree: rank + 1",						"\t\t\t\t\t  -> (anAssociation value linkBinomialTree: carAssociation value)",						"\t\t\t\t  onTrees: trees nextLink ] ]"					],					"isTestMethod" : false,					"category" : "adding",					"comment" : [ ],					"hash" : 37704125,					"argumentNames" : [						"anAssociation",						"trees"					]				}			}		},		"asSplayHeap" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTSplayHeapTest>>#tree:"			],			"implementors" : {				"Collection" : {					"sourceCode" : [						"asSplayHeap",						"",						"\t^ self asBinaryTree: CTSplayHeap"					],					"body" : [						"^ self asBinaryTree: CTSplayHeap"					],					"isTestMethod" : false,					"category" : "*Containers-SplayHeap",					"comment" : [ ],					"hash" : 1644962,					"argumentNames" : [ ]				}			}		},		"partitionGreaterThanOrEqualTo:inSplayHeap:do:" : {			"senders" : [				"BaselineOfBookletDSst>>#scriptRedBlackSetMessagesForDoc",				"CTBinaryTreeNodeSplayHeap>>#partition:inSplayHeap:do:"			],			"implementors" : {				"CTBinaryTreeNodeSplayHeap" : {					"sourceCode" : [						"partitionGreaterThanOrEqualTo: pivot inSplayHeap: aHeap do: aBlock",						"",						"\t^ previousLink",						"\t\t  ifEmpty: [ aBlock value: aHeap binaryTreeElementEmpty value: self ]",						"\t\t  ifNotEmpty: [ ",						"\t\t\t  | y |",						"\t\t\t  y := previousLink value.",						"\t\t\t  (aHeap is: y lessThan: pivot)",						"\t\t\t\t  ifTrue: [ ",						"\t\t\t\t\t  previousLink nextLink",						"\t\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t\t  | r l |",						"\t\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: previousLink previousLink",						"\t\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t\t       value: value",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: nextLink.",						"\t\t\t\t\t\t\t  aBlock value: l value: r ] ]",						"\t\t\t\t  ifFalse: [ ",						"\t\t\t\t\t  previousLink previousLink",						"\t\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t\t  | r rr |",						"\t\t\t\t\t\t\t  rr := aHeap",						"\t\t\t\t\t\t\t\t        leftBinaryTreeElement: previousLink nextLink",						"\t\t\t\t\t\t\t\t        value: value",						"\t\t\t\t\t\t\t\t        rightBinaryTreeElement: nextLink.",						"\t\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t\t       rightBinaryTreeElement: rr.",						"\t\t\t\t\t\t\t  aBlock value: s value: r ] ] ]"					],					"body" : [						"^ previousLink",						"\t  ifEmpty: [ aBlock value: aHeap binaryTreeElementEmpty value: self ]",						"\t  ifNotEmpty: [ ",						"\t\t  | y |",						"\t\t  y := previousLink value.",						"\t\t  (aHeap is: y lessThan: pivot)",						"\t\t\t  ifTrue: [ ",						"\t\t\t\t  previousLink nextLink",						"\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t  | r l |",						"\t\t\t\t\t\t  l := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: previousLink previousLink",						"\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: s.",						"\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t       value: value",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: nextLink.",						"\t\t\t\t\t\t  aBlock value: l value: r ] ]",						"\t\t\t  ifFalse: [ ",						"\t\t\t\t  previousLink previousLink",						"\t\t\t\t\t  partition: pivot",						"\t\t\t\t\t  inSplayHeap: aHeap",						"\t\t\t\t\t  do: [ :s :b | ",						"\t\t\t\t\t\t  | r rr |",						"\t\t\t\t\t\t  rr := aHeap",						"\t\t\t\t\t\t\t        leftBinaryTreeElement: previousLink nextLink",						"\t\t\t\t\t\t\t        value: value",						"\t\t\t\t\t\t\t        rightBinaryTreeElement: nextLink.",						"\t\t\t\t\t\t  r := aHeap",						"\t\t\t\t\t\t\t       leftBinaryTreeElement: b",						"\t\t\t\t\t\t\t       value: y",						"\t\t\t\t\t\t\t       rightBinaryTreeElement: rr.",						"\t\t\t\t\t\t  aBlock value: s value: r ] ] ]"					],					"isTestMethod" : false,					"category" : "partitioning",					"comment" : [ ],					"hash" : 54226866,					"argumentNames" : [						"pivot",						"aHeap",						"aBlock"					]				}			}		}	}}